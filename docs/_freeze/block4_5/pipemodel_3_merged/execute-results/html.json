{
  "hash": "3a8e1ac57c2544b5169a0a107b9be31c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel — Idealized valley microclimate sandbox\"\nsubtitle: \"Robust modeling + spatial CV and scale checking\"\nauthor: \"Chris Reudenbach\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    theme: cosmo\n    code-fold: true\n    number-sections: true\n    embed-resources: true\n    \nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\n\n## Why the *pipemodel*?\n\nThe **pipemodel** is a deliberately idealized yet physically plausible valley scenario. It distills terrain to the essentials (parabolic cross‑valley profile, optional features like a **north facing slope**, **right side hill** and a **a water filled pond/ or empty pit**) so that the dominant microclimate drivers become visible and quantifiable.\n\n-   **Radiation (cos i)** via slope/aspect captures sun exposure.\n-   **Elevation**: daytime *negative lapse*; pre‑dawn *weak inversion*.\n-   **Cold‑air processes**: a Gaussian pool along the valley axis.\n-   **Surface type**: water vs grass alters heating/cooling.\n\nYou can use the synthetic \"truth\" field to sample **stations**, train **interpolators** (IDW, Kriging variants, RF, GAM), and assess them with **spatial CV**.\n\n### What this setup does (and why)\n\n**Packages & options.**\nYou load a geospatial + modeling toolkit (`terra`, `sf`, `gstat`, `mgcv`, `randomForest`, `ggplot2`, etc.). `sf_use_s2(FALSE)` disables spherical geometry so nearest-feature and block joins behave predictably in a **small projected test area**. A fixed `set.seed(42)` makes the synthetic world reproducible.\n\n**Domain & grid.**\nYou define a **compact UTM scene** (500 m × 300 m at 5 m pixels). This gives enough cells to show structure (valley, hill, pond) without making interpolation or CV painfully slow. `Rtemplate` is the master raster all other rasters align to.\n\n**Feature placement (left/right thirds).**\nTwo anchors split the domain: a **hill** in the left third and a **pond/hollow** in the right third. This creates asymmetric terrain and surface types so different models (OK/KED/GAM/RF) have something meaningful to learn from.\n\n**Scenario controls (knobs).**\nAll physically motivated but simple: pond diameter/depth, hill diameter/height, **edge sharpness**, and **pool\\_block\\_gain** (reduces nocturnal cold-air pooling over the hill). These let you dial patterns up/down to probe model behavior.\n\n**Stations & layouts.**\nYou can scatter stations randomly, or enforce **N–S**/**E–W transects** with small offsets. Random layouts test generalization; transects stress models with **anisotropic** sampling. A narrow `transect_margin_m` keeps sensors inside the domain.\n\n**CV blocks & model list.**\n`block_size = 100` m builds **leave-block-out** folds with limited spatial leakage. The model set spans proximity (Voronoi/IDW), geostatistics (OK/KED), and machine learning (GAM/RF), which is great for side-by-side diagnostics and “what wins when” comparisons.\n\n**Color scale.**\nA simple blue→red palette with quantile stretching (`stretch_q`) keeps day/dawn maps visually comparable and prevents outliers from dominating.\n\n**Sun geometry & cos(i).**\n`sun_pos_utc()` computes **altitude** and **azimuth-from-north** for 14 UTC and 05 UTC on the summer solstice at your test latitude/longitude. `cosi_fun()` converts slope/aspect + sun angle into **cosine of incidence** and clamps negatives to zero (self-shade). This acts as a terrain-aware irradiance proxy that drives **daytime warming** (T14) and is near-zero at **dawn** (T05).\n\n**Scenario builder (synthetic physics).**\n\n* Base topography is a **parabolic half-pipe** (valley) along *y*.\n* Add a **circular water body or hollow** to the right and a **hill bump** to the left (crisp or smoothed edges).\n* Compute slope/aspect and `I14`/`I05 = cos(i)`.\n* Generate temperatures with interpretable terms:\n\n  * **T14 (day):** baseline + **lapse** with elevation + **surface-specific solar response** (`alpha_I_grass` vs `alpha_I_water`) + small noise.\n  * **T05 (pre-dawn):** baseline + weak **inversion** with elevation + **slope** effect (drainage proxy) − **cold-air pooling** centered on the valley axis (partially **blocked** by the hill) + small **warm water bias** + noise.\n* Any non-finite cells are replaced by the median to keep downstream modeling robust.\n\n**Station extraction & unified response.**\nFor each station you extract `z_surf`, slope, and `cos(i)` for the relevant time slot, plus the target temperature (T14 or T05). You then **rename the response to `temp`** so all models share a consistent formula/signature. The small **station table** shows coordinates, elevation, and sample T14/T05 values as a sanity check.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chunk defaults for crisp figures\nknitr::opts_chunk$set(fig.width = 9, fig.height = 6, dpi = 150)\n```\n:::\n\n\n\n## A. Setup & global knobs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages ---------------------------------------------------------------\nreq_pkgs <- c(\n  \"terra\",\"sf\",\"sp\",\"ggplot2\",\"dplyr\",\"tibble\",\"tidyr\",\n  \"suncalc\",\"gstat\",\"randomForest\",\"mgcv\",\"scales\",\"patchwork\",\"knitr\"\n)\ninst <- rownames(installed.packages())\nif (any(!req_pkgs %in% inst)) install.packages(setdiff(req_pkgs, inst), dependencies = TRUE)\ninvisible(lapply(req_pkgs, require, character.only = TRUE))\nsf::sf_use_s2(FALSE)  # robust joins in small projected domains\nset.seed(42)\n\n# Domain & grid ---------------------------------------------------------\ncrs_utm <- \"EPSG:32632\"\nE0 <- 600000; N0 <- 5725000\nlen_x <- 500; len_y <- 300; res <- 5\next <- terra::ext(E0 - len_x/2, E0 + len_x/2, N0 - len_y/2, N0 + len_y/2)\nRtemplate <- terra::rast(ext, resolution = res, crs = crs_utm)\n\nxmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\nymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\nx0 <- (xmin+xmax)/2;      y0 <- (ymin+ymax)/2\n\n# Feature placement (left/right thirds) --------------------------------\nx_hill_center <- xmin + len_x/3;   y_hill_center <- y0\nx_lake_center <- xmin + 2*len_x/3; y_lake_center <- y0\n\n# Scenario controls -----------------------------------------------------\nlake_choice <- \"water\"   # \"none\" | \"water\" | \"hollow\"\nhill_choice <- \"bump\"    # \"none\" | \"bump\"\n\nlake_diam_m  <- 80; lake_depth_m <- 10; smooth_edges <- FALSE\nhill_diam_m  <- 80; hill_height_m <- 50; hill_smooth  <- FALSE\npool_block_gain <- 0.4        # night pooling weakened over hill (0..1)\n\n# Stations --------------------------------------------------------------\nstation_mode      <- \"random\"     # \"random\" | \"ns_transect\" | \"ew_transect\"\nn_st              <- 60\ntransect_margin_m <- 10\nns_offset_m <- 0   # + east / - west\new_offset_m <- 0   # + north / - south\n\n# CV & models -----------------------------------------------------------\nblock_size <- 100  # LBO block size in meters\nmodels_use <- c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\")\n\n# Viz palettes ----------------------------------------------------------\ntemp_palette <- grDevices::colorRampPalette(c(\"#0000FF\",\"#FF0000\"))(256)  # blue->red\nstretch_q    <- c(0.02, 0.98)\n```\n:::\n\n\n\n![The pipe-valley with hill and hole and lateral virtual stations along the valley ground](pipe.png){width=\"530\"}\n\n## B. Engine: sun geometry, physics & scenario builder\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sun geometry ----------------------------------------------------------\nlat <- 51.8; lon <- 10.6\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  az_from_north <- (sp$azimuth + pi) %% (2*pi)\n  list(alt = sp$altitude, az = az_from_north)\n}\nsun14 <- sun_pos_utc(2024, 6, 21, 14, lat, lon)\nsun05 <- sun_pos_utc(2024, 6, 21,  5, lat, lon)\n\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n\n# Scenario builder ------------------------------------------------------\nbuild_scenario <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                           hill_mode = c(\"none\",\"bump\")) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / ((len_y/2)^2)              # ~100 m rim height\n  elev <- 500 + a * dy^2\n\n  # Pond/hollow (right third)\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Hill (left third)\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h <- if (hill_smooth) exp(- (rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else w_h <- 0\n\n  E <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW <- Rtemplate; terra::values(hillW) <- if (hill_mode==\"bump\") w_h else 0; names(hillW) <- \"hillW\"\n\n  # Derivatives & sun\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  # Physics\n  set.seed(1001); noise14 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  set.seed(1002); noise05 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - y0); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool      <- pool_base * (1 - pool_block_gain * hillW)\n  alpha_I_grass <- 5.0; alpha_I_water <- 1.5\n  alpha_map <- alpha_I_grass * (1 - lakeR) + alpha_I_water * lakeR\n  warm_bias_water_dawn <- if (lake_mode==\"water\") 1.5 else 0\n\n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_map * I14 + noise14; names(R14) <- \"T14\"\n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool + warm_bias_water_dawn * lakeR + noise05; names(R05) <- \"T05\"\n\n  # Replace non‑finite with median\n  fix_nonfinite <- function(r) { v <- terra::values(r); m <- stats::median(v[is.finite(v)], na.rm = TRUE); v[!is.finite(v)] <- m; terra::values(r) <- v; r }\n  list(E = fix_nonfinite(E), R14 = fix_nonfinite(R14), R05 = fix_nonfinite(R05),\n       lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05)\n}\n\nscen <- build_scenario(lake_choice, hill_choice)\n\nsummary(scen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Length Class      Mode\nE     1      SpatRaster S4  \nR14   1      SpatRaster S4  \nR05   1      SpatRaster S4  \nlake  1      SpatRaster S4  \nhillW 1      SpatRaster S4  \nslp   1      SpatRaster S4  \nasp   1      SpatRaster S4  \nI14   1      SpatRaster S4  \nI05   1      SpatRaster S4  \n```\n\n\n:::\n:::\n\n\n\n## C. Stations: sampling & extraction\n\n* Station layout: it creates station coordinates either randomly across the domain or along a north–south or east–west transect. The transect_margin_m keeps points away from the border; the optional offsets shift the transect without leaving the domain.\n\n* Geospatial objects: the plain tibble pts is turned into an sf object (pts_sf) with the projected CRS and a terra vector (vpts). That lets you extract raster values precisely at the station locations.\n\n* Feature/target extraction: from the scenario rasters you pull (i) surface elevation (z_surf), (ii) slope (slp), (iii) a sun–terrain proxy I14/I05 (saved as cosi later), and the temperatures T14/T05 that act as targets.\n\n* Time-specific completeness: for each time slot (14 UTC / 05 UTC) you keep only rows with complete inputs for that slot. This avoids NA leakage in model fitting while retaining stations that may be missing only one time.\n\n* Unified schema for modeling: you build stn_sf_14 and stn_sf_05 with the same columns and rename the response to temp (and irradiance proxy to cosi). Unifying names means the exact same modeling code (GAM, RF, kriging, etc.) can run for both times without branching.\n\n* Sanity check table: a compact preview of the first 15 stations with rounded coordinates, elevation, and temps lets you quickly spot obvious issues (e.g., duplicated IDs, extreme values, or suspicious elevations).\n\n* Small but important details: keeping x/y as numeric columns (in addition to geometry) helps methods that expect explicit coordinates; using a projected CRS (UTM) ensures distances are in meters for interpolation and block-CV later.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Station coordinates ---------------------------------------------------\nif (station_mode == \"random\") {\n  pts <- tibble::tibble(\n    id = 1:n_st,\n    x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n    y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n  )\n} else if (station_mode == \"ns_transect\") {\n  x_const <- min(max(x0 + ns_offset_m, xmin + transect_margin_m), xmax - transect_margin_m)\n  y_seq   <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_const, y = y_seq)\n} else if (station_mode == \"ew_transect\") {\n  y_const <- min(max(y0 + ew_offset_m, ymin + transect_margin_m), ymax - transect_margin_m)\n  x_seq   <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_seq, y = y_const)\n} else stop(\"Unknown station_mode\")\n\npts_sf <- sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\nvpts   <- terra::vect(pts_sf)\n\n# Extract covariates & targets -----------------------------------------\npts$z_surf <- as.numeric(terra::extract(scen$E,   vpts, ID = FALSE)[,1])\npts$slp    <- as.numeric(terra::extract(scen$slp, vpts, ID = FALSE)[,1])\npts$I14    <- as.numeric(terra::extract(scen$I14, vpts, ID = FALSE)[,1])\npts$I05    <- as.numeric(terra::extract(scen$I05, vpts, ID = FALSE)[,1])\npts$T14    <- as.numeric(terra::extract(scen$R14, vpts, ID = FALSE)[,1])\npts$T05    <- as.numeric(terra::extract(scen$R05, vpts, ID = FALSE)[,1])\n\n# Keep complete rows per time slot -------------------------------------\npts14 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I14\",\"T14\")]), ]\npts05 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I05\",\"T05\")]), ]\n\n# Unify response name to 'temp' ----------------------------------------\nstn_sf_14 <- pts14 |>\n  dplyr::transmute(id, x, y,\n                   z_surf = as.numeric(z_surf),\n                   slp    = as.numeric(slp),\n                   cosi   = as.numeric(I14),\n                   temp   = as.numeric(T14)) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\nstn_sf_05 <- pts05 |>\n  dplyr::transmute(id, x, y,\n                   z_surf = as.numeric(z_surf),\n                   slp    = as.numeric(slp),\n                   cosi   = as.numeric(I05),\n                   temp   = as.numeric(T05)) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\n# Quick station table ---------------------------------------------------\nknitr::kable(\n  head(pts,15) |>\n    dplyr::transmute(id, easting = round(x), northing = round(y),\n                      z_surf = round(z_surf,1), T14_C = round(T14,1), T05_C = round(T05,1)),\n  caption = \"Station sample (sanity check)\", digits = 1\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Station sample (sanity check)\n\n| id| easting| northing| z_surf| T14_C| T05_C|\n|--:|-------:|--------:|------:|-----:|-----:|\n|  1|  600182|  5724912|  534.0|  28.1|   7.6|\n|  2|  599785|  5724917|  530.2|  27.9|   8.2|\n|  3|  600093|  5724994|  490.2|  27.5|   5.6|\n|  4|  600061|  5724914|  534.0|  28.5|   8.4|\n|  5|  600006|  5725001|  500.0|  30.1|   4.8|\n|  6|  600056|  5725136|  584.0|  28.6|   8.7|\n|  7|  600227|  5725015|  500.7|  30.5|   4.5|\n|  8|  600209|  5725074|  523.4|  30.0|   7.5|\n|  9|  599878|  5724950|  510.0|  29.5|   6.0|\n| 10|  600160|  5724901|  542.2|  27.8|   8.7|\n| 11|  599799|  5724871|  572.2|  27.1|   8.7|\n| 12|  599844|  5724936|  517.4|  28.5|   6.8|\n| 13|  600003|  5724861|  584.0|  26.6|   9.0|\n| 14|  600023|  5724932|  520.2|  28.5|   7.0|\n| 15|  599984|  5724932|  520.2|  28.6|   7.2|\n\n\n:::\n:::\n\n\n\n## D. Modeling helpers\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grid blocks for LBO-CV ------------------------------------------------\nmake_blocks_and_assign <- function(pts_sf, E, block_size = 100) {\n  bb <- sf::st_as_sfc(\n    sf::st_bbox(\n      c(xmin = terra::xmin(E), ymin = terra::ymin(E), xmax = terra::xmax(E), ymax = terra::ymax(E)),\n      crs = sf::st_crs(pts_sf)\n    )\n  )\n  gr <- sf::st_make_grid(bb, cellsize = c(block_size, block_size), what = \"polygons\")\n  blocks <- sf::st_sf(block_id = seq_along(gr), geometry = gr)\n  pts_blk <- sf::st_join(pts_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (any(is.na(pts_blk$block_id))) {\n    nearest <- sf::st_nearest_feature(pts_blk[is.na(pts_blk$block_id), ], blocks)\n    pts_blk$block_id[is.na(pts_blk$block_id)] <- blocks$block_id[nearest]\n  }\n  list(blocks = blocks, pts = pts_blk)\n}\n\nplot_blocks_grid <- function(blocks, pts_blk, title = \"Blocks & stations\") {\n  ggplot() +\n    geom_sf(data = blocks, fill = NA, color = \"grey50\", linewidth = 0.2) +\n    geom_sf(data = pts_blk, aes(color = factor(block_id)), size = 2) +\n    scale_color_brewer(palette = \"Set2\", name = \"Block\") +\n    coord_sf(expand = FALSE) + theme_minimal() +\n    labs(title = title, x = \"Easting\", y = \"Northing\")\n}\n\n# GAM helpers -----------------------------------------------------------\nfit_gam_safe <- function(stn_sf) {\n  d <- stn_sf |> sf::st_drop_geometry()\n  d <- d[stats::complete.cases(d), , drop = FALSE]\n  n <- nrow(d); if (n < 10) stop(\"Too few stations for GAM: n=\", n)\n  n_xy <- dplyr::n_distinct(paste0(round(d$x,3), \"_\", round(d$y,3)))\n  k_xy <- max(10, min(60, n_xy - 1, floor(n * 0.8)))\n  k1   <- function(v, kmax=15) { ku <- length(unique(d[[v]])); max(4, min(ku - 1, kmax)) }\n  mgcv::gam(temp ~ s(x,y,bs='tp',k=k_xy) + s(z_surf,bs='tp',k=k1(\"z_surf\",20)) +\n              s(slp,bs='tp',k=k1(\"slp\",12)) + s(cosi,bs='tp',k=k1(\"cosi\",12)),\n            data = d, method = \"REML\", select = TRUE)\n}\n\n# Pointwise predictors --------------------------------------------------\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf); as.numeric(train_sf$temp)[idx]\n}\n\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  pr <- gstat::idw(temp ~ 1, as(train_sf[\"temp\"], \"Spatial\"), newdata = as(test_sf, \"Spatial\"), idp = idp)\n  as.numeric(pr$var1.pred)\n}\n\npred_OK <- function(train_sf, test_sf) {\n  tr_sp <- as(train_sf[\"temp\"], \"Spatial\")\n  vg    <- gstat::variogram(temp ~ 1, tr_sp)\n  vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(train_sf$temp, na.rm=TRUE), model=\"Exp\", range=100)\n  kr <- gstat::krige(temp ~ 1, locations = tr_sp, newdata = as(test_sf, \"Spatial\"), model = vgm_fit)\n  as.numeric(kr$var1.pred)\n}\n\npred_KED <- function(train_sf, test_sf, E = NULL) {\n  if (is.null(E)) stop(\"pred_KED: provide raster E for fallback elevation extraction.\")\n  add_z <- function(s) { if (!(\"z_surf\" %in% names(s)) || any(!is.finite(s$z_surf))) { z <- terra::extract(E, sf::st_coordinates(s))[,1]; s$z_surf <- as.numeric(z) }; s }\n  train_sf <- add_z(train_sf); test_sf <- add_z(test_sf)\n  tr_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(train_sf), data = data.frame(temp = train_sf$temp, z_surf = as.numeric(train_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(train_sf)$wkt))\n  tr_sp <- tr_sp[stats::complete.cases(tr_sp@data), ]\n  te_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(test_sf), data = data.frame(z_surf = as.numeric(test_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(test_sf)$wkt))\n  vg <- gstat::variogram(temp ~ z_surf, tr_sp)\n  vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(tr_sp$temp, na.rm=TRUE), model=\"Exp\", range=100)\n  pr <- gstat::krige(temp ~ z_surf, locations = tr_sp, newdata = te_sp, model = vgm_fit)\n  as.numeric(pr$var1.pred)\n}\n\npred_RF <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf); dtr <- stats::na.omit(dtr)\n  if (nrow(dtr) < 5) return(rep(NA_real_, nrow(test_sf)))\n  rf  <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi, data = dtr, na.action = na.omit)\n  dte <- sf::st_drop_geometry(test_sf)\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n  out <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(rf, dte[good, ])\n  out\n}\n\npred_GAM <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf); dtr <- dtr[stats::complete.cases(dtr), , drop = FALSE]\n  if (nrow(dtr) < 10) return(rep(NA_real_, nrow(test_sf)))\n  gm <- fit_gam_safe(train_sf)\n  dte <- sf::st_drop_geometry(test_sf)\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n  out <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(gm, dte[good, ], type=\"response\")\n  out\n}\n\n# Leave-Block-Out CV ----------------------------------------------------\nrun_lbo_cv <- function(stn_sf, E, block_size = 100, models = models_use) {\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) {\n    xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2]\n  }\n  blk <- make_blocks_and_assign(stn_sf, E, block_size = block_size)\n  blocks_sf <- blk$blocks; stn_blk <- blk$pts\n  restore <- function(nm) if (!(nm %in% names(stn_blk))) stn_blk[[nm]] <<- stn_sf[[nm]][match(stn_blk$id, stn_sf$id)]\n  for (nm in c(\"temp\",\"z_surf\",\"slp\",\"cosi\",\"x\",\"y\")) restore(nm)\n\n  block_ids <- sort(unique(stn_blk$block_id))\n  out_list <- vector(\"list\", length(block_ids))\n  for (k in seq_along(block_ids)) {\n    b <- block_ids[k]\n    test_idx  <- which(stn_blk$block_id == b)\n    train_idx <- which(stn_blk$block_id != b)\n    train_sf <- stn_blk[train_idx, ]; test_sf <- stn_blk[test_idx, ]\n    pred_tbl <- lapply(models, function(m) {\n      p <- switch(m,\n        \"Voronoi\" = pred_Voronoi(train_sf, test_sf),\n        \"IDW\"     = pred_IDW(train_sf, test_sf),\n        \"OK\"      = pred_OK(train_sf, test_sf),\n        \"KED\"     = pred_KED(train_sf, test_sf, E = E),\n        \"RF\"      = pred_RF(train_sf, test_sf),\n        \"GAM\"     = pred_GAM(train_sf, test_sf),\n        stop(\"Unknown model: \", m)\n      )\n      tibble::tibble(model = m, id = test_sf$id, obs = test_sf$temp, pred = p, block_id = b)\n    })\n    out_list[[k]] <- dplyr::bind_rows(pred_tbl)\n  }\n\n  cv_tbl <- dplyr::bind_rows(out_list)\n  metrics <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(\n      n    = dplyr::n(),\n      MAE  = mean(abs(obs - pred), na.rm = TRUE),\n      RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)),\n      Bias = mean(pred - obs, na.rm = TRUE),\n      R2   = cor(obs, pred, use = \"complete.obs\")^2,\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n\n  diag_plot <- ggplot(cv_tbl, aes(obs, pred)) +\n    geom_abline(slope=1, intercept=0, linetype=\"dashed\") +\n    geom_point(alpha=0.7) +\n    coord_equal() + theme_minimal() +\n    labs(title = sprintf(\"LBO-CV (block = %dm) — Observed vs Predicted\", block_size), x = \"Observed\", y = \"Predicted\") +\n    facet_wrap(~ model)\n\n  blocks_plot <- plot_blocks_grid(blocks_sf, stn_blk, title = sprintf(\"Blocks (%.0f m) & stations\", block_size))\n  list(cv = cv_tbl, metrics = metrics, diag_plot = diag_plot, blocks_plot = blocks_plot)\n}\n\n# Prediction maps & error panels ---------------------------------------\n.make_labeller <- function(cv_tbl) {\n  m <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE  = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\")\n  setNames(sprintf(\"%s  (RMSE=%.2f · MAE=%.2f)\", m$model, m$RMSE, m$MAE), m$model)\n}\n\npredict_maps <- function(stn_sf, truth_raster, which_time = c(\"T14\",\"T05\"), scen, models = models_use) {\n  which_time <- match.arg(which_time)\n  E <- scen$E; slp_r <- scen$slp; cosi_r <- if (which_time == \"T14\") scen$I14 else scen$I05\n  train_sf <- stn_sf\n  if (!all(c(\"x\",\"y\") %in% names(train_sf))) { xy <- sf::st_coordinates(train_sf); train_sf$x <- xy[,1]; train_sf$y <- xy[,2] }\n  if (!(\"z_surf\" %in% names(train_sf))) train_sf$z_surf <- as.numeric(terra::extract(E,      sf::st_coordinates(train_sf))[,1])\n  if (!(\"slp\"    %in% names(train_sf))) train_sf$slp    <- as.numeric(terra::extract(slp_r,  sf::st_coordinates(train_sf))[,1])\n  if (!(\"cosi\"   %in% names(train_sf))) train_sf$cosi   <- as.numeric(terra::extract(cosi_r, sf::st_coordinates(train_sf))[,1])\n\n  grid_df <- as.data.frame(c(E, slp_r, cosi_r), xy = TRUE, na.rm = FALSE); names(grid_df) <- c(\"x\",\"y\",\"elev\",\"slp\",\"cosi\"); grid_df$z_surf <- grid_df$elev\n  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\",\"y\"), crs = sf::st_crs(train_sf), remove = FALSE)\n  good_grid <- stats::complete.cases(grid_df[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n\n  pred_list <- list()\n  if (\"Voronoi\" %in% models) { idx <- sf::st_nearest_feature(grid_sf, train_sf); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(train_sf$temp)[idx[good_grid]]; pred_list$Voronoi <- tmp }\n\n  grid_sp <- as(grid_sf, \"Spatial\")\n  if (\"IDW\" %in% models) { message(\"[inverse distance weighted interpolation]\"); tr_sp <- as(train_sf[\"temp\"], \"Spatial\"); pr <- gstat::idw(temp ~ 1, locations = tr_sp, newdata = grid_sp, idp = 2); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$IDW <- tmp }\n  if (\"OK\"  %in% models) { message(\"[using ordinary kriging]\"); tr_sp <- as(train_sf[\"temp\"], \"Spatial\"); vg <- gstat::variogram(temp ~ 1, tr_sp); vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE); if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(train_sf$temp, na.rm = TRUE), model = \"Exp\", range = 100); pr  <- gstat::krige(temp ~ 1, locations = tr_sp, newdata = grid_sp, model = vgm_fit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$OK <- tmp }\n  if (\"KED\" %in% models) { message(\"[using universal kriging]\"); tr_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(train_sf), data = data.frame(temp = train_sf$temp, z_surf = as.numeric(train_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(train_sf)$wkt)); tr_sp <- tr_sp[stats::complete.cases(tr_sp@data), ]; stopifnot(\"z_surf\" %in% names(grid_sp@data)); vg <- gstat::variogram(temp ~ z_surf, tr_sp); vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE); if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(tr_sp$temp, na.rm = TRUE), model = \"Exp\", range = 100); pr  <- gstat::krige(temp ~ z_surf, locations = tr_sp, newdata = grid_sp, model = vgm_fit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$KED <- tmp }\n  if (\"RF\"  %in% models) { dtr <- sf::st_drop_geometry(train_sf); dtr <- stats::na.omit(dtr); rf <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi, data = dtr, na.action = na.omit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- stats::predict(rf, grid_df[good_grid, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")]); pred_list$RF <- tmp }\n  if (\"GAM\" %in% models) { dtr <- sf::st_drop_geometry(train_sf); n <- nrow(dtr); k_xy <- max(10, min(60, n - 5)); gm  <- mgcv::gam(temp ~ s(x,y,k=k_xy) + s(z_surf,k=15) + s(slp,k=12) + s(cosi,k=12), data = dtr, method = \"REML\"); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- stats::predict(gm, grid_df[good_grid, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")], type=\"response\"); pred_list$GAM <- tmp }\n\n  pred_df  <- dplyr::bind_rows(lapply(names(pred_list), function(nm) { tibble::tibble(model = nm, x = grid_df$x, y = grid_df$y, pred = pred_list[[nm]]) }))\n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE); names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  lims <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n\n  p_pred <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(.make_labeller(data.frame(obs=pred_df$pred, pred=pred_df$pred, model=pred_df$model))))\n\n  p_truth <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time), x = \"Easting\", y = \"Northing\")\n\n  list(pred_df = pred_df, p_pred = p_pred, p_truth = p_truth)\n}\n\n# Error/diagnostic panels ----------------------------------------------\nblock_metrics_long <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"block_id\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  cv_tbl |>\n    dplyr::group_by(model, block_id) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\") |>\n    tidyr::pivot_longer(c(RMSE, MAE), names_to = \"Metric\", values_to = \"Value\")\n}\n\norder_models_by_median_rmse <- function(cv_tbl) {\n  bm <- block_metrics_long(cv_tbl)\n  bm |>\n    dplyr::filter(Metric == \"RMSE\") |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(Value, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n}\n\nmake_block_metric_box <- function(cv_tbl, which_time = \"T14\") {\n  bm <- block_metrics_long(cv_tbl)\n  lev <- order_models_by_median_rmse(cv_tbl)\n  bm$model <- factor(bm$model, levels = lev)\n  ggplot2::ggplot(bm, ggplot2::aes(model, Value)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.35, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3, fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Block-wise errors (LBO-CV)\", which_time), subtitle = \"Box = IQR · line = median · ◆ = mean\", x = \"Model\", y = \"Error\") +\n    ggplot2::facet_wrap(~ Metric, scales = \"free_y\")\n}\n\nmake_abs_error_box <- function(cv_tbl, which_time = \"T14\") {\n  df <- cv_tbl |> dplyr::mutate(abs_err = abs(pred - obs))\n  lev <- df |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(abs_err, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n  df$model <- factor(df$model, levels = lev)\n  ggplot2::ggplot(df, ggplot2::aes(model, abs_err)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.3, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3, fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Absolute errors per station (LBO-CV)\", which_time), subtitle = \"Box = IQR · line = median · ◆ = mean\", x = \"Model\", y = \"|pred − obs|\")\n}\n\nbuild_panels_with_errors <- function(maps, truth_raster, cv_tbl, stn_sf, which_time, temp_palette = temp_palette, stretch_q = stretch_q) {\n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE); names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  pred_df  <- maps$pred_df\n  err_df   <- dplyr::inner_join(pred_df, truth_df, by = c(\"x\",\"y\")) |>\n    dplyr::mutate(err = pred - truth)\n  emax <- max(abs(err_df$err), na.rm = TRUE); emax <- if (is.finite(emax)) emax else 1\n  lims_T <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n  coords  <- sf::st_coordinates(stn_sf)\n  st_xy   <- tibble::tibble(id = stn_sf$id, x = coords[,1], y = coords[,2])\n  st_res  <- cv_tbl |>\n    dplyr::mutate(resid = pred - obs) |>\n    dplyr::select(model, id, resid) |>\n    dplyr::left_join(st_xy, by = \"id\")\n  lab <- .make_labeller(cv_tbl)\n  p_truth <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims_T, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time), x = \"Easting\", y = \"Northing\")\n  p_pred <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims_T, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n  p_err <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = err_df, ggplot2::aes(x, y, fill = err)) +\n    ggplot2::scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#de2d26\", midpoint = 0, limits = c(-emax, emax), name = \"Error\") +\n    ggplot2::geom_point(data = st_res, ggplot2::aes(x, y, fill = resid), shape = 21, colour = \"black\", size = 2, stroke = 0.2) +\n    ggplot2::scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#de2d26\", midpoint = 0, limits = c(-emax, emax), name = \"Error\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Error (pred − truth) with CV residuals\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n  (p_truth | p_pred) / p_err\n}\n```\n:::\n\n\n\n## E. Run models with spatial CV and plot\n\n### Model Cheat-Sheets (what/why/when)\n\n**Voronoi / Nearest Neighbor (NN)**\n**Idea:** Assign the value of the closest station (piecewise-constant Voronoi cells).\n**Strengths:** Zero tuning, bulletproof baseline, extremely fast.\n**Watch-outs:** Blocky maps; ignores elevation/drift; strong edge effects.\n**Use when:** Very small n, quick sanity maps, mandatory “no-magic” baseline.\n**Quick settings:** None (always include as a baseline).\n\n**IDW (Inverse Distance Weighting)**\n**Idea:** Weighted average of neighbors; weights ∝ distance^(-p).\n**Strengths:** Simple; no variogram needed; local and responsive.\n**Watch-outs:** Choice of p/radius drives results; no uncertainty; can smear terrain effects.\n**Use when:** Medium n; variogram unreliable; fast preview needed.\n**Quick settings:** `idp ≈ 1.5–2.0`; search radius ≈ **R**\\*; min neighbors 5–8; tune with **L-block CV**.\n\n**OK — Ordinary Kriging**\n**Idea:** Geostatistical best linear unbiased prediction from a fitted variogram + geometry.\n**Strengths:** Sound; provides kriging variance; great if (residual) field is stationary.\n**Watch-outs:** Needs a decent variogram; sensitive with few points; unmodeled trends cause bias.\n**Use when:** Enough stations (≈≥12–15); weak trend or trend modeled elsewhere; need uncertainty.\n**Quick settings:** Start `vgm(\"Exp\")`/Spherical; range \\~ L50–L95; nugget from short-scale noise; neighborhood radius ≈ **R**\\*; **L-block CV**.\n\n**KED — Kriging with External Drift (aka Universal Kriging)**\n**Idea:** Trend (e.g., DEM, slope, aspect) in the mean; kriging on the residuals.\n**Strengths:** Captures topo/insolation gradients; often beats OK/IDW; has uncertainty.\n**Watch-outs:** Drift must be meaningful; residual variogram must be stationary; collinearity possible.\n**Use when:** Clear elevation/radiation effects; good raster predictors available.\n**Quick settings:** Drift = `z_surf` (+ `slope`, `aspect`, `TRI`, `cosi`); fit variogram on residuals; radius ≈ **R**\\*; **L-block CV**.\n\n**TPS — Thin Plate Splines**\n**Idea:** Smooth global spline over x,y (and optionally predictors via GAM).\n**Strengths:** Very smooth surfaces; no variogram required.\n**Watch-outs:** Global smoothing → edge artifacts; GCV can be unstable; no spatial uncertainty.\n**Use when:** You want a very smooth map or the variogram is unstable.\n**Quick settings:** If using `fields::Tps` leave default GCV; if via GAM, use `s(x, y, bs=\"tp\")`, control `k`.\n\n**GAM — Generalized Additive Model**\n**Idea:** Flexible trend surface: `temp ~ s(x,y) + s(DEM) + s(slope) + s(cosi) + …`.\n**Strengths:** Handles nonlinearity & nonstationarity via predictors; interpretable partial effects; robust with REML.\n**Watch-outs:** No geostatistical uncertainty; spatial residuals may persist (consider cascading with OK).\n**Use when:** Predictors are informative (DEM, slope, aspect, sun), n is moderate+.\n**Quick settings:** `method=\"REML\", select=TRUE`; `s(x,y, k≈min(60, 0.8*n_unique))`; `s(z_surf, k≈10–20)`; `s(slp, k≈8–12)`; `s(cosi, k≈8–12)`; **L-block CV**.\n\n**RF — Random Forest (x,y + predictors)**\n**Idea:** Non-parametric ensemble using trees.\n**Strengths:** Captures strong nonlinearities & interactions; little tuning; robust.\n**Watch-outs:** Coordinates aren’t a spatial model; extrapolation can blotch; no kriging variance.\n**Use when:** Many useful predictors; aim to minimize RMSE/MAE; n≥\\~30–50.\n**Quick settings:** `ntree=500–1000`; `mtry≈sqrt(p)`; slightly larger `nodesize` (2–5); **L-block CV**; features: `x, y, DEM, slope, aspect, cosi, …`.\n\n**Cascaded (Hybrid) Trend + Residual Kriging**\n**Idea:** Fit **GAM** (or **KED**) for the large-scale trend, then **OK** the residuals, add back the trend.\n**Strengths:** Marries interpretability & nonstationary drift (trend) with geostatistical fine structure (residuals).\n**Watch-outs:** Two models to maintain; ensure residuals are roughly stationary before OK.\n**Quick settings:** Tune **R**\\* via L-block CV on the trend model (use `[L50, L95]` range). Use **R**\\* as OK neighborhood radius.\n\n---\n\n# One-Page Summary Table\n\n| Model                 | Core idea                            | Best for                       | Strengths                           | Watch-outs                                | Tune first                                       |\n| --------------------- | ------------------------------------ | ------------------------------ | ----------------------------------- | ----------------------------------------- | ------------------------------------------------ |\n| Voronoi (NN)          | Closest station value                | Tiny n, baseline               | Zero tuning, very fast              | Blocky, no drift, edge-sensitive          | None                                             |\n| IDW                   | Distance-weighted mean (∝ d^−p)      | Medium n, no variogram         | Simple, local                       | p/radius dominate; no uncertainty         | `idp≈1.5–2.0`, radius≈**R**\\*, ≥5–8 neighbors    |\n| OK                    | Kriging with constant mean           | Stationary fields, uncertainty | Statistically optimal; variance map | Needs variogram; trend bias               | Variogram (range \\~ L50–L95); radius≈**R**\\*     |\n| KED (UK)              | Kriging + external drift             | Clear topo/radiation trend     | Uses DEM/slope/etc.; variance map   | Drift must be good; residual stationarity | Drift set; residual variogram; radius≈**R**\\*    |\n| TPS                   | Smooth radial spline                 | Very smooth maps               | No variogram; smooth                | Edge artifacts; no variance               | GCV/REML; limit `k` if needed                    |\n| GAM                   | Additive smooths of x,y & predictors | Nonstationary trend            | Flexible, interpretable             | No geo-variance; residual spatiality      | `REML`, `select=TRUE`, sensible `k`              |\n| RF                    | Tree ensemble (x,y + rasters)        | Many predictors; RMSE focus    | Nonlinear, robust                   | Weak spatial extrapolation; no variance   | `ntree`, `mtry≈sqrt(p)`, L-block CV              |\n| Cascaded GAM/KED → OK | Trend + kriged residuals             | Nonstationary + fine structure | Best of both worlds                 | 2-stage complexity                        | Tune **R**\\* on trend; OK residuals with **R**\\* |\n\n---\n\n## Fast decision guide (for your dataset)\n\n* **n < \\~8–10:** Voronoi or IDW (p≈2) as a pragmatic map + baseline metrics.\n* **Variogram stable, weak drift:** OK (range \\~ L50–L95).\n* **Strong DEM/insolation signal:** KED **or** GAM → **OK residuals** (cascaded).\n* **Many predictors, aim for lowest RMSE:** RF (with L-block CV).\n* **You want extra-smooth maps:** TPS or GAM.\n\n\n\n## Safe defaults \n\n* **Blocking:** `use_blocks = \"L\"` (derived from L50/L95), `k = 5`.\n* **R\\*** candidates: auto from `[L50, L95]`; if tiny sample, try `c(20,30,40,60,80)` m.\n* **Neighbors:** min 5–8 for IDW/OK/KED.\n* **GAM:** `s(x,y, k<=60)`, `s(z_surf, k=10–20)`, `s(slp, k=8–12)`, `s(cosi, k=8–12)`, `method=\"REML\"`, `select=TRUE`.\n* **RF:** `ntree=500–1000`, `mtry≈sqrt(p)`, `nodesize=2–5`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# LBO-CV & prediction maps ---------------------------------------------\nmessage(\"Running LBO-CV and building maps for T14 ...\")\nres14  <- run_lbo_cv(stn_sf_14, scen$E, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps14 <- predict_maps(stn_sf_14, scen$R14, which_time = \"T14\", scen = scen, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T05 ...\")\nres05  <- run_lbo_cv(stn_sf_05, scen$E, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps05 <- predict_maps(stn_sf_05, scen$R05, which_time = \"T05\", scen = scen, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\n# Spatial blocks + Obs-vs-Pred -----------------------------------------\n(res14$blocks_plot | res14$diag_plot) / (res05$blocks_plot | res05$diag_plot)\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/running-models-1.png){width=1350}\n:::\n:::\n\n\n\n### Truth, predictions & error panels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npanel14 <- build_panels_with_errors(maps14, scen$R14, res14$cv, stn_sf_14, \"T14\", temp_palette = temp_palette, stretch_q = stretch_q)\npanel05 <- build_panels_with_errors(maps05, scen$R05, res05$cv, stn_sf_05, \"T05\", temp_palette = temp_palette, stretch_q = stretch_q)\npanel14\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/unnamed-chunk-6-1.png){width=1350}\n:::\n\n```{.r .cell-code}\npanel05\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/unnamed-chunk-6-2.png){width=1350}\n:::\n:::\n\n\n\n### Block‑wise and per‑station errors\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_block_box14  <- make_block_metric_box(res14$cv, \"T14\")\np_abserr_box14 <- make_abs_error_box(res14$cv,  \"T14\")\np_block_box05  <- make_block_metric_box(res05$cv, \"T05\")\np_abserr_box05 <- make_abs_error_box(res05$cv,  \"T05\")\n\n(p_block_box14 | p_abserr_box14) / (p_block_box05 | p_abserr_box05)\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/unnamed-chunk-7-1.png){width=1350}\n:::\n:::\n\n\n\n### LBO‑CV metrics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(res14$metrics, digits = 3, caption = \"LBO‑CV metrics — T14\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO‑CV metrics — T14\n\n|model   |  n|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|-----:|-----:|------:|-----:|\n|GAM     | 60| 0.418| 0.734|  0.160| 0.582|\n|RF      | 60| 0.568| 0.796|  0.036| 0.460|\n|KED     | 60| 0.682| 0.872| -0.098| 0.365|\n|OK      | 60| 0.771| 0.993| -0.059| 0.156|\n|IDW     | 60| 0.838| 1.032| -0.031| 0.082|\n|Voronoi | 60| 0.887| 1.248| -0.051| 0.069|\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(res05$metrics, digits = 3, caption = \"LBO‑CV metrics — T05\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO‑CV metrics — T05\n\n|model   |  n|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|-----:|-----:|------:|-----:|\n|GAM     | 60| 0.420| 0.600|  0.055| 0.815|\n|RF      | 60| 0.506| 0.643|  0.066| 0.786|\n|KED     | 60| 0.662| 0.831|  0.061| 0.628|\n|OK      | 60| 0.773| 1.023| -0.078| 0.435|\n|IDW     | 60| 1.084| 1.323| -0.108| 0.055|\n|Voronoi | 60| 1.108| 1.373|  0.199| 0.216|\n\n\n:::\n:::\n\n\n\n---\n\n# H. Physics & Scenario Builder — Cheat Sheet\n\n## H.1 Generated rasters & derived fields\n\n| Name          | Unit | What it is                             | How it’s built                                                              |\n| ------------- | ---: | -------------------------------------- | --------------------------------------------------------------------------- |\n| `E` (`elev`)  |    m | Ground elevation                       | Parabolic “half-pipe” across **y**, + optional hill, − optional pond/hollow |\n| `slp`         |  rad | Slope (terrain steepness)              | `terra::terrain(E, \"slope\", \"radians\")`                                     |\n| `asp`         |  rad | Aspect (downslope direction)           | `terra::terrain(E, \"aspect\", \"radians\")`                                    |\n| `I14`, `I05`  |    – | Cosine of solar incidence at 14/05 UTC | `cosi_fun(alt, az, slp, asp)`, clamped at 0                                 |\n| `lake`        |  0/1 | Water mask (1 if pond is water)        | Disk at right third; only 1 when `lake_choice == \"water\"`                   |\n| `hillW`       |  0–1 | Hill weight (1 inside hill footprint)  | Disk at left third (or smooth Gaussian if enabled)                          |\n| `R14` (`T14`) |   °C | Daytime “truth” temperature            | See equation below                                                          |\n| `R05` (`T05`) |   °C | Pre-dawn “truth” temperature           | See equation below                                                          |\n\n## H.2 Governing equations\n\nLet $\\overline{E}$ be mean elevation, and `pool` the cold-air pooling term:\n\n$$\n\\begin{aligned}\nT_{14} &= T0_{14} \\;+\\; \\texttt{lapse\\_14}\\,(E-\\overline{E})\n\\;+\\; \\alpha_{\\text{map}}\\, I_{14}\n\\;+\\; \\varepsilon_{14}, \\\\\nT_{05} &= T0_{05} \\;+\\; \\texttt{inv\\_05}\\,(E-\\overline{E})\n\\;+\\; \\eta_{\\text{slope}}\\,\\texttt{slp}\n\\;-\\; \\texttt{pool}\n\\;+\\; \\texttt{warm\\_bias\\_water\\_dawn}\\cdot \\texttt{lake}\n\\;+\\; \\varepsilon_{05}.\n\\end{aligned}\n$$\n\n**Terms**\n\n* $\\alpha_{\\text{map}} = \\alpha_{I,\\text{grass}}\\cdot(1-\\texttt{lake}) + \\alpha_{I,\\text{water}}\\cdot\\texttt{lake}$.\n* `pool` = $A \\exp[-(d_y/w)^2]\\cdot(1 - \\texttt{pool\\_block\\_gain}\\cdot \\texttt{hillW})$, where $d_y=|y - y_0|$.\n* Noise $\\varepsilon_{14}, \\varepsilon_{05} \\sim \\mathcal{N}(0, 0.3^2)$ (independent by cell/time).\n\n## H.3 Dial summary (parameters you can tweak)\n\n| Parameter                    |               Default | Sensible range | Affects                    | Visual signature when increased (+)                  |                                                |                                                                              |\n| ---------------------------- | --------------------: | -------------: | -------------------------- | ---------------------------------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------- |\n| `T0_14`                      |               26.0 °C |          20–35 | T14 baseline               | Whole map warms uniformly                            |                                                |                                                                              |\n| `lapse_14`                   |          −0.0065 °C/m |   −0.01…−0.002 | T14 vs elevation           | Stronger cool-with-height (rim cooler, floor warmer) |                                                |                                                                              |\n| `αI_grass` (`alpha_I_grass`) |                   5.0 |            1–6 | T14 exposure               | Sun-facing slopes pop warmer by day                  |                                                |                                                                              |\n| `αI_water` (`alpha_I_water`) |                   1.5 |          0.2–3 | T14 over water             | Water heats less by day; lake flatter/ cooler        |                                                |                                                                              |\n| `T0_05`                      |                8.5 °C |           3–15 | T05 baseline               | Whole map warms uniformly                            |                                                |                                                                              |\n| `inv_05`                     |           +0.003 °C/m |        0–0.008 | T05 vs elevation           | Inversion strength: valley floor cooler vs rims      |                                                |                                                                              |\n| `η_slope` (`eta_slope`)      |                   0.6 |          0–1.5 | T05 topographic flow proxy | Steeper slopes slightly warmer at dawn               |                                                |                                                                              |\n| `pool_base` amplitude        |                 4.0 K |            1–8 | T05 pooling                | Stronger cold band along valley axis (blue stripe)   |                                                |                                                                              |\n| `w_pool` (m)                 |                    70 |         40–150 | T05 pooling width          | Narrower/ broader cold band                          |                                                |                                                                              |\n| `pool_block_gain`            |                   0.4 |            0–1 | T05 pooling near hill      | Suppresses pooling over hill; lee side warms         |                                                |                                                                              |\n| `warm_bias_water_dawn`       | 1.5 K (only if water) |            0–3 | T05 over water             | Lake area warmer pre-dawn                            |                                                |                                                                              |\n| `lake_choice`                |             `\"water\"` |       \\`\"none\" | \"water\"                    | \"hollow\"\\`                                           | Geometry + physics                             | `\"water\"`: thermal effects + mask; `\"hollow\"`: geom only (no water thermals) |\n| `hill_choice`                |              `\"bump\"` |       \\`\"none\" | \"bump\"\\`                   | Geometry + pooling                                   | Introduces pooling blocking and local warm rim |                                                                              |\n| `lake_diam_m`                |                    80 |         40–150 | Area of lake/hollow        | Larger disk on right third                           |                                                |                                                                              |\n| `lake_depth_m`               |                    10 |           5–30 | Elevation depression       | Stronger local depression (affects lapse/inversion)  |                                                |                                                                              |\n| `hill_diam_m`                |                    80 |         40–150 | Hill footprint             | Larger bump on left third                            |                                                |                                                                              |\n| `hill_height_m`              |                    50 |         10–120 | Hill relief                | Stronger pooling blocking & lapse effects            |                                                |                                                                              |\n| `smooth_edges`               |               `FALSE` |           bool | Lake boundary shape        | `TRUE` softens rim (harder for sharp interpolators)  |                                                |                                                                              |\n| `hill_smooth`                |               `FALSE` |           bool | Hill shape                 | `TRUE` makes bump Gaussian-smooth                    |                                                |                                                                              |\n| `noise σ`                    |                 0.3 K |            0–1 | Both                       | Adds sub-grid “sensor” noise/random texture          |                                                |                                                                              |\n\n## H.4 Quick “recipe” effects\n\n* **Cloudy/hazy day** → ↓ `alpha_I_grass`, ↓ `alpha_I_water`\n  → Daytime slope contrasts fade; RF/GAM rely more on spatial smoothness and elevation.\n* **Hotter afternoon** → ↑ `T0_14` (+1…+3 K)\n  → All models’ bias shifts; relative rankings unchanged.\n* **Stronger pooling** → ↑ `pool_base` and/or ↓ `w_pool`\n  → Sharper, colder centerline at dawn; models with drift (KED/GAM/RF) gain.\n* **Water vs hollow** → `\"water\"` adds: ↓ daytime heating (`αI_water`) + ↑ dawn warm bias\n  → Day/night asymmetry near pond strengthens; useful to test model nonlinearity.\n* **Pooling blocked by hill** → ↑ `pool_block_gain`\n  → Warm “tongue” over hill at dawn; spatial CV gets tougher (domain shift across blocks).\n\n## H.5 Geometry at a glance\n\n* **Valley**: Elevation $\\propto (y-y_0)^2$ — a U-shape across **y**, uniform along **x**.\n* **Hill** (left third): Disk (or Gaussian) of height `hill_height_m` and diameter `hill_diam_m`.\n* **Pond/Hollow** (right third): Disk depression of depth `lake_depth_m`; if `lake_choice == \"water\"` it also flips exposure gain and adds a pre-dawn warm bias.\n\n## H.6 What each term *looks like* on maps\n\n| Term                          | Map signature                                     |\n| ----------------------------- | ------------------------------------------------- |\n| `lapse_14*(E-Ȇ)`              | Subtle cool rims / warm floor (day)               |\n| `α_map * I14`                 | Warm, sun-facing slopes; damped over water        |\n| `inv_05*(E-Ȇ)`                | Warmer rims vs cooler floor (dawn inversion)      |\n| `η_slope*slp`                 | Slight warm bias on steeper slopes at dawn        |\n| `−pool`                       | Blue band centered on valley axis, width `w_pool` |\n| `+ warm_bias_water_dawn*lake` | Local warm spot over the lake at dawn             |\n\n---\n\n**Tip:** when benchmarking interpolators, try toggling **(a)** sharp vs. smooth feature rims, **(b)** strong vs. weak pooling, and **(c)** water vs. hollow. You’ll see IDW/OK struggle on discontinuities, while **KED/RF/GAM** better exploit drift and covariates—especially under strong physics signals.\n\n## I. Scale analysis — L50/L95 & tuned KED drift (R\\*)\n\n### Overview\n\nThis document demonstrates and explains a **four‑stage spatial pipeline** for field (temperature) data scale and process analysis:\n\n1. **Scale inference (L):** fit a global variogram to get **L50 / L95** (spatial correlation ranges).\n2. **Scale‑matched predictors:** build **covariate rasters** at the right scale (e.g., smoothed synthetic elevation **E**; optionally slope/aspect/TRI).\n3. **Tune** $R^*$: select an optimal **drift radius** $R$ with block‑CV (**U‑curve**), then benchmark methods.\n4. **Diagnostics:** export products, report scales, and compute an optional **error budget**.\n\n> **Key concept (pragmatic, data‑driven scales).** We use the empirical variogram of the synthetic **truth** field to extract **L50/L95** — process‑valid ranges that are robust even without a perfect parametric fit. We then align the **model scale** to these ranges by smoothing covariates at radius **R** and tuning **R\\*** via **blocked CV** (U‑curve). The result is less **scale‑mismatch** and clearer attribution of gains to **scale** rather than to the choice of algorithm.\n>\n> **Why this matters.** Scale governs spatial prediction performance. We (1) infer correlation scales from the empirical variogram, (2) construct a **scale‑matched** drift by smoothing the covariate raster (e.g., elevation **E**) with a Gaussian kernel of radius **R**, (3) **tune** the radius via block‑CV (**U‑curve**) to get **R\\***, and (4) benchmark models **before vs after** tuning. Finally, we show a compact **error budget** (OK → KED base → KED R\\*).\n>\n> **Guiding idea: Scale → Model → Explanatory power.** The quality of a spatial interpolation hinges on whether the **model scale** matches the **process** and **observation** scales. Our pipeline enforces this match explicitly: (1) estimate **L50/L95** from the variogram, (2) build **scale‑matched predictors** (e.g., drift from **E**) with $R_{\text{micro}} \u0007pprox L_{50}$ and $R_{\text{local}} \u0007pprox L_{95}$, (3) tune the **drift radius ($R^*$)** via block‑CV (U‑curve), and (4) benchmark methods at the aligned scale.\n\n### I.1 Scale inference (L50 / L95)\n\n(L50 / L95)\n\nWe fit a global empirical variogram to the truth field and read off the distances at which the semivariance reaches 50% and 95% of the sill — our **L50** and **L95**.\n\n#### Semivariogram & process variance\n\nThe semivariance for lag $h$ is\n\n$$\n\\gamma(h) = \\tfrac{1}{2}\\,\\mathrm{Var}\\!\\big(Z(s)-Z(s+h)\\big).\n$$\n\nThe **structural sill** $\\sigma_{\\text{proc}}^2$ (excluding the nugget) captures the spatially structured process variance, while the **nugget** $\\sigma_{\\text{inst}}^2$ captures measurement/microscale noise. We use $\\sigma_{\\text{proc}} = \\sqrt{\\text{Sill}_{\\text{struct}}}$ in the error budget.\n\n#### Practical lengths $L_{50}$ / $L_{95}$\n\nDefine practical correlation lengths as distances where semivariance reaches a fixed fraction of the structural sill:\n\n$$\nL_p = \\inf\\!\\left\\{h : \\gamma(h) \\ge (1-p)\\,\\sigma_{\\text{proc}}^2 \\right\\},\\quad p\\in\\{0.50, 0.95\\}.\n$$\n\nIntuition: at $L_{50}$ half of the process variance is “spent”; at $L_{95}$ almost the entire structure is.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_Ls_from_raster <- function(r, maxdist = NULL, nlag = 20, sample_n = 3000) {\n  stopifnot(inherits(r, \"SpatRaster\"))\n  # If no maxdist is given, derive it from the raster's own extent (safe default)\n  if (is.null(maxdist)) {\n    e <- terra::ext(r)\n    dom_diag <- sqrt((terra::xmax(e) - terra::xmin(e))^2 +\n                     (terra::ymax(e) - terra::ymin(e))^2)\n    maxdist <- dom_diag / 2\n  }\n  df <- as.data.frame(r, xy = TRUE, na.rm = TRUE)\n  names(df) <- c(\"x\",\"y\",\"z\")\n  if (nrow(df) > sample_n) {\n    set.seed(1L)\n    df <- df[sample(seq_len(nrow(df)), sample_n), , drop = FALSE]\n  }\n  # Try to carry over CRS from the raster; fall back gracefully if missing\n  crs_wkt <- tryCatch({\n    cw <- terra::crs(r, proj = TRUE)\n    if (is.na(cw) || cw == \"\") NA_character_ else cw\n  }, error = function(...) NA_character_)\n  spdf <- sp::SpatialPointsDataFrame(\n    coords = df[, c(\"x\",\"y\")],\n    data   = data.frame(val = df$z),\n    proj4string = if (!is.na(crs_wkt) && nzchar(crs_wkt)) sp::CRS(crs_wkt) else sp::CRS(NA_character_)\n  )\n  vg <- gstat::variogram(val ~ 1, spdf, cutoff = maxdist, width = maxdist / nlag)\n  # monotonicize gamma for stable inversion\n  gamma_mono <- cummax(vg$gamma)\n  sill <- max(gamma_mono, na.rm = TRUE)\n  L50  <- tryCatch(stats::approx(x = gamma_mono, y = vg$dist, xout = 0.5 * sill, ties = mean)$y, error = function(...) NA_real_)\n  L95  <- tryCatch(stats::approx(x = gamma_mono, y = vg$dist, xout = 0.95 * sill, ties = mean)$y, error = function(...) NA_real_)\n  list(vg = vg, sill = sill, L50 = as.numeric(L50), L95 = as.numeric(L95), cutoff = maxdist)\n}\n\nplot_variogram_with_scales <- function(vg, L50, L95, sill, title = \"Empirical variogram\") {\n  df <- as.data.frame(vg)\n  ggplot2::ggplot(df, ggplot2::aes(dist, gamma)) +\n    ggplot2::geom_point() + ggplot2::geom_line(alpha = 0.6) +\n    ggplot2::geom_hline(yintercept = sill, linetype = \"dotted\", linewidth = 0.4) +\n    ggplot2::geom_vline(xintercept = L50, colour = \"#2b8cbe\", linetype = \"dashed\") +\n    ggplot2::geom_vline(xintercept = L95, colour = \"#de2d26\", linetype = \"dashed\") +\n    ggplot2::annotate(\"text\", x = L50, y = 0, vjust = -0.5, label = sprintf(\"L50 = %.0f m\", L50)) +\n    ggplot2::annotate(\"text\", x = L95, y = 0, vjust = -0.5, label = sprintf(\"L95 = %.0f m\", L95), colour = \"#de2d26\") +\n    ggplot2::theme_minimal() + ggplot2::labs(title = title, x = \"Distance (m)\", y = \"Semivariance\")\n}\n```\n:::\n\n\n\n### I.2 Scale‑matched drift via Gaussian smoothing at R\n\nWe smooth the covariate raster (e.g., the synthetic elevation **E**) to construct the external drift (`z_surf`) at radius **R**. The kernel size is **capped** by the raster size to keep `terra::focal()` stable.\n\n#### Working radii $R$: micro & local\n\nWe tie model scale to process scale:\n\n$$\nR_{\\text{micro}} \\approx L_{50},\\qquad R_{\\text{local}} \\approx L_{95}.\n$$\n\nThis sets smoothing/drift and block sizes in a process‑consistent way.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.make_gaussian_kernel <- function(r_pix) {\n  sigma <- max(1e-6, r_pix / 2)\n  x <- -r_pix:r_pix; y <- x\n  K <- outer(x, y, function(i, j) exp(- (i^2 + j^2) / (2 * sigma^2)))\n  K / sum(K)\n}\n\nsmooth_raster_gaussian <- function(r, R_m) {\n  stopifnot(inherits(r, \"SpatRaster\"))\n  res_m <- mean(terra::res(r))\n  r_pix <- max(1L, ceiling(R_m / res_m))\n  # cap relative to raster dimensions\n  r_pix_cap <- min(terra::nrow(r) - 1L, terra::ncol(r) - 1L)\n  if (r_pix > r_pix_cap) {\n    message(sprintf(\"[smooth] R=%.1f m -> r_pix=%d capped to %d (raster %dx%d)\",\n                    R_m, r_pix, r_pix_cap, terra::ncol(r), terra::nrow(r)))\n    r_pix <- r_pix_cap\n  }\n  K <- .make_gaussian_kernel(r_pix)\n  terra::focal(r, w = K, fun = \"sum\", na.policy = \"omit\", pad = TRUE, na.rm = TRUE)\n}\n```\n:::\n\n\n\n### I.3 Tune R\\* with block‑CV (U‑curve)\n\nWe scan a sequence between \\~$0.5\\cdot L_{50}$ and $1.5\\cdot L_{95}$, **capped** by raster geometry, then pick the RMSE‑minimizing **R\\***.\n\n#### Tuned radius $R^*$\n\nFor candidate radii $R$ we perform **blocked cross‑validation** (block edge $\\approx L_{95}$ or $R$) to avoid spatial leakage, and select\n\n$$\nR^* = \\arg\\min_R \\ \\mathrm{RMSE}_{\\text{CV}}(R).\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntune_Rstar <- function(stn_sf, E, L50, L95, block_size = 100) {\n  res_m <- mean( terra::res(E) )\n  R_cap_pix <- min(terra::nrow(E) - 1L, terra::ncol(E) - 1L)\n  R_cap_m   <- R_cap_pix * res_m\n  R_min <- if (is.finite(L50)) 0.5 * L50 else 10\n  R_max <- if (is.finite(L95)) 1.5 * L95 else sqrt(terra::expanse(E, unit = \"m\"))/3\n  R_seq <- sort(unique(pmax(5, pmin(round(seq(R_min, R_max, length.out = 8)), R_cap_m))))\n  if (!length(R_seq)) R_seq <- c(min(25, R_cap_m/4), min(50, R_cap_m/2))\n\n  out <- lapply(R_seq, function(R) {\n    E_R <- smooth_raster_gaussian(E, R)\n    stn_mod <- stn_sf\n    stn_mod$z_surf <- as.numeric(terra::extract(E_R, sf::st_coordinates(stn_mod))[,1])\n    cv_res <- suppressMessages(run_lbo_cv(stn_mod, E = E_R, block_size = block_size, models = c(\"KED\")))\n    rmse <- cv_res$metrics$RMSE[match(\"KED\", cv_res$metrics$model)]\n    tibble::tibble(R = R, RMSE = rmse)\n  })\n\n  tbl <- dplyr::bind_rows(out)\n  list(R_star = tbl$R[which.min(tbl$RMSE)], table = tbl)\n}\n\nplot_ucurve <- function(tune_tbl, label = \"\") {\n  ggplot2::ggplot(tune_tbl, ggplot2::aes(R, RMSE)) +\n    ggplot2::geom_line() + ggplot2::geom_point() +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"U-curve (KED) — %s\", label), x = \"Smoothing radius R (m)\", y = \"RMSE (°C)\")\n}\n```\n:::\n\n\n\n### I.4 Benchmark & simple error budget\n\nWe re‑run the full model set with (a) **base** drift and (b) **tuned** drift at **R\\***. The simple budget contrasts **OK** (no drift) → **KED (base)** → **KED (R\\*)**.\n\n#### Scale‑mismatch penalty $g(R/L)$\n\nScale error arises when the model radius $R$ doesn’t match the process length $L$. A symmetric, dimensionless measure is\n\n$$\n g\\!\\left(\\frac{R}{L}\\right) = \\tfrac{1}{2}\\!\\left(\\frac{R}{L} + \\frac{L}{R}\\right) - 1 \\;\\;\\ge 0,\n$$\n\nwith minimum $0$ at $R/L=1$.\n\n#### Error budget (interpreting RMSE)\n\nWe can heuristically decompose CV error as\n\n$$\n\\mathrm{RMSE}^2 \\approx \\underbrace{\\sigma_{\\text{inst}}^2}_{\\text{measurement noise}}\\;+\n\\; \\underbrace{\\sigma_{\\text{proc}}^2\\, g(R/L)}_{\\text{scale mismatch}}\\;+\n\\; \\underbrace{\\varepsilon_{\\text{model}}^2}_{\\text{model residual}}.\n$$\n\nThis helps disentangle whether errors come primarily from noise, scale choice, or model choice.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_with_Rstar <- function(stn_sf, E, R_star, block_size = 100) {\n  base <- run_lbo_cv(stn_sf, E = E, block_size = block_size, models = models_use)\n  E_star <- smooth_raster_gaussian(E, R_star)\n  stn_star <- stn_sf\n  stn_star$z_surf <- as.numeric(terra::extract(E_star, sf::st_coordinates(stn_star))[,1])\n  tuned <- run_lbo_cv(stn_star, E = E_star, block_size = block_size, models = models_use)\n  list(base = base, tuned = tuned, E_star = E_star, stn_star = stn_star)\n}\n\nmake_simple_error_budget <- function(base_metrics, tuned_metrics) {\n  b <- base_metrics |> dplyr::select(model, RMSE) |> dplyr::rename(RMSE_base = RMSE)\n  t <- tuned_metrics |> dplyr::select(model, RMSE) |> dplyr::rename(RMSE_tuned = RMSE)\n  jt <- dplyr::left_join(b, t, by = \"model\")\n  ok_row  <- jt[jt$model == \"OK\", , drop = FALSE]\n  ked_row <- jt[jt$model == \"KED\", , drop = FALSE]\n  tibble::tibble(\n    Component    = c(\"Baseline (OK)\", \"Add drift (KED base)\", \"Scale‑match drift (KED R*)\"),\n    RMSE         = c(ok_row$RMSE_base, ked_row$RMSE_base, ked_row$RMSE_tuned),\n    Gain_vs_prev = c(NA_real_, ok_row$RMSE_base - ked_row$RMSE_base, ked_row$RMSE_base - ked_row$RMSE_tuned)\n  )\n}\n```\n:::\n\n\n\n> **From concept to practice (pipeline mapping).**\n>\n> 1. Estimate scales: variogram $\\rightarrow$ $\\sigma_{\\text{proc}}^2$, $L_{50}$, $L_{95}$.\n> 2. Couple scales: smooth predictors / choose grids according to $R_{\\text{micro}}$, $R_{\\text{local}}$.\n> 3. Tune $R^*$: block‑CV, U‑curve $\\rightarrow$ stable drift radius.\n> 4. Benchmark methods: compare OK/KED/GAM/RF/Trend/IDW/Voronoi at $R^*$ (RMSE/MAE/Bias, document block size).\n> 5. Products: write maps/grids at $R^*$ (and optionally $L_{95}$); report the error budget.\n\n> **Key takeaway:** *The “smartest” algorithm doesn’t win — the one whose scale matches the process does.*\n\n\n\n### I.5 Wrapper & execution (T14, T05)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_scale_analysis_for_time <- function(stn_sf, truth_r, label) {\n  Ls <- compute_Ls_from_raster(truth_r)\n  vg_plot <- plot_variogram_with_scales(Ls$vg, Ls$L50, Ls$L95, Ls$sill, title = sprintf(\"Variogram — %s\", label))\n  tune <- tune_Rstar(stn_sf, scen$E, L50 = Ls$L50, L95 = Ls$L95, block_size = block_size)\n  u_plot <- plot_ucurve(tune$table, label)\n  bench <- bench_with_Rstar(stn_sf, scen$E, tune$R_star, block_size = block_size)\n  best <- dplyr::bind_rows(\n    bench$base$metrics |> dplyr::mutate(source = \"base\"),\n    bench$tuned$metrics |> dplyr::mutate(source = \"tuned\")\n  ) |>\n    dplyr::arrange(model, RMSE) |>\n    dplyr::group_by(model) |>\n    dplyr::slice_head(n = 1) |>\n    dplyr::ungroup()\n  wf <- list(L = c(L50 = Ls$L50, L95 = Ls$L95), R = c(micro = Ls$L50/2, local = Ls$L95))\n  eb <- make_simple_error_budget(bench$base$metrics, bench$tuned$metrics)\n  list(stamp = label, Ls = Ls, tune = list(R_star = tune$R_star, table = tune$table, u_plot = u_plot),\n       wf = wf, bench = list(base = bench$base, tuned = bench$tuned, best = best),\n       errtab = eb, vg_plot = vg_plot)\n}\n```\n:::\n\n\n\nRun it for both times and present compact outputs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pretty tables\npretty_table <- function(df, caption) {\n  df |>\n    knitr::kable(digits = 3, caption = caption, format = \"html\") |>\n    kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c(\"striped\",\"hover\",\"condensed\")) |>\n    kableExtra::row_spec(0, bold = TRUE)\n}\nmessage(\"Scale analysis + R* tuning for T14 …\")\nsa14 <- run_scale_analysis_for_time(stn_sf_14, scen$R14, \"T14\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Scale analysis + R* tuning for T05 …\")\nsa05 <- run_scale_analysis_for_time(stn_sf_05, scen$R05, \"T05\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nsa14$vg_plot; sa14$tune$u_plot\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/scale-run-1.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/scale-run-2.png){width=1350}\n:::\n\n```{.r .cell-code}\nsa05$vg_plot; sa05$tune$u_plot\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/scale-run-3.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_3_merged_files/figure-html/scale-run-4.png){width=1350}\n:::\n\n```{.r .cell-code}\nsummary_pipe <- dplyr::bind_rows(\n  tibble::tibble(ts_key = \"T14\", stamp = \"T14\", R_star = sa14$tune$R_star) |>\n    dplyr::bind_cols(sa14$bench$best |> dplyr::select(best_source = source, best_method = model, best_RMSE = RMSE)),\n  tibble::tibble(ts_key = \"T05\", stamp = \"T05\", R_star = sa05$tune$R_star) |>\n    dplyr::bind_cols(sa05$bench$best |> dplyr::select(best_source = source, best_method = model, best_RMSE = RMSE))\n)\nsummary_pipe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n   ts_key stamp R_star best_source best_method best_RMSE\n   <chr>  <chr>  <dbl> <chr>       <chr>           <dbl>\n 1 T14    T14      112 base        GAM             0.734\n 2 T14    T14      112 base        IDW             1.03 \n 3 T14    T14      112 base        KED             0.872\n 4 T14    T14      112 base        OK              0.993\n 5 T14    T14      112 base        RF              0.798\n 6 T14    T14      112 base        Voronoi         1.25 \n 7 T05    T05       36 base        GAM             0.600\n 8 T05    T05       36 base        IDW             1.32 \n 9 T05    T05       36 base        KED             0.831\n10 T05    T05       36 base        OK              1.02 \n11 T05    T05       36 base        RF              0.636\n12 T05    T05       36 base        Voronoi         1.37 \n```\n\n\n:::\n\n```{.r .cell-code}\npretty_table(sa14$bench$base$metrics, \"Metrics — base (T14)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Metrics — base (T14)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> model </th>\n   <th style=\"text-align:right;font-weight: bold;\"> n </th>\n   <th style=\"text-align:right;font-weight: bold;\"> MAE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Bias </th>\n   <th style=\"text-align:right;font-weight: bold;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> GAM </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.418 </td>\n   <td style=\"text-align:right;\"> 0.734 </td>\n   <td style=\"text-align:right;\"> 0.160 </td>\n   <td style=\"text-align:right;\"> 0.582 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> RF </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.567 </td>\n   <td style=\"text-align:right;\"> 0.798 </td>\n   <td style=\"text-align:right;\"> 0.035 </td>\n   <td style=\"text-align:right;\"> 0.458 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KED </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.682 </td>\n   <td style=\"text-align:right;\"> 0.872 </td>\n   <td style=\"text-align:right;\"> -0.098 </td>\n   <td style=\"text-align:right;\"> 0.365 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> OK </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.771 </td>\n   <td style=\"text-align:right;\"> 0.993 </td>\n   <td style=\"text-align:right;\"> -0.059 </td>\n   <td style=\"text-align:right;\"> 0.156 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> IDW </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.838 </td>\n   <td style=\"text-align:right;\"> 1.032 </td>\n   <td style=\"text-align:right;\"> -0.031 </td>\n   <td style=\"text-align:right;\"> 0.082 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Voronoi </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.887 </td>\n   <td style=\"text-align:right;\"> 1.248 </td>\n   <td style=\"text-align:right;\"> -0.051 </td>\n   <td style=\"text-align:right;\"> 0.069 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\npretty_table(sa14$bench$tuned$metrics, \"Metrics — tuned (T14)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Metrics — tuned (T14)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> model </th>\n   <th style=\"text-align:right;font-weight: bold;\"> n </th>\n   <th style=\"text-align:right;font-weight: bold;\"> MAE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Bias </th>\n   <th style=\"text-align:right;font-weight: bold;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> RF </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.623 </td>\n   <td style=\"text-align:right;\"> 0.841 </td>\n   <td style=\"text-align:right;\"> -0.037 </td>\n   <td style=\"text-align:right;\"> 0.395 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GAM </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.638 </td>\n   <td style=\"text-align:right;\"> 0.878 </td>\n   <td style=\"text-align:right;\"> -0.071 </td>\n   <td style=\"text-align:right;\"> 0.360 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KED </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.753 </td>\n   <td style=\"text-align:right;\"> 0.974 </td>\n   <td style=\"text-align:right;\"> -0.103 </td>\n   <td style=\"text-align:right;\"> 0.190 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> OK </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.771 </td>\n   <td style=\"text-align:right;\"> 0.993 </td>\n   <td style=\"text-align:right;\"> -0.059 </td>\n   <td style=\"text-align:right;\"> 0.156 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> IDW </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.838 </td>\n   <td style=\"text-align:right;\"> 1.032 </td>\n   <td style=\"text-align:right;\"> -0.031 </td>\n   <td style=\"text-align:right;\"> 0.082 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Voronoi </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.887 </td>\n   <td style=\"text-align:right;\"> 1.248 </td>\n   <td style=\"text-align:right;\"> -0.051 </td>\n   <td style=\"text-align:right;\"> 0.069 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\npretty_table(sa14$errtab, \"Simple error budget (T14)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Simple error budget (T14)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> Component </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Gain_vs_prev </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Baseline (OK) </td>\n   <td style=\"text-align:right;\"> 0.993 </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Add drift (KED base) </td>\n   <td style=\"text-align:right;\"> 0.872 </td>\n   <td style=\"text-align:right;\"> 0.121 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Scale‑match drift (KED R*) </td>\n   <td style=\"text-align:right;\"> 0.974 </td>\n   <td style=\"text-align:right;\"> -0.102 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\npretty_table(sa05$bench$base$metrics, \"Metrics — base (T05)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Metrics — base (T05)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> model </th>\n   <th style=\"text-align:right;font-weight: bold;\"> n </th>\n   <th style=\"text-align:right;font-weight: bold;\"> MAE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Bias </th>\n   <th style=\"text-align:right;font-weight: bold;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> GAM </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.420 </td>\n   <td style=\"text-align:right;\"> 0.600 </td>\n   <td style=\"text-align:right;\"> 0.055 </td>\n   <td style=\"text-align:right;\"> 0.815 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> RF </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.503 </td>\n   <td style=\"text-align:right;\"> 0.636 </td>\n   <td style=\"text-align:right;\"> 0.054 </td>\n   <td style=\"text-align:right;\"> 0.789 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KED </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.662 </td>\n   <td style=\"text-align:right;\"> 0.831 </td>\n   <td style=\"text-align:right;\"> 0.061 </td>\n   <td style=\"text-align:right;\"> 0.628 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> OK </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.773 </td>\n   <td style=\"text-align:right;\"> 1.023 </td>\n   <td style=\"text-align:right;\"> -0.078 </td>\n   <td style=\"text-align:right;\"> 0.435 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> IDW </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 1.084 </td>\n   <td style=\"text-align:right;\"> 1.323 </td>\n   <td style=\"text-align:right;\"> -0.108 </td>\n   <td style=\"text-align:right;\"> 0.055 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Voronoi </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 1.108 </td>\n   <td style=\"text-align:right;\"> 1.373 </td>\n   <td style=\"text-align:right;\"> 0.199 </td>\n   <td style=\"text-align:right;\"> 0.216 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\npretty_table(sa05$bench$tuned$metrics, \"Metrics — tuned (T05)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Metrics — tuned (T05)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> model </th>\n   <th style=\"text-align:right;font-weight: bold;\"> n </th>\n   <th style=\"text-align:right;font-weight: bold;\"> MAE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Bias </th>\n   <th style=\"text-align:right;font-weight: bold;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> RF </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.550 </td>\n   <td style=\"text-align:right;\"> 0.735 </td>\n   <td style=\"text-align:right;\"> 0.040 </td>\n   <td style=\"text-align:right;\"> 0.722 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KED </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.731 </td>\n   <td style=\"text-align:right;\"> 0.944 </td>\n   <td style=\"text-align:right;\"> -0.049 </td>\n   <td style=\"text-align:right;\"> 0.522 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> OK </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.773 </td>\n   <td style=\"text-align:right;\"> 1.023 </td>\n   <td style=\"text-align:right;\"> -0.078 </td>\n   <td style=\"text-align:right;\"> 0.435 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GAM </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 0.707 </td>\n   <td style=\"text-align:right;\"> 1.214 </td>\n   <td style=\"text-align:right;\"> 0.256 </td>\n   <td style=\"text-align:right;\"> 0.479 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> IDW </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 1.084 </td>\n   <td style=\"text-align:right;\"> 1.323 </td>\n   <td style=\"text-align:right;\"> -0.108 </td>\n   <td style=\"text-align:right;\"> 0.055 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Voronoi </td>\n   <td style=\"text-align:right;\"> 60 </td>\n   <td style=\"text-align:right;\"> 1.108 </td>\n   <td style=\"text-align:right;\"> 1.373 </td>\n   <td style=\"text-align:right;\"> 0.199 </td>\n   <td style=\"text-align:right;\"> 0.216 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\npretty_table(sa05$errtab, \"Simple error budget (T05)\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Simple error budget (T05)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;font-weight: bold;\"> Component </th>\n   <th style=\"text-align:right;font-weight: bold;\"> RMSE </th>\n   <th style=\"text-align:right;font-weight: bold;\"> Gain_vs_prev </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Baseline (OK) </td>\n   <td style=\"text-align:right;\"> 1.023 </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Add drift (KED base) </td>\n   <td style=\"text-align:right;\"> 0.831 </td>\n   <td style=\"text-align:right;\"> 0.193 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Scale‑match drift (KED R*) </td>\n   <td style=\"text-align:right;\"> 0.944 </td>\n   <td style=\"text-align:right;\"> -0.113 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n> **From concept to practice (pipeline mapping).**\n>\n> 1. Estimate scales: variogram $\\rightarrow$ $\\sigma_{\\text{proc}}^2$, $L_{50}$, $L_{95}$.\n> 2. Couple scales: smooth predictors / choose grids according to $R_{\\text{micro}}$, $R_{\\text{local}}$.\n> 3. Tune $R^*$: block‑CV, U‑curve $\\rightarrow$ stable drift radius.\n> 4. Benchmark methods: compare OK/KED/GAM/RF/Trend/IDW/Voronoi at $R^*$ (RMSE/MAE/Bias, document block size).\n> 5. Products: write maps/grids at $R^*$ (and optionally $L_{95}$); report the error budget.\n\n> **Key takeaway:** *The “smartest” algorithm doesn’t win — the one whose scale matches the process does.*\n\n### I.5 Reading the outputs (tables & plots)\n\nThis section explains **how to interpret** the key tables and figures produced by the pipeline and how to turn them into a **model choice** and a **scale statement**.\n\n#### 1) Variogram & scale table (chunk `scale-Ls`)\n\n* **What you see:** Empirical variogram points/line, horizontal dotted line at the **(structural) sill**, and vertical dashed lines at **L50** and **L95**.\n* **How to read it:**\n\n  * **Nugget** (near‑zero intercept) ≈ measurement/microscale noise. A large nugget means close points differ substantially; no method can beat this noise floor.\n  * **Sill** (plateau) ≈ total variance once pairs are effectively uncorrelated.\n  * **L50 / L95** ≈ pragmatic correlation distances (half vs. \\~all structure spent). They are your **scale anchors** for smoothing radii, neighborhood ranges, and CV block sizes.\n* **Quality checks:**\n\n  * If no clear plateau: trend/non‑stationarity is likely → consider a drift (elev/sun terms) or a larger domain.\n  * If L95 is near the domain size: scales are long; block sizes should be generous to avoid leakage.\n  * If the variogram is noisy at large lags: rely more on **L50** and the U‑curve outcome.\n\n#### 2) U‑curve for tuned drift (chunk `scale-tune`)\n\n* **What you see:** A line plot of **RMSE vs. smoothing radius R** for KED under **blocked CV**.\n* **Decision rule:** **R\\*** is the radius with the **lowest CV‑RMSE**.\n* **What shapes mean:**\n\n  * **Left side high** (too small R): drift carries microscale noise → overfitting → higher CV error.\n  * **Right side high** (too large R): drift is oversmoothed → loses meaningful gradient → bias ↑.\n  * **Flat bottom/plateau:** a range of R values are equivalent → pick the smallest R on the plateau for parsimony.\n* **Edge cases:** If the minimum sits at the **search boundary**, widen the R grid and re‑run; if still at the boundary, the field may be trend‑dominated or the covariate is weak.\n\n#### 3) LBO‑CV metrics table (`res$metrics`)\n\nFor each model (Voronoi, IDW, OK, KED, GAM, RF) we report:\n\n* **RMSE** (primary): square‑error penalty; most sensitive to outliers. **Use this to rank models.**\n* **MAE**: median‑like robustness; a useful tie‑breaker alongside RMSE.\n* **Bias** (mean error): systematic over/under‑prediction; prefer |Bias| close to 0.\n* **R²**: variance explained in held‑out blocks; interpret cautiously under spatial CV.\n* **n**: number of held‑out predictions contributing.\n\n**Choosing a winner:**\n\n1. Rank by **lowest RMSE** under the **tuned** configuration.\n2. If RMSEs are within \\~5–10%: prefer the model with **lower MAE**, **lower |Bias|**, and **more stable block‑wise errors** (see next point).\n3. If KED (R\\*) ≈ OK: the drift adds little; the covariate is weak or the process is long‑range. If GAM/RF wins, the relationship is **nonlinear** or **interaction‑rich**.\n\n#### 4) Block‑wise diagnostics\n\n* **Block error boxes/scatter:** Look for **narrow distributions** (stable across space). Large spread or outliers indicate location‑dependent performance.\n* **Stability index (optional):** `CV_rmse = sd(RMSE_block) / mean(RMSE_block)`. Values < 0.25 are typically stable; > 0.4 suggests uneven performance.\n* **Obs vs Pred scatter:** Slope \\~1 and tight cloud = good calibration; bowed patterns imply bias or missing drift terms.\n\n#### 5) Error budget table (`make_simple_error_budget`)\n\nThree rows show how error decreases as structure is added and matched:\n\n* **Baseline (OK):** no drift; sets a structure‑free reference.\n* **Add drift (KED base):** uses raw covariate; improvement here quantifies **signal in the covariate**.\n* **Scale‑match drift (KED R\\*):** covariate smoothed at **R\\***; additional gain isolates **scale alignment**. The `Gain_vs_prev` column is the **incremental improvement** at each step.\n\n> If **KED base** \\~ **KED R\\***, scale matching adds little (either the raw drift is already at a compatible scale, or the field is insensitive to R). If **OK** > **KED base**, the covariate may inject noise or the drift term is mis‑specified.\n\n### I.6 Deciding on the *best* model (and documenting the scale)\n\nUse this practical, auditable rule set:\n\n1. **Primary criterion:** Lowest **CV‑RMSE** under blocked CV.\n2. **Tie‑breakers:** Lower **MAE**, smaller **|Bias|**, and better **block‑stability**.\n3. **Parsimony:** If multiple models tie, choose the **simplest** (OK/KED < GAM < RF).\n4. **Scale sanity check:** Report **L50/L95** and verify that **R\\*** lies roughly in \\[L50, 1.5·L95]. If not, discuss why (e.g., strong trend, weak covariate, anisotropy).\n5. **Reproducibility:** Record the **block size**, **R grid**, winning **R\\***, and the full metrics table.\n\n\n### I.7 Typical patterns & what they imply\n\n* **High nugget, short L50:** Expect modest absolute accuracy; prefer **coarser R** and conservative models. IDW/OK with tight neighborhoods can perform on par with KED.\n* **Long L95, clear sill:** Favor larger neighborhoods and smoother drifts; **KED (R\\*)** often dominates.\n* **GAM/RF > KED:** Nonlinear covariate effects or interactions (e.g., slope×aspect). Still align covariates to **R\\*** to avoid noise chasing.\n* **OK \\~ KED:** Elevation (or chosen drift) is weak for this synthetic setup; consider enriching covariates (slope/aspect/TRI) at matched scales.\n\n### I.8 Checklist before you trust the numbers\n\n* Block size reflects **correlation scale** (≈ L95).\n* U‑curve scanned a **broad enough R** range; minimum not at boundary.\n* **R\\*** reported along with **L50/L95**.\n* Winner chosen by **blocked CV** (not random folds).\n* Bias near zero; residuals pattern‑free in space.\n* Figures/tables archived for reproducibility.\nAwesome—here’s a single, consistent interpretation that stitches together\n**(1) the model run (blocked CV)** and **(2) the scale-tuning block (variogram + U-curve)**, and then ends with **what to tune, when, for which model** (+ whether GAM “always wins”).\n\n---\n\n# Executive summary\n\n* Your **blocked CV** (100 m) shows **GAM** best, **RF** second, **KED > OK > IDW > Voronoi** for both T14 and T05. This says: *with the right covariates*, flexible learners generalize best across space.\n* The **empirical variogram** gives pragmatic scales:\n\n  * **T14:** $L_{50}\\!\\approx\\!68$ m, $L_{95}\\!\\approx\\!205$ m (longer correlation tail; insolation-driven).\n  * **T05:** $L_{50}\\!\\approx\\!72$ m, $L_{95}\\!\\approx\\!126$ m (shorter-ranged; pooling/inversion).\n* **KED tuning** with a smoothed **E** drift did **not** beat KED-base. That’s not a failure of scale logic; it’s a **covariate-mismatch**: at **T14** the signal is mainly **insolation**, at **T05** it’s **pooling**—smoothing elevation can’t recover the right physics.\n* Do **scale match the right driver** and allow **$R=0$** in the search; then the U-curve will pick an $R^\\*$ that actually helps.\n\n---\n\n# 1) Blocked-CV model run (first block)\n\n**T14:** RMSE ranking `GAM (0.73) < RF (0.80) < KED (0.87) < OK (0.99) < IDW (1.03) < Voronoi (1.25)` with R² up to \\~0.58.\n**T05:** `GAM (0.60) < RF (0.64) < KED (0.83) < OK (1.02) < IDW (1.32) < Voronoi (1.37)`, R² up to \\~0.82.\n\n* **Why learners win:** They ingest **z\\_surf, slope, cosi** (and x/y) and capture mild nonlinearities. Their **block-wise** error boxes are lowest and tightest → robust across space.\n* **Why KED > OK:** adding **any** relevant drift reduces OK’s bias/smoothing error. But **which drift** matters: elevation alone under-explains T14 and only partly explains T05.\n* **Baselines (OK/IDW/Voronoi):** scale-agnostic, higher mean and spread; useful references but outperformed when covariates carry signal.\n\n**Map panels** confirm this: GAM/RF reproduce gradients + hill/pond signatures; OK/KED blur edges; IDW/Voronoi show radial/cell artifacts. Error maps show residual clusters where features aren’t captured by the chosen drift.\n\n---\n\n# 2) Scale-tuning with the empirical variogram (second block)\n\n**Variogram scales.**\n\n* **T14 $L_{50}\\!\\approx\\!68$ m; $L_{95}\\!\\approx\\!205$ m** → larger-scale structure from insolation; longer tail.\n* **T05 $L_{50}\\!\\approx\\!72$ m; $L_{95}\\!\\approx\\!126$ m** → smoother, shorter-range field from pooling + gentle slopes.\n\n**U-curves (KED with smoothed E):** shallow minima near **$R \\sim 100\\!-\\!120$ m** at T14; a decreasing tail at larger **R** in one T05 run, while another run reported **$R^\\*\\!\\approx\\!36$ m**. That mismatch is just **different $R$-grids**—log/print the candidate `R_seq` so plots and tables align.\n\n**Key diagnosis:** KED-**base** < KED-**tuned** → **covariate mis-specification**. The right *scale* applied to the *wrong* driver (E) won’t help. For T14 smooth/enter **cosi** (and possibly slope); for T05 use a **pooling proxy** (e.g., smoothed E **and** slope, distance-to-axis). Also include **$R=0$** in the search (current tuner starts at \\~0.5·L50).\n\n**Error budget** (OK → KED base → KED R\\*):\n\n* **T14:** adding a drift gains \\~0.12 °C; smoothing E loses \\~0.10 °C.\n* **T05:** drift gains \\~0.19 °C; smoothing E loses \\~0.11 °C.\n  The budget cleanly shows: *drift helps; wrong drift scale/variable hurts*.\n\n---\n\n# 3) Why scale matters & what to tune (by model)\n\n**Shared first:** set **block size ≈ $L_{95}$**; keep CV **blocked**; if anisotropy shows up, use directional variograms or anisotropic neighborhoods.\n\n### KED / UK\n\n* **Tune:** drift **variables** (e.g., `z_surf`, `cosi`, `slope`, pooling proxy), **their smoothing radii $R$** (include **$R=0$**), variogram model/range (cap by $L_{95}$).\n* **When it shines:** strong, physically interpretable drifts at the right scale(s); small–moderate n where parametric structure helps.\n\n### OK\n\n* **Tune:** variogram **range** (anchor to $L_{95}$), sill/nugget; max neighbors or search radius ≈ $L_{95}$.\n* **Use case:** no reliable covariates; you want a robust spatial baseline.\n\n### IDW\n\n* **Tune:** **power**, **k**, **radius ≈ $L_{95}$** via blocked CV.\n* **Note:** simple, but no uncertainty and tends to artifact at edges.\n\n### GAM\n\n* **Tune:** basis sizes (`k`) relative to domain/L50, smoothness penalties (REML); **features** smoothed at appropriate **R** (e.g., `E_R`, `slope_R`, `cosi_R`).\n* **Guardrails:** blocked CV to prevent micro-scale overfitting; limit `k` when n is small.\n\n### RF\n\n* **Tune:** `mtry`, min node size, trees; include **coordinates** and **scale-matched features**; use blocked CV (and/or spatial cross-validators) to reduce leakage.\n* **Strength:** nonlinear interactions; **risk:** memorizing micro-texture if features aren’t scale-matched.\n\n### Voronoi / NN\n\n* **No real tuning** beyond sampling geometry; keep as a micro-scale baseline.\n\n---\n\n# 4) Does GAM always win?\n\n**No.** GAM wins **here** because (a) your covariates line up with the physics, and (b) n≈60 supports smooth, low-variance fits under **blocked CV**. Cases where something else can win:\n\n* **Perfectly linear physics + very clean drift(s):** well-tuned **KED/UK** can beat GAM/RF and be more stable.\n* **Very small n or sparse coverage:** **KED/OK** can be safer than learners.\n* **Poor covariates / high nugget:** **OK** can tie/beat mis-specified learners; or all methods plateau at the noise floor.\n* **Strong anisotropy:** a **directional** KED/OK may outperform generic learners unless you explicitly engineer anisotropic features.\n\n---\n\n# 5) Concrete next steps (to make scale work for you)\n\n1. **Include $R=0$** in `tune_Rstar()` and **log `R_seq`** used.\n2. **Use the right drifts per slot** and tune *their* scales:\n\n   * **T14:** add **`cosi` (I14)** (and maybe `slope`), tune **R** for these, not just for E.\n   * **T05:** add a **pooling proxy** (e.g., smoothed E **and** slope, distance-to-axis).\n3. **Re-run U-curves** and expect **KED(R\\*) ≤ KED(base)** when the covariate matches the process.\n4. For **GAM/RF**, also feed **scale-matched features**; keep **blocked CV**; report basis sizes / node sizes used.\n5. **Report** per slot: $L_{50}$, $L_{95}$, block size, `R_seq`, $R^\\*$, model ranking, and the OK→KED→KED(R\\*) budget.\n\n---\n\n## One-liner\n\n**Scale only pays off when you scale the *right* driver.** Use the variogram to set the *target scale* (L50/L95), put that scale into the *covariate that carries the physics*, allow **$R=0$**, and keep CV **blocked**—then $R^\\*$ will improve KED and keep learners honest. GAM won here, but it won’t always win.\n\n",
    "supporting": [
      "pipemodel_3_merged_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}