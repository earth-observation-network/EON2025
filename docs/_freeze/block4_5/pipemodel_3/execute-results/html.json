{
  "hash": "b389204bf3f02bd463a5f48f22a41bcd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel — merged narrative & engine\"\nsubtitle: \"Idealized valley microclimate sandbox with robust modeling + spatial CV\"\nauthor: \"PipeModel Team\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    theme: cosmo\n    code-fold: true\n    number-sections: true\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\n\n## Why the *pipemodel*?\n\nThe **pipemodel** is a deliberately idealized yet physically plausible valley scenario. It distills terrain to the essentials (parabolic cross‑valley profile, optional features like a **north facing slope**, **right side hill** and a **a water filled pond/ or empty pit**) so that the dominant microclimate drivers become visible and quantifiable.\n\n-   **Radiation (cos i)** via slope/aspect captures sun exposure.\n-   **Elevation**: daytime *negative lapse*; pre‑dawn *weak inversion*.\n-   **Cold‑air processes**: a Gaussian pool along the valley axis.\n-   **Surface type**: water vs grass alters heating/cooling.\n\nYou can use the synthetic \"truth\" field to sample **stations**, train **interpolators** (IDW, Kriging variants, RF, GAM), and assess them with **spatial CV**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chunk defaults for crisp figures\nknitr::opts_chunk$set(fig.width = 9, fig.height = 6, dpi = 150)\n```\n:::\n\n\n\n## A. Setup & global knobs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages ---------------------------------------------------------------\nreq_pkgs <- c(\n  \"terra\",\"sf\",\"sp\",\"ggplot2\",\"dplyr\",\"tibble\",\"tidyr\",\n  \"suncalc\",\"gstat\",\"randomForest\",\"mgcv\",\"scales\",\"patchwork\",\"knitr\"\n)\ninst <- rownames(installed.packages())\nif (any(!req_pkgs %in% inst)) install.packages(setdiff(req_pkgs, inst), dependencies = TRUE)\ninvisible(lapply(req_pkgs, require, character.only = TRUE))\nsf::sf_use_s2(FALSE)  # robust joins in small projected domains\nset.seed(42)\n\n# Domain & grid ---------------------------------------------------------\ncrs_utm <- \"EPSG:32632\"\nE0 <- 600000; N0 <- 5725000\nlen_x <- 500; len_y <- 300; res <- 5\next <- terra::ext(E0 - len_x/2, E0 + len_x/2, N0 - len_y/2, N0 + len_y/2)\nRtemplate <- terra::rast(ext, resolution = res, crs = crs_utm)\n\nxmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\nymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\nx0 <- (xmin+xmax)/2;      y0 <- (ymin+ymax)/2\n\n# Feature placement (left/right thirds) --------------------------------\nx_hill_center <- xmin + len_x/3;   y_hill_center <- y0\nx_lake_center <- xmin + 2*len_x/3; y_lake_center <- y0\n\n# Scenario controls -----------------------------------------------------\nlake_choice <- \"water\"   # \"none\" | \"water\" | \"hollow\"\nhill_choice <- \"bump\"    # \"none\" | \"bump\"\n\nlake_diam_m  <- 80; lake_depth_m <- 10; smooth_edges <- FALSE\nhill_diam_m  <- 80; hill_height_m <- 50; hill_smooth  <- FALSE\npool_block_gain <- 0.4        # night pooling weakened over hill (0..1)\n\n# Stations --------------------------------------------------------------\nstation_mode      <- \"random\"     # \"random\" | \"ns_transect\" | \"ew_transect\"\nn_st              <- 60\ntransect_margin_m <- 10\nns_offset_m <- 0   # + east / - west\new_offset_m <- 0   # + north / - south\n\n# CV & models -----------------------------------------------------------\nblock_size <- 100  # LBO block size in meters\nmodels_use <- c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\")\n\n# Viz palettes ----------------------------------------------------------\ntemp_palette <- grDevices::colorRampPalette(c(\"#0000FF\",\"#FF0000\"))(256)  # blue->red\nstretch_q    <- c(0.02, 0.98)\n```\n:::\n\n\n\n![The pipe-valley with hill and hole and lateral virtual stations along the valley ground](pipe.png){width=\"530\"}\n\n## B. Engine: sun geometry, physics & scenario builder\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sun geometry ----------------------------------------------------------\nlat <- 51.8; lon <- 10.6\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  az_from_north <- (sp$azimuth + pi) %% (2*pi)\n  list(alt = sp$altitude, az = az_from_north)\n}\nsun14 <- sun_pos_utc(2024, 6, 21, 14, lat, lon)\nsun05 <- sun_pos_utc(2024, 6, 21,  5, lat, lon)\n\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n\n# Scenario builder ------------------------------------------------------\nbuild_scenario <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                           hill_mode = c(\"none\",\"bump\")) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / ((len_y/2)^2)              # ~100 m rim height\n  elev <- 500 + a * dy^2\n\n  # Pond/hollow (right third)\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Hill (left third)\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h <- if (hill_smooth) exp(- (rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else w_h <- 0\n\n  E <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW <- Rtemplate; terra::values(hillW) <- if (hill_mode==\"bump\") w_h else 0; names(hillW) <- \"hillW\"\n\n  # Derivatives & sun\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  # Physics\n  set.seed(1001); noise14 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  set.seed(1002); noise05 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - y0); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool      <- pool_base * (1 - pool_block_gain * hillW)\n  alpha_I_grass <- 5.0; alpha_I_water <- 1.5\n  alpha_map <- alpha_I_grass * (1 - lakeR) + alpha_I_water * lakeR\n  warm_bias_water_dawn <- if (lake_mode==\"water\") 1.5 else 0\n\n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_map * I14 + noise14; names(R14) <- \"T14\"\n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool + warm_bias_water_dawn * lakeR + noise05; names(R05) <- \"T05\"\n\n  # Replace non‑finite with median\n  fix_nonfinite <- function(r) { v <- terra::values(r); m <- stats::median(v[is.finite(v)], na.rm = TRUE); v[!is.finite(v)] <- m; terra::values(r) <- v; r }\n  list(E = fix_nonfinite(E), R14 = fix_nonfinite(R14), R05 = fix_nonfinite(R05),\n       lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05)\n}\n\nscen <- build_scenario(lake_choice, hill_choice)\n\nsummary(scen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Length Class      Mode\nE     1      SpatRaster S4  \nR14   1      SpatRaster S4  \nR05   1      SpatRaster S4  \nlake  1      SpatRaster S4  \nhillW 1      SpatRaster S4  \nslp   1      SpatRaster S4  \nasp   1      SpatRaster S4  \nI14   1      SpatRaster S4  \nI05   1      SpatRaster S4  \n```\n\n\n:::\n:::\n\n\n\n## C. Stations: sampling & extraction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Station coordinates ---------------------------------------------------\nif (station_mode == \"random\") {\n  pts <- tibble::tibble(\n    id = 1:n_st,\n    x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n    y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n  )\n} else if (station_mode == \"ns_transect\") {\n  x_const <- min(max(x0 + ns_offset_m, xmin + transect_margin_m), xmax - transect_margin_m)\n  y_seq   <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_const, y = y_seq)\n} else if (station_mode == \"ew_transect\") {\n  y_const <- min(max(y0 + ew_offset_m, ymin + transect_margin_m), ymax - transect_margin_m)\n  x_seq   <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_seq, y = y_const)\n} else stop(\"Unknown station_mode\")\n\npts_sf <- sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\nvpts   <- terra::vect(pts_sf)\n\n# Extract covariates & targets -----------------------------------------\npts$z_surf <- as.numeric(terra::extract(scen$E,   vpts, ID = FALSE)[,1])\npts$slp    <- as.numeric(terra::extract(scen$slp, vpts, ID = FALSE)[,1])\npts$I14    <- as.numeric(terra::extract(scen$I14, vpts, ID = FALSE)[,1])\npts$I05    <- as.numeric(terra::extract(scen$I05, vpts, ID = FALSE)[,1])\npts$T14    <- as.numeric(terra::extract(scen$R14, vpts, ID = FALSE)[,1])\npts$T05    <- as.numeric(terra::extract(scen$R05, vpts, ID = FALSE)[,1])\n\n# Keep complete rows per time slot -------------------------------------\npts14 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I14\",\"T14\")]), ]\npts05 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I05\",\"T05\")]), ]\n\n# Unify response name to 'temp' ----------------------------------------\nstn_sf_14 <- pts14 |>\n  dplyr::transmute(id, x, y,\n                   z_surf = as.numeric(z_surf),\n                   slp    = as.numeric(slp),\n                   cosi   = as.numeric(I14),\n                   temp   = as.numeric(T14)) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\nstn_sf_05 <- pts05 |>\n  dplyr::transmute(id, x, y,\n                   z_surf = as.numeric(z_surf),\n                   slp    = as.numeric(slp),\n                   cosi   = as.numeric(I05),\n                   temp   = as.numeric(T05)) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\n# Quick station table ---------------------------------------------------\nknitr::kable(\n  pts |>\n    dplyr::transmute(id, easting = round(x), northing = round(y),\n                      z_surf = round(z_surf,1), T14_C = round(T14,1), T05_C = round(T05,1)),\n  caption = \"Station sample (sanity check)\", digits = 1\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Station sample (sanity check)\n\n| id| easting| northing| z_surf| T14_C| T05_C|\n|--:|-------:|--------:|------:|-----:|-----:|\n|  1|  600182|  5724912|  534.0|  28.1|   7.6|\n|  2|  599785|  5724917|  530.2|  27.9|   8.2|\n|  3|  600093|  5724994|  490.2|  27.5|   5.6|\n|  4|  600061|  5724914|  534.0|  28.5|   8.4|\n|  5|  600006|  5725001|  500.0|  30.1|   4.8|\n|  6|  600056|  5725136|  584.0|  28.6|   8.7|\n|  7|  600227|  5725015|  500.7|  30.5|   4.5|\n|  8|  600209|  5725074|  523.4|  30.0|   7.5|\n|  9|  599878|  5724950|  510.0|  29.5|   6.0|\n| 10|  600160|  5724901|  542.2|  27.8|   8.7|\n| 11|  599799|  5724871|  572.2|  27.1|   8.7|\n| 12|  599844|  5724936|  517.4|  28.5|   6.8|\n| 13|  600003|  5724861|  584.0|  26.6|   9.0|\n| 14|  600023|  5724932|  520.2|  28.5|   7.0|\n| 15|  599984|  5724932|  520.2|  28.6|   7.2|\n| 16|  600125|  5725078|  526.7|  29.6|   7.7|\n| 17|  600181|  5725088|  534.0|  30.2|   8.1|\n| 18|  599784|  5725130|  572.2|  29.7|   8.2|\n| 19|  600036|  5724942|  514.7|  28.9|   7.2|\n| 20|  599877|  5724964|  506.2|  29.5|   5.8|\n| 21|  600020|  5724920|  526.7|  28.1|   8.0|\n| 22|  600093|  5725019|  491.4|  26.9|   6.4|\n| 23|  599991|  5725094|  538.0|  29.8|   8.1|\n| 24|  599856|  5725082|  530.2|  29.9|   7.9|\n| 25|  600015|  5725101|  546.7|  29.8|   8.3|\n| 26|  599824|  5725118|  561.4|  29.4|   9.2|\n| 27|  599795|  5725061|  517.4|  30.7|   6.3|\n| 28|  600194|  5724889|  556.2|  27.3|   8.7|\n| 29|  600107|  5725092|  538.0|  29.7|   7.8|\n| 30|  599782|  5724926|  523.4|  28.5|   6.9|\n| 31|  600076|  5725096|  542.2|  29.8|   8.0|\n| 32|  599868|  5724938|  517.4|  28.8|   7.3|\n| 33|  599898|  5725034|  554.7|  26.8|   7.3|\n| 34|  600158|  5725131|  578.0|  29.5|   8.9|\n| 35|  600141|  5724968|  504.7|  29.7|   5.9|\n| 36|  600043|  5725014|  500.7|  27.0|   5.2|\n| 37|  600204|  5724967|  504.7|  29.8|   5.3|\n| 38|  600212|  5724912|  534.0|  27.9|   7.7|\n| 39|  599849|  5725108|  551.4|  29.7|   8.8|\n| 40|  599972|  5725006|  500.2|  30.2|   4.2|\n| 41|  600190|  5724992|  500.2|  30.2|   4.8|\n| 42|  599921|  5725110|  556.2|  29.9|   8.5|\n| 43|  599975|  5725124|  566.7|  29.0|   9.2|\n| 44|  600049|  5724939|  517.4|  28.5|   7.2|\n| 45|  599815|  5725090|  534.0|  30.4|   7.5|\n| 46|  600148|  5724890|  556.2|  27.4|   8.8|\n| 47|  599892|  5724982|  551.4|  29.5|   6.6|\n| 48|  599836|  5725001|  500.0|  29.9|   4.6|\n| 49|  599896|  5725078|  526.7|  30.6|   8.0|\n| 50|  599831|  5724970|  504.7|  29.4|   5.0|\n| 51|  599785|  5725056|  514.7|  30.1|   6.5|\n| 52|  599919|  5725114|  556.2|  29.4|   9.0|\n| 53|  600118|  5725059|  514.7|  30.3|   6.8|\n| 54|  600162|  5724898|  546.7|  27.7|   8.1|\n| 55|  599992|  5724994|  500.2|  30.2|   4.7|\n| 56|  599905|  5724968|  554.7|  29.8|   6.9|\n| 57|  599836|  5724932|  520.2|  28.5|   7.0|\n| 58|  599890|  5725004|  550.0|  29.1|   6.1|\n| 59|  600074|  5724940|  514.7|  28.2|   6.4|\n| 60|  600128|  5725094|  538.0|  29.1|   8.0|\n\n\n:::\n:::\n\n\n\n## D. Modeling helpers\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grid blocks for LBO-CV ------------------------------------------------\nmake_blocks_and_assign <- function(pts_sf, E, block_size = 100) {\n  bb <- sf::st_as_sfc(\n    sf::st_bbox(\n      c(xmin = terra::xmin(E), ymin = terra::ymin(E), xmax = terra::xmax(E), ymax = terra::ymax(E)),\n      crs = sf::st_crs(pts_sf)\n    )\n  )\n  gr <- sf::st_make_grid(bb, cellsize = c(block_size, block_size), what = \"polygons\")\n  blocks <- sf::st_sf(block_id = seq_along(gr), geometry = gr)\n  pts_blk <- sf::st_join(pts_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (any(is.na(pts_blk$block_id))) {\n    nearest <- sf::st_nearest_feature(pts_blk[is.na(pts_blk$block_id), ], blocks)\n    pts_blk$block_id[is.na(pts_blk$block_id)] <- blocks$block_id[nearest]\n  }\n  list(blocks = blocks, pts = pts_blk)\n}\n\nplot_blocks_grid <- function(blocks, pts_blk, title = \"Blocks & stations\") {\n  ggplot() +\n    geom_sf(data = blocks, fill = NA, color = \"grey50\", linewidth = 0.2) +\n    geom_sf(data = pts_blk, aes(color = factor(block_id)), size = 2) +\n    scale_color_brewer(palette = \"Set2\", name = \"Block\") +\n    coord_sf(expand = FALSE) + theme_minimal() +\n    labs(title = title, x = \"Easting\", y = \"Northing\")\n}\n\n# GAM helpers -----------------------------------------------------------\nfit_gam_safe <- function(stn_sf) {\n  d <- stn_sf |> sf::st_drop_geometry()\n  d <- d[stats::complete.cases(d), , drop = FALSE]\n  n <- nrow(d); if (n < 10) stop(\"Too few stations for GAM: n=\", n)\n  n_xy <- dplyr::n_distinct(paste0(round(d$x,3), \"_\", round(d$y,3)))\n  k_xy <- max(10, min(60, n_xy - 1, floor(n * 0.8)))\n  k1   <- function(v, kmax=15) { ku <- length(unique(d[[v]])); max(4, min(ku - 1, kmax)) }\n  mgcv::gam(temp ~ s(x,y,bs='tp',k=k_xy) + s(z_surf,bs='tp',k=k1(\"z_surf\",20)) +\n              s(slp,bs='tp',k=k1(\"slp\",12)) + s(cosi,bs='tp',k=k1(\"cosi\",12)),\n            data = d, method = \"REML\", select = TRUE)\n}\n\n# Pointwise predictors --------------------------------------------------\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf); as.numeric(train_sf$temp)[idx]\n}\n\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  pr <- gstat::idw(temp ~ 1, as(train_sf[\"temp\"], \"Spatial\"), newdata = as(test_sf, \"Spatial\"), idp = idp)\n  as.numeric(pr$var1.pred)\n}\n\npred_OK <- function(train_sf, test_sf) {\n  tr_sp <- as(train_sf[\"temp\"], \"Spatial\")\n  vg    <- gstat::variogram(temp ~ 1, tr_sp)\n  vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(train_sf$temp, na.rm=TRUE), model=\"Exp\", range=100)\n  kr <- gstat::krige(temp ~ 1, locations = tr_sp, newdata = as(test_sf, \"Spatial\"), model = vgm_fit)\n  as.numeric(kr$var1.pred)\n}\n\npred_KED <- function(train_sf, test_sf, E = NULL) {\n  if (is.null(E)) stop(\"pred_KED: provide raster E for fallback elevation extraction.\")\n  add_z <- function(s) { if (!(\"z_surf\" %in% names(s)) || any(!is.finite(s$z_surf))) { z <- terra::extract(E, sf::st_coordinates(s))[,1]; s$z_surf <- as.numeric(z) }; s }\n  train_sf <- add_z(train_sf); test_sf <- add_z(test_sf)\n  tr_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(train_sf), data = data.frame(temp = train_sf$temp, z_surf = as.numeric(train_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(train_sf)$wkt))\n  tr_sp <- tr_sp[stats::complete.cases(tr_sp@data), ]\n  te_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(test_sf), data = data.frame(z_surf = as.numeric(test_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(test_sf)$wkt))\n  vg <- gstat::variogram(temp ~ z_surf, tr_sp)\n  vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(tr_sp$temp, na.rm=TRUE), model=\"Exp\", range=100)\n  pr <- gstat::krige(temp ~ z_surf, locations = tr_sp, newdata = te_sp, model = vgm_fit)\n  as.numeric(pr$var1.pred)\n}\n\npred_RF <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf); dtr <- stats::na.omit(dtr)\n  if (nrow(dtr) < 5) return(rep(NA_real_, nrow(test_sf)))\n  rf  <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi, data = dtr, na.action = na.omit)\n  dte <- sf::st_drop_geometry(test_sf)\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n  out <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(rf, dte[good, ])\n  out\n}\n\npred_GAM <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf); dtr <- dtr[stats::complete.cases(dtr), , drop = FALSE]\n  if (nrow(dtr) < 10) return(rep(NA_real_, nrow(test_sf)))\n  gm <- fit_gam_safe(train_sf)\n  dte <- sf::st_drop_geometry(test_sf)\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n  out <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(gm, dte[good, ], type=\"response\")\n  out\n}\n\n# Leave-Block-Out CV ----------------------------------------------------\nrun_lbo_cv <- function(stn_sf, E, block_size = 100, models = models_use) {\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) {\n    xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2]\n  }\n  blk <- make_blocks_and_assign(stn_sf, E, block_size = block_size)\n  blocks_sf <- blk$blocks; stn_blk <- blk$pts\n  restore <- function(nm) if (!(nm %in% names(stn_blk))) stn_blk[[nm]] <<- stn_sf[[nm]][match(stn_blk$id, stn_sf$id)]\n  for (nm in c(\"temp\",\"z_surf\",\"slp\",\"cosi\",\"x\",\"y\")) restore(nm)\n\n  block_ids <- sort(unique(stn_blk$block_id))\n  out_list <- vector(\"list\", length(block_ids))\n  for (k in seq_along(block_ids)) {\n    b <- block_ids[k]\n    test_idx  <- which(stn_blk$block_id == b)\n    train_idx <- which(stn_blk$block_id != b)\n    train_sf <- stn_blk[train_idx, ]; test_sf <- stn_blk[test_idx, ]\n    pred_tbl <- lapply(models, function(m) {\n      p <- switch(m,\n        \"Voronoi\" = pred_Voronoi(train_sf, test_sf),\n        \"IDW\"     = pred_IDW(train_sf, test_sf),\n        \"OK\"      = pred_OK(train_sf, test_sf),\n        \"KED\"     = pred_KED(train_sf, test_sf, E = E),\n        \"RF\"      = pred_RF(train_sf, test_sf),\n        \"GAM\"     = pred_GAM(train_sf, test_sf),\n        stop(\"Unknown model: \", m)\n      )\n      tibble::tibble(model = m, id = test_sf$id, obs = test_sf$temp, pred = p, block_id = b)\n    })\n    out_list[[k]] <- dplyr::bind_rows(pred_tbl)\n  }\n\n  cv_tbl <- dplyr::bind_rows(out_list)\n  metrics <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(\n      n    = dplyr::n(),\n      MAE  = mean(abs(obs - pred), na.rm = TRUE),\n      RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)),\n      Bias = mean(pred - obs, na.rm = TRUE),\n      R2   = cor(obs, pred, use = \"complete.obs\")^2,\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n\n  diag_plot <- ggplot(cv_tbl, aes(obs, pred)) +\n    geom_abline(slope=1, intercept=0, linetype=\"dashed\") +\n    geom_point(alpha=0.7) +\n    coord_equal() + theme_minimal() +\n    labs(title = sprintf(\"LBO-CV (block = %dm) — Observed vs Predicted\", block_size), x = \"Observed\", y = \"Predicted\") +\n    facet_wrap(~ model)\n\n  blocks_plot <- plot_blocks_grid(blocks_sf, stn_blk, title = sprintf(\"Blocks (%.0f m) & stations\", block_size))\n  list(cv = cv_tbl, metrics = metrics, diag_plot = diag_plot, blocks_plot = blocks_plot)\n}\n\n# Prediction maps & error panels ---------------------------------------\n.make_labeller <- function(cv_tbl) {\n  m <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE  = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\")\n  setNames(sprintf(\"%s  (RMSE=%.2f · MAE=%.2f)\", m$model, m$RMSE, m$MAE), m$model)\n}\n\npredict_maps <- function(stn_sf, truth_raster, which_time = c(\"T14\",\"T05\"), scen, models = models_use) {\n  which_time <- match.arg(which_time)\n  E <- scen$E; slp_r <- scen$slp; cosi_r <- if (which_time == \"T14\") scen$I14 else scen$I05\n  train_sf <- stn_sf\n  if (!all(c(\"x\",\"y\") %in% names(train_sf))) { xy <- sf::st_coordinates(train_sf); train_sf$x <- xy[,1]; train_sf$y <- xy[,2] }\n  if (!(\"z_surf\" %in% names(train_sf))) train_sf$z_surf <- as.numeric(terra::extract(E,      sf::st_coordinates(train_sf))[,1])\n  if (!(\"slp\"    %in% names(train_sf))) train_sf$slp    <- as.numeric(terra::extract(slp_r,  sf::st_coordinates(train_sf))[,1])\n  if (!(\"cosi\"   %in% names(train_sf))) train_sf$cosi   <- as.numeric(terra::extract(cosi_r, sf::st_coordinates(train_sf))[,1])\n\n  grid_df <- as.data.frame(c(E, slp_r, cosi_r), xy = TRUE, na.rm = FALSE); names(grid_df) <- c(\"x\",\"y\",\"elev\",\"slp\",\"cosi\"); grid_df$z_surf <- grid_df$elev\n  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\",\"y\"), crs = sf::st_crs(train_sf), remove = FALSE)\n  good_grid <- stats::complete.cases(grid_df[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")])\n\n  pred_list <- list()\n  if (\"Voronoi\" %in% models) { idx <- sf::st_nearest_feature(grid_sf, train_sf); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(train_sf$temp)[idx[good_grid]]; pred_list$Voronoi <- tmp }\n\n  grid_sp <- as(grid_sf, \"Spatial\")\n  if (\"IDW\" %in% models) { message(\"[inverse distance weighted interpolation]\"); tr_sp <- as(train_sf[\"temp\"], \"Spatial\"); pr <- gstat::idw(temp ~ 1, locations = tr_sp, newdata = grid_sp, idp = 2); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$IDW <- tmp }\n  if (\"OK\"  %in% models) { message(\"[using ordinary kriging]\"); tr_sp <- as(train_sf[\"temp\"], \"Spatial\"); vg <- gstat::variogram(temp ~ 1, tr_sp); vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE); if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(train_sf$temp, na.rm = TRUE), model = \"Exp\", range = 100); pr  <- gstat::krige(temp ~ 1, locations = tr_sp, newdata = grid_sp, model = vgm_fit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$OK <- tmp }\n  if (\"KED\" %in% models) { message(\"[using universal kriging]\"); tr_sp <- sp::SpatialPointsDataFrame(coords = sf::st_coordinates(train_sf), data = data.frame(temp = train_sf$temp, z_surf = as.numeric(train_sf$z_surf)), proj4string = sp::CRS(sf::st_crs(train_sf)$wkt)); tr_sp <- tr_sp[stats::complete.cases(tr_sp@data), ]; stopifnot(\"z_surf\" %in% names(grid_sp@data)); vg <- gstat::variogram(temp ~ z_surf, tr_sp); vgm_fit <- try(gstat::fit.variogram(vg, gstat::vgm(\"Exp\")), silent = TRUE); if (inherits(vgm_fit, \"try-error\")) vgm_fit <- gstat::vgm(variance = stats::var(tr_sp$temp, na.rm = TRUE), model = \"Exp\", range = 100); pr  <- gstat::krige(temp ~ z_surf, locations = tr_sp, newdata = grid_sp, model = vgm_fit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- as.numeric(pr$var1.pred)[good_grid]; pred_list$KED <- tmp }\n  if (\"RF\"  %in% models) { dtr <- sf::st_drop_geometry(train_sf); dtr <- stats::na.omit(dtr); rf <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi, data = dtr, na.action = na.omit); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- stats::predict(rf, grid_df[good_grid, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")]); pred_list$RF <- tmp }\n  if (\"GAM\" %in% models) { dtr <- sf::st_drop_geometry(train_sf); n <- nrow(dtr); k_xy <- max(10, min(60, n - 5)); gm  <- mgcv::gam(temp ~ s(x,y,k=k_xy) + s(z_surf,k=15) + s(slp,k=12) + s(cosi,k=12), data = dtr, method = \"REML\"); tmp <- rep(NA_real_, nrow(grid_df)); tmp[good_grid] <- stats::predict(gm, grid_df[good_grid, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\")], type=\"response\"); pred_list$GAM <- tmp }\n\n  pred_df  <- dplyr::bind_rows(lapply(names(pred_list), function(nm) { tibble::tibble(model = nm, x = grid_df$x, y = grid_df$y, pred = pred_list[[nm]]) }))\n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE); names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  lims <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n\n  p_pred <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(.make_labeller(data.frame(obs=pred_df$pred, pred=pred_df$pred, model=pred_df$model))))\n\n  p_truth <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time), x = \"Easting\", y = \"Northing\")\n\n  list(pred_df = pred_df, p_pred = p_pred, p_truth = p_truth)\n}\n\n# Error/diagnostic panels ----------------------------------------------\nblock_metrics_long <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"block_id\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  cv_tbl |>\n    dplyr::group_by(model, block_id) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\") |>\n    tidyr::pivot_longer(c(RMSE, MAE), names_to = \"Metric\", values_to = \"Value\")\n}\n\norder_models_by_median_rmse <- function(cv_tbl) {\n  bm <- block_metrics_long(cv_tbl)\n  bm |>\n    dplyr::filter(Metric == \"RMSE\") |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(Value, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n}\n\nmake_block_metric_box <- function(cv_tbl, which_time = \"T14\") {\n  bm <- block_metrics_long(cv_tbl)\n  lev <- order_models_by_median_rmse(cv_tbl)\n  bm$model <- factor(bm$model, levels = lev)\n  ggplot2::ggplot(bm, ggplot2::aes(model, Value)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.35, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3, fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Block-wise errors (LBO-CV)\", which_time), subtitle = \"Box = IQR · line = median · ◆ = mean\", x = \"Model\", y = \"Error\") +\n    ggplot2::facet_wrap(~ Metric, scales = \"free_y\")\n}\n\nmake_abs_error_box <- function(cv_tbl, which_time = \"T14\") {\n  df <- cv_tbl |> dplyr::mutate(abs_err = abs(pred - obs))\n  lev <- df |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(abs_err, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n  df$model <- factor(df$model, levels = lev)\n  ggplot2::ggplot(df, ggplot2::aes(model, abs_err)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.3, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3, fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Absolute errors per station (LBO-CV)\", which_time), subtitle = \"Box = IQR · line = median · ◆ = mean\", x = \"Model\", y = \"|pred − obs|\")\n}\n\nbuild_panels_with_errors <- function(maps, truth_raster, cv_tbl, stn_sf, which_time, temp_palette = temp_palette, stretch_q = stretch_q) {\n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE); names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  pred_df  <- maps$pred_df\n  err_df   <- dplyr::inner_join(pred_df, truth_df, by = c(\"x\",\"y\")) |>\n    dplyr::mutate(err = pred - truth)\n  emax <- max(abs(err_df$err), na.rm = TRUE); emax <- if (is.finite(emax)) emax else 1\n  lims_T <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n  coords  <- sf::st_coordinates(stn_sf)\n  st_xy   <- tibble::tibble(id = stn_sf$id, x = coords[,1], y = coords[,2])\n  st_res  <- cv_tbl |>\n    dplyr::mutate(resid = pred - obs) |>\n    dplyr::select(model, id, resid) |>\n    dplyr::left_join(st_xy, by = \"id\")\n  lab <- .make_labeller(cv_tbl)\n  p_truth <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims_T, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time), x = \"Easting\", y = \"Northing\")\n  p_pred <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims_T, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n  p_err <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = err_df, ggplot2::aes(x, y, fill = err)) +\n    ggplot2::scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#de2d26\", midpoint = 0, limits = c(-emax, emax), name = \"Error\") +\n    ggplot2::geom_point(data = st_res, ggplot2::aes(x, y, fill = resid), shape = 21, colour = \"black\", size = 2, stroke = 0.2) +\n    ggplot2::scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#de2d26\", midpoint = 0, limits = c(-emax, emax), name = \"Error\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Error (pred − truth) with CV residuals\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n  (p_truth | p_pred) / p_err\n}\n```\n:::\n\n\n\n## E. Run models with spatial CV and plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# LBO-CV & prediction maps ---------------------------------------------\nmessage(\"Running LBO-CV and building maps for T14 ...\")\nres14  <- run_lbo_cv(stn_sf_14, scen$E, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps14 <- predict_maps(stn_sf_14, scen$R14, which_time = \"T14\", scen = scen, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T05 ...\")\nres05  <- run_lbo_cv(stn_sf_05, scen$E, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps05 <- predict_maps(stn_sf_05, scen$R05, which_time = \"T05\", scen = scen, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using ordinary kriging]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\n# Spatial blocks + Obs-vs-Pred -----------------------------------------\n(res14$blocks_plot | res14$diag_plot) / (res05$blocks_plot | res05$diag_plot)\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_files/figure-html/unnamed-chunk-6-1.png){width=1350}\n:::\n:::\n\n\n\n### Truth, predictions & error panels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npanel14 <- build_panels_with_errors(maps14, scen$R14, res14$cv, stn_sf_14, \"T14\", temp_palette = temp_palette, stretch_q = stretch_q)\npanel05 <- build_panels_with_errors(maps05, scen$R05, res05$cv, stn_sf_05, \"T05\", temp_palette = temp_palette, stretch_q = stretch_q)\npanel14\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_files/figure-html/unnamed-chunk-7-1.png){width=1350}\n:::\n\n```{.r .cell-code}\npanel05\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_files/figure-html/unnamed-chunk-7-2.png){width=1350}\n:::\n:::\n\n\n\n### Block‑wise and per‑station errors\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_block_box14  <- make_block_metric_box(res14$cv, \"T14\")\np_abserr_box14 <- make_abs_error_box(res14$cv,  \"T14\")\np_block_box05  <- make_block_metric_box(res05$cv, \"T05\")\np_abserr_box05 <- make_abs_error_box(res05$cv,  \"T05\")\n\n(p_block_box14 | p_abserr_box14) / (p_block_box05 | p_abserr_box05)\n```\n\n::: {.cell-output-display}\n![](pipemodel_3_files/figure-html/unnamed-chunk-8-1.png){width=1350}\n:::\n:::\n\n\n\n### LBO‑CV metrics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(res14$metrics, digits = 3, caption = \"LBO‑CV metrics — T14\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO‑CV metrics — T14\n\n|model   |  n|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|-----:|-----:|------:|-----:|\n|GAM     | 60| 0.418| 0.734|  0.160| 0.582|\n|RF      | 60| 0.568| 0.796|  0.036| 0.460|\n|KED     | 60| 0.682| 0.872| -0.098| 0.365|\n|OK      | 60| 0.771| 0.993| -0.059| 0.156|\n|IDW     | 60| 0.838| 1.032| -0.031| 0.082|\n|Voronoi | 60| 0.887| 1.248| -0.051| 0.069|\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(res05$metrics, digits = 3, caption = \"LBO‑CV metrics — T05\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO‑CV metrics — T05\n\n|model   |  n|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|-----:|-----:|------:|-----:|\n|GAM     | 60| 0.420| 0.600|  0.055| 0.815|\n|RF      | 60| 0.506| 0.643|  0.066| 0.786|\n|KED     | 60| 0.662| 0.831|  0.061| 0.628|\n|OK      | 60| 0.773| 1.023| -0.078| 0.435|\n|IDW     | 60| 1.084| 1.323| -0.108| 0.055|\n|Voronoi | 60| 1.108| 1.373|  0.199| 0.216|\n\n\n:::\n:::\n\n\n\n---\n\n# H. Physics & Scenario Builder — Cheat Sheet\n\n## H.1 Generated rasters & derived fields\n\n| Name          | Unit | What it is                             | How it’s built                                                              |\n| ------------- | ---: | -------------------------------------- | --------------------------------------------------------------------------- |\n| `E` (`elev`)  |    m | Ground elevation                       | Parabolic “half-pipe” across **y**, + optional hill, − optional pond/hollow |\n| `slp`         |  rad | Slope (terrain steepness)              | `terra::terrain(E, \"slope\", \"radians\")`                                     |\n| `asp`         |  rad | Aspect (downslope direction)           | `terra::terrain(E, \"aspect\", \"radians\")`                                    |\n| `I14`, `I05`  |    – | Cosine of solar incidence at 14/05 UTC | `cosi_fun(alt, az, slp, asp)`, clamped at 0                                 |\n| `lake`        |  0/1 | Water mask (1 if pond is water)        | Disk at right third; only 1 when `lake_choice == \"water\"`                   |\n| `hillW`       |  0–1 | Hill weight (1 inside hill footprint)  | Disk at left third (or smooth Gaussian if enabled)                          |\n| `R14` (`T14`) |   °C | Daytime “truth” temperature            | See equation below                                                          |\n| `R05` (`T05`) |   °C | Pre-dawn “truth” temperature           | See equation below                                                          |\n\n## H.2 Governing equations\n\nLet $\\overline{E}$ be mean elevation, and `pool` the cold-air pooling term:\n\n$$\n\\begin{aligned}\nT_{14} &= T0_{14} \\;+\\; \\texttt{lapse\\_14}\\,(E-\\overline{E})\n\\;+\\; \\alpha_{\\text{map}}\\, I_{14}\n\\;+\\; \\varepsilon_{14}, \\\\\nT_{05} &= T0_{05} \\;+\\; \\texttt{inv\\_05}\\,(E-\\overline{E})\n\\;+\\; \\eta_{\\text{slope}}\\,\\texttt{slp}\n\\;-\\; \\texttt{pool}\n\\;+\\; \\texttt{warm\\_bias\\_water\\_dawn}\\cdot \\texttt{lake}\n\\;+\\; \\varepsilon_{05}.\n\\end{aligned}\n$$\n\n**Terms**\n\n* $\\alpha_{\\text{map}} = \\alpha_{I,\\text{grass}}\\cdot(1-\\texttt{lake}) + \\alpha_{I,\\text{water}}\\cdot\\texttt{lake}$.\n* `pool` = $A \\exp[-(d_y/w)^2]\\cdot(1 - \\texttt{pool\\_block\\_gain}\\cdot \\texttt{hillW})$, where $d_y=|y - y_0|$.\n* Noise $\\varepsilon_{14}, \\varepsilon_{05} \\sim \\mathcal{N}(0, 0.3^2)$ (independent by cell/time).\n\n## H.3 Dial summary (parameters you can tweak)\n\n| Parameter                    |               Default | Sensible range | Affects                    | Visual signature when increased (+)                  |                                                |                                                                              |\n| ---------------------------- | --------------------: | -------------: | -------------------------- | ---------------------------------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------- |\n| `T0_14`                      |               26.0 °C |          20–35 | T14 baseline               | Whole map warms uniformly                            |                                                |                                                                              |\n| `lapse_14`                   |          −0.0065 °C/m |   −0.01…−0.002 | T14 vs elevation           | Stronger cool-with-height (rim cooler, floor warmer) |                                                |                                                                              |\n| `αI_grass` (`alpha_I_grass`) |                   5.0 |            1–6 | T14 exposure               | Sun-facing slopes pop warmer by day                  |                                                |                                                                              |\n| `αI_water` (`alpha_I_water`) |                   1.5 |          0.2–3 | T14 over water             | Water heats less by day; lake flatter/ cooler        |                                                |                                                                              |\n| `T0_05`                      |                8.5 °C |           3–15 | T05 baseline               | Whole map warms uniformly                            |                                                |                                                                              |\n| `inv_05`                     |           +0.003 °C/m |        0–0.008 | T05 vs elevation           | Inversion strength: valley floor cooler vs rims      |                                                |                                                                              |\n| `η_slope` (`eta_slope`)      |                   0.6 |          0–1.5 | T05 topographic flow proxy | Steeper slopes slightly warmer at dawn               |                                                |                                                                              |\n| `pool_base` amplitude        |                 4.0 K |            1–8 | T05 pooling                | Stronger cold band along valley axis (blue stripe)   |                                                |                                                                              |\n| `w_pool` (m)                 |                    70 |         40–150 | T05 pooling width          | Narrower/ broader cold band                          |                                                |                                                                              |\n| `pool_block_gain`            |                   0.4 |            0–1 | T05 pooling near hill      | Suppresses pooling over hill; lee side warms         |                                                |                                                                              |\n| `warm_bias_water_dawn`       | 1.5 K (only if water) |            0–3 | T05 over water             | Lake area warmer pre-dawn                            |                                                |                                                                              |\n| `lake_choice`                |             `\"water\"` |       \\`\"none\" | \"water\"                    | \"hollow\"\\`                                           | Geometry + physics                             | `\"water\"`: thermal effects + mask; `\"hollow\"`: geom only (no water thermals) |\n| `hill_choice`                |              `\"bump\"` |       \\`\"none\" | \"bump\"\\`                   | Geometry + pooling                                   | Introduces pooling blocking and local warm rim |                                                                              |\n| `lake_diam_m`                |                    80 |         40–150 | Area of lake/hollow        | Larger disk on right third                           |                                                |                                                                              |\n| `lake_depth_m`               |                    10 |           5–30 | Elevation depression       | Stronger local depression (affects lapse/inversion)  |                                                |                                                                              |\n| `hill_diam_m`                |                    80 |         40–150 | Hill footprint             | Larger bump on left third                            |                                                |                                                                              |\n| `hill_height_m`              |                    50 |         10–120 | Hill relief                | Stronger pooling blocking & lapse effects            |                                                |                                                                              |\n| `smooth_edges`               |               `FALSE` |           bool | Lake boundary shape        | `TRUE` softens rim (harder for sharp interpolators)  |                                                |                                                                              |\n| `hill_smooth`                |               `FALSE` |           bool | Hill shape                 | `TRUE` makes bump Gaussian-smooth                    |                                                |                                                                              |\n| `noise σ`                    |                 0.3 K |            0–1 | Both                       | Adds sub-grid “sensor” noise/random texture          |                                                |                                                                              |\n\n## H.4 Quick “recipe” effects\n\n* **Cloudy/hazy day** → ↓ `alpha_I_grass`, ↓ `alpha_I_water`\n  → Daytime slope contrasts fade; RF/GAM rely more on spatial smoothness and elevation.\n* **Hotter afternoon** → ↑ `T0_14` (+1…+3 K)\n  → All models’ bias shifts; relative rankings unchanged.\n* **Stronger pooling** → ↑ `pool_base` and/or ↓ `w_pool`\n  → Sharper, colder centerline at dawn; models with drift (KED/GAM/RF) gain.\n* **Water vs hollow** → `\"water\"` adds: ↓ daytime heating (`αI_water`) + ↑ dawn warm bias\n  → Day/night asymmetry near pond strengthens; useful to test model nonlinearity.\n* **Pooling blocked by hill** → ↑ `pool_block_gain`\n  → Warm “tongue” over hill at dawn; spatial CV gets tougher (domain shift across blocks).\n\n## H.5 Geometry at a glance\n\n* **Valley**: Elevation $\\propto (y-y_0)^2$ — a U-shape across **y**, uniform along **x**.\n* **Hill** (left third): Disk (or Gaussian) of height `hill_height_m` and diameter `hill_diam_m`.\n* **Pond/Hollow** (right third): Disk depression of depth `lake_depth_m`; if `lake_choice == \"water\"` it also flips exposure gain and adds a pre-dawn warm bias.\n\n## H.6 What each term *looks like* on maps\n\n| Term                          | Map signature                                     |\n| ----------------------------- | ------------------------------------------------- |\n| `lapse_14*(E-Ȇ)`              | Subtle cool rims / warm floor (day)               |\n| `α_map * I14`                 | Warm, sun-facing slopes; damped over water        |\n| `inv_05*(E-Ȇ)`                | Warmer rims vs cooler floor (dawn inversion)      |\n| `η_slope*slp`                 | Slight warm bias on steeper slopes at dawn        |\n| `−pool`                       | Blue band centered on valley axis, width `w_pool` |\n| `+ warm_bias_water_dawn*lake` | Local warm spot over the lake at dawn             |\n\n---\n\n**Tip:** when benchmarking interpolators, try toggling **(a)** sharp vs. smooth feature rims, **(b)** strong vs. weak pooling, and **(c)** water vs. hollow. You’ll see IDW/OK struggle on discontinuities, while **KED/RF/GAM** better exploit drift and covariates—especially under strong physics signals.\n",
    "supporting": [
      "pipemodel_3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}