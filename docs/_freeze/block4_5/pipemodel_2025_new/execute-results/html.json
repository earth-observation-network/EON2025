{
  "hash": "3395acb04ab6ac8c33c5452b035cd253",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel Idealized valley microclimate sandbox \"\nsubtitle: \"with robust modeling, spatial CV, and land-cover physics\"\nauthor: \"gisma\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    code-fold: true\n    number-sections: true\n    embed-resources: true\n\nexecute:\n  echo: true\n  warning: false\n  message: false\n  results: hide\n---\n\n\n\n# Why the PipeModel?\n\nThe **PipeModel** is a deliberately idealized yet physically plausible valley scenario. It distills terrain to the essentials (parabolic cross-valley profile) and optional features (left-side hill, right-side pond or hollow), so that dominant **microclimate drivers** become visible and testable:\n\n* **Radiation** via terrain exposure `cos(i)` from slope & aspect\n* **Elevation**: daytime negative lapse; pre-dawn weak inversion\n* **Cold-air pooling** along the valley axis (Gaussian trough)\n* **Surface type / land-cover** (grass / forest / water / bare soil / maize) alters heating, shading, roughness and nocturnal behaviour\n\nYou can sample synthetic stations, train interpolators (IDW, Kriging variants, RF, GAM), and assess them with **spatial LBO-CV**.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crisp figures\n# EN: Crisp figures\nknitr::opts_chunk$set(fig.width = 9, fig.height = 6, dpi = 150)\n# Alle Chunk-Meldungen global weg\n# EN: Silence messages/warnings in all chunks\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n# Hilfsfunktion: gstat & Co. ruhigstellen\n# EN: Helper: silence gstat & friends\nquiet <- function(expr) suppressWarnings(suppressMessages(force(expr)))\n```\n:::\n\n\n\n## Helper function cheat-sheet\n\nlove this sandbox. here are the three things you asked for—ready to paste into your Quarto doc.\n\n# Helper functions (name | explanation)\n\n| name                           | explanation                                                                                                                                                         |                                                           |\n| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |\n| `build_topography()`           | Builds the DEM “half-pipe” valley plus optional left hill and right lake/hollow; returns `E`, `lake`, `hillW`, `slp`, `asp`, and sun-incidence rasters `I14`/`I05`. |                                                           |\n| `build_physics_fields()`       | Turns topo + land cover into “truth” temperature rasters (`R14`, `R05`) using lapse/inversion, slope & pooling terms, LC modifiers, and noise.                      |                                                           |\n| `build_scenario()`             | One-stop builder that calls topo + land-cover rules + physics; can sprinkle micro-hills; returns all rasters and LC metadata.                                       |                                                           |\n| `plot_landcover_terrain()`     | Quick tri-panel (LC, elevation, slope) with optional station overlay and feature contours.                                                                          |                                                           |\n| `plot_block_overview_2x2_en()` | Compact 2×2 overview: elevation, land cover (or slope), and cos(i) for 14/05 UTC.                                                                                   |                                                           |\n| `make_blocks_and_assign()`     | Makes a square grid (meters) and assigns each station to a block for LBO-CV.                                                                                        |                                                           |\n| `plot_blocks_grid()`           | Visualizes blocks + color-coded station membership.                                                                                                                 |                                                           |\n| `run_lbo_cv()`                 | Leave-Block-Out CV driver; returns per-point CV table, summary metrics, and diagnostic plots.                                                                       |                                                           |\n| `pred_Voronoi()`               | Nearest-neighbour (Voronoi) predictor.                                                                                                                              |                                                           |\n| `pred_IDW()`                   | Inverse Distance Weighting predictor.                                                                                                                               |                                                           |\n| `pred_OK()`                    | Ordinary Kriging with fitted (guarded) variogram.                                                                                                                   |                                                           |\n| `pred_KED()`                   | Kriging with external drifts (`z_surf`, `slp`, `cosi`, optional `lc`).                                                                                              |                                                           |\n| `pred_RF()`                    | Random Forest using `x,y,z_surf,slp,cosi` (+ `lc` if present).                                                                                                      |                                                           |\n| `pred_GAM()`                   | Penalized GAM with safe spline bases on space + drifts (+ optional `lc`).                                                                                           |                                                           |\n| `predict_maps()`               | Full-grid prediction for each model; returns rasters, long DF, and ready-made facet map.                                                                            |                                                           |\n| `build_panels_with_errors()`   | Assembles truth                                                                                                                                                     | predictions and CV diagnostics (boxes, scatter, density). |\n| `compute_Ls_from_points()`     | Empirical variogram + L50 / L95 process-scale extraction.                                                                                                           |                                                           |\n| `plot_variogram_with_scales()` | Plots empirical variogram with sill and L50/L95 markers.                                                                                                            |                                                           |\n| `smooth_dem_and_derive()`      | Gaussian-smoothed DEM; recomputes slope and cos(i) at a radius `R`.                                                                                                 |                                                           |\n| `cv_gam_with_R()`              | Blocked-CV RMSE of a GAM using smoothed drifts at radius `R`.                                                                                                       |                                                           |\n| `tune_Rstar_ucurve()`          | Scans `R` between L50–L95 to find `R*` that minimizes blocked-CV RMSE (“U-curve”).                                                                                  |                                                           |\n| `plot_ucurve()`                | Visualizes the U-curve and chosen `R*`.                                                                                                                             |                                                           |\n| `add_drifts_at_R()`            | Extracts smoothed drifts (`z_surf`, `slp`, `cosi`, `lc`) to station points at a given `R`.                                                                          |                                                           |\n\n-\n## 0. Setup & global options\n\n::: callout-note\n**Goal.** Make figures crisp, silence chatty packages, load deps, set\nCRS, and define tiny helpers used everywhere.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crisp figures\nknitr::opts_chunk$set(fig.width = 9, fig.height = 6, dpi = 150)\n# Silence messages/warnings in all chunks\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n# Helper: silence gstat & friends\nquiet <- function(expr) suppressWarnings(suppressMessages(force(expr)))\n\n# Packages ----------------------------------------------------------------\nreq_pkgs <- c(\n  \"terra\",\"sf\",\"ggplot2\",\"dplyr\",\"tibble\",\"tidyr\",\n  \"suncalc\",\"gstat\",\"randomForest\",\"mgcv\",\"scales\",\"patchwork\",\n  \"knitr\",\"kableExtra\",\"RColorBrewer\",\"zoo\"\n)\ninst <- rownames(installed.packages())\nif (any(!req_pkgs %in% inst)) install.packages(setdiff(req_pkgs, inst), dependencies = TRUE)\ninvisible(lapply(req_pkgs, require, character.only = TRUE))\nsf::sf_use_s2(FALSE)  # robust joins in small projected domains\nset.seed(42)\n\n`%||%` <- function(a, b) if (!is.null(a)) a else b\n```\n:::\n\n\n\n## 1. Domain, grid & scenario parameters\n\n::: callout-note\n**Idea.** Build a simple **half-pipe valley** with a **hill** (left) and\n**lake/hollow** (right). Keep everything in **UTM32N** meters to make\nspatial tuning physically interpretable.\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CRS & template grid ----------------------------------------------------\ncrs_utm <- \"EPSG:32632\"\nE0 <- 600000; N0 <- 5725000\nlen_x <- 1500; len_y <- 500; res <- 1\next <- terra::ext(E0 - len_x/2, E0 + len_x/2, N0 - len_y/2, N0 + len_y/2)\nRtemplate <- terra::rast(ext, resolution = res, crs = crs_utm)\n\nxmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\nymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\nx0 <- (xmin+xmax)/2;      y0 <- (ymin+ymax)/2\n\n# Feature anchors (left/right thirds)\nx_hill_center <- xmin + len_x/3;   y_hill_center <- y0\nx_lake_center <- xmin + 2*len_x/3; y_lake_center <- y0\n\n# Scenario toggles -------------------------------------------------------\nlake_choice <- \"water\"   # \"none\" | \"water\" | \"hollow\"\nhill_choice <- \"bump\"    # \"none\" | \"bump\"\n\n# Feature geometry\nlake_diam_m  <- 300; lake_depth_m <- 10; smooth_edges <- FALSE\nhill_diam_m  <- 100; hill_height_m <- 50; hill_smooth  <- TRUE\n\n# Night pooling reduction over hill (0..1)\npool_block_gain <- 0.4\nno_hill <- 100\n\n# Stations ---------------------------------------------------------------\nstation_mode      <- \"random\"     # \"random\" | \"ns_transect\" | \"ew_transect\"\nn_st              <- 60\ntransect_margin_m <- 10\nns_offset_m <- 0; ew_offset_m <- 0\n\n# CV & models ------------------------------------------------------------\n# Ziel: ~2.5 Stationen pro Block (anpassbar), mind. 3 Blöcke je Achse\ncompute_block_size <- function(len_x, len_y, n_st,\n                               target_st_per_block = 5,\n                               min_blocks_axis = 3,\n                               round_to = 50) {\n  area <- len_x * len_y\n  B_target <- max(min_blocks_axis^2, round(n_st / target_st_per_block))\n  bs <- sqrt(area / B_target)                         # idealisierte Blockkante\n  bs <- min(bs, len_x / min_blocks_axis, len_y / min_blocks_axis)  # mind. 3 pro Achse\n  bs <- max(round_to, round(bs / round_to) * round_to)             # \"schön\" runden\n  as.integer(bs)\n}\n\n# anwenden\nblock_size  <- compute_block_size(len_x, len_y, n_st)\n.get_block_size <- function() {\n  bs <- get0(\"block_size\", ifnotfound = 100)\n  if (!is.numeric(bs) || !is.finite(bs) || bs <= 0) 100 else as.numeric(bs)\n}\nmodels_use <- c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\")\n\n# Viz palettes -----------------------------------------------------------\ntemp_palette <- grDevices::colorRampPalette(c(\"#0000FF\",\"#FF0000\"))(256)  # blue->red\nstretch_q    <- c(0.02, 0.98)\n\n# Solar geometry (UTC) ---------------------------------------------------\nlat <- 51.8; lon <- 10.6\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  az_from_north <- (sp$azimuth + pi) %% (2*pi)\n  list(alt = sp$altitude, az = az_from_north)\n}\nsun14 <- sun_pos_utc(2024, 6, 21, 14, lat, lon)\nsun05 <- sun_pos_utc(2024, 6, 21,  5, lat, lon)\n\n# Cosine of incidence (sun on slope/aspect)\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n```\n:::\n\n\n\n## 2. Topography (valley, hill, lake/hollow)\n\n::: callout-tip\n**Physics stub.** Valley is a simple parabola in **y**; optional lake\nlowers the DEM; optional hill raises it on the left third. Slope/aspect\nand cos(i) are derived for **14 UTC** and **05 UTC**.\n:::\n\n# Physics table\n\n## A) Global knobs & terms (as coded)\n\n| symbol / term     |                 value (default) | used in | explanation                                                             |\n| ----------------- | ------------------------------: | ------- | ----------------------------------------------------------------------- |\n| `T0_14`           |                         26.0 °C | T14     | Daytime baseline at domain-mean elevation.                              |\n| `lapse_14`        |                  −0.0065 °C m⁻¹ | T14     | Negative lapse (warmer low, cooler high) at 14 UTC.                     |\n| `α(LC)`           |                    see LC table | T14     | Land-cover-specific gain on cos(i) (heating sensitivity).               |\n| `shade_fac(LC)`   |                    see LC table | T14     | Multiplies cos(i) to mimic canopy shading.                              |\n| `T0_05`           |                          8.5 °C | T05     | Pre-dawn baseline at domain-mean elevation.                             |\n| `inv_05`          |                   +0.003 °C m⁻¹ | T05     | Weak inversion (slightly warmer higher up pre-dawn).                    |\n| `η_slope`         |                             0.6 | T05     | Slope-term coefficient (drainage/exposure surrogate).                   |\n| `pool_base(y)`    |       `4·exp(-(d_axis/70)²)` °C | T05     | Gaussian cold-air pooling vs distance to valley axis (`w_pool = 70 m`). |\n| `pool_block_gain` |                             0.4 | T05     | Reduces pooling over the hill by `1 − 0.4·hillW`.                       |\n| `bias_dawn(LC)`   |                    see LC table | T05     | Additive pre-dawn LC bias (e.g., water warmer).                         |\n| noise σ           |                          0.3 °C | both    | Small texture added to fields.                                          |\n| sun geometry      | 21 Jun, 14/05 UTC, site lat/lon | both    | Drives cos(i) via `suncalc`; azimuth from north.                        |\n\nDaytime model:\n`T14 = T0_14 + lapse_14·(E − mean(E)) + α(LC)·[cos(i)·shade_fac(LC)] + noise`\n\nPre-dawn model:\n`T05 = T0_05 + inv_05·(E − mean(E)) + η_slope·slope − pooling + bias_dawn(LC) + noise`\n\n## B) Land-cover physics (per class)\n\n| Land cover | α(LC) (day gain) | shade\\_fac | bias\\_dawn (°C) | pool\\_fac (× on pooling) | qualitative effect                                             |\n| ---------- | ---------------: | ---------: | --------------: | -----------------------: | -------------------------------------------------------------- |\n| forest     |              3.5 |       0.60 |            +0.3 |                     0.70 | Muted daytime heating; less pooling; slightly warmer pre-dawn. |\n| water      |              1.5 |       1.00 |            +1.2 |                     0.80 | Small day gain; warm pre-dawn; damped pooling.                 |\n| bare soil  |              6.0 |       1.00 |            −0.5 |                     1.10 | Strong day heating; tends to over-cool pre-dawn & pool more.   |\n| meadow     |              4.0 |       0.95 |            +0.1 |                     1.05 | Moderate day heating; mild pooling amplification.              |\n| maize      |              4.5 |       0.90 |            +0.1 |                     1.00 | Slightly stronger day gain than meadow; neutral pooling.       |\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_topography <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                             hill_mode = c(\"none\",\"bump\")) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / ((len_y/2)^2)              # ~100 m rim height\n  elev <- 500 + a * dy^2\n\n  # Pond/hollow (right third)\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Hill (left third)\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h <- if (hill_smooth) exp(- (rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else w_h <- 0\n\n  E <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW <- Rtemplate; terra::values(hillW) <- if (hill_mode==\"bump\") w_h else 0; names(hillW) <- \"hillW\"\n\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  list(E = E, lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05)\n}\n```\n:::\n\n\n\n## 3. Land cover classes & physical response knobs\n\n::: callout-note\n**Why here?** We parameterize how **land cover** modulates **solar\nheating (day)** and **pooling/bias (pre-dawn)**. This lets you stress-test\nmodel sensitivity to plausible canopy/soil effects.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Land cover labels & colors\nlc_levels <- c(\"forest\",\"water\",\"bare soil\",\"meadow\",\"maize\")\nlc_colors <- c(\n  \"forest\"    = \"#2E8B57\",\n  \"water\"     = \"#5DADE2\",\n  \"bare soil\" = \"#C49A6C\",\n  \"meadow\"    = \"#9ACD32\",\n  \"maize\"     = \"#F4D03F\"\n)\n\n# Land-cover dependent physics (day/night response)\nalpha_I_by_lc <- c(   # day: sensitivity to insolation\n  \"forest\"    = 3.5,\n  \"water\"     = 1.5,\n  \"bare soil\" = 6.0,\n  \"meadow\"    = 4.0,\n  \"maize\"     = 4.5\n)\nshade_fac_by_lc <- c( # canopy shading factor\n  \"forest\"    = 0.6,\n  \"water\"     = 1.0,\n  \"bare soil\" = 1.0,\n  \"meadow\"    = 0.95,\n  \"maize\"     = 0.9\n)\ndawn_bias_by_lc <- c( # pre-dawn bias (°C)\n  \"forest\"    = 0.3,\n  \"water\"     = 1.2,\n  \"bare soil\" = -0.5,\n  \"meadow\"    = 0.1,\n  \"maize\"     = 0.1\n)\npool_fac_by_lc  <- c( # pooling multiplier (>1 = more cooling)\n  \"forest\"    = 0.7,\n  \"water\"     = 0.8,\n  \"bare soil\" = 1.1,\n  \"meadow\"    = 1.05,\n  \"maize\"     = 1.0\n)\n```\n:::\n\n\n\n## 4. Physics: generate “truth” rasters T14 / T05\n\n::: callout-tip\n**Model form.**\nT14 = baseline + lapse \\* (E − mean E) + α(LC)·cos(i)\\*shade + noise\nT05 = baseline + inversion \\* (E − mean E) + slope term − pooling + bias(LC) + noise\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_physics_fields <- function(topography, landcover, noise14, noise05) {\n  E    <- topography$E\n  slp0 <- topography$slp\n  I14  <- topography$I14\n  I05  <- topography$I05\n  hillW<- topography$hillW\n\n  lc <- if (inherits(landcover, \"SpatRaster\")) landcover else landcover$lc\n  stopifnot(inherits(lc, \"SpatRaster\"))\n\n  v  <- as.integer(terra::values(lc))\n  v[!is.finite(v)] <- 1L\n  v <- pmax(1L, pmin(v, length(lc_levels)))\n  lc_char <- factor(lc_levels[v], levels = lc_levels)\n\n  to_r <- function(x) terra::setValues(terra::rast(E), x)\n  alpha_I <- to_r(as.numeric(alpha_I_by_lc[lc_char]))\n  shade_f <- to_r(as.numeric(shade_fac_by_lc[lc_char]))\n  dawn_b  <- to_r(as.numeric(dawn_bias_by_lc[lc_char]))\n  pool_f  <- to_r(as.numeric(pool_fac_by_lc[lc_char]))\n\n  I14_eff <- I14 * shade_f\n\n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - (terra::ymax(E)+terra::ymin(E))/2); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool_mod  <- pool_base * (1 - pool_block_gain * hillW) * pool_f\n\n  # Day (14 UTC)\n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_I * I14_eff + noise14; names(R14) <- \"T14\"\n\n  # Pre-dawn (05 UTC)\n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool_mod + dawn_b + noise05; names(R05) <- \"T05\"\n\n  list(R14 = R14, R05 = R05)\n}\n\n# Small texture (noise) -------------------------------------------------\nset.seed(1001)\nnoise14_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\nset.seed(1002)\nnoise05_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\n```\n:::\n\n\n\n## 5. One-stop scenario builder (topo + LC + physics)\n\n::: callout-note\n**Why one function?** Keeps **DEM, land cover, sun rasters, and T14/T05**\nsynchronized; can optionally sprinkle **micro-hills** for structure.\n:::\n\n# Use-case scenarios (midsummer; ready-to-run recipes)\n\nBelow: short “recipes” that call your existing `build_scenario()` without refactoring. Each returns a `scen_*` object compatible with the rest of the pipeline.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_block_overview_2x2_en <- function(scen, pts_sf = NULL) {\n  stopifnot(all(c(\"E\",\"slp\",\"I14\",\"I05\") %in% names(scen)))\n\n  Rstack <- c(scen$E, scen$slp, scen$I14, scen$I05)\n  df <- terra::as.data.frame(Rstack, xy = TRUE, na.rm = FALSE)\n  names(df) <- c(\"x\",\"y\",\"elev\",\"slope\",\"I14\",\"I05\")\n\n  theme_base <- ggplot2::theme_minimal(base_size = 11)\n  pal_terrain <- grDevices::hcl.colors(256, \"Terrain\")\n  pal_slope   <- grDevices::hcl.colors(256, \"Viridis\")\n  pal_hot     <- grDevices::hcl.colors(256, \"YlOrRd\")\n  pal_cool    <- grDevices::hcl.colors(256, \"PuBuGn\")\n\n  p_elev <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = elev)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_terrain, name = \"m\") +\n    ggplot2::labs(title = \"Terrain (Elevation)\") + theme_base\n\n  p_slope <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = slope)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_slope, name = \"rad\") +\n    ggplot2::labs(title = \"Slope (radians)\") + theme_base\n\n  p_I14 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I14)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_hot, name = \"\") +\n    ggplot2::labs(title = \"Insolation 14 UTC (cos i)\") + theme_base\n\n  p_I05 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I05)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_cool, name = \"\") +\n    ggplot2::labs(title = \"Insolation 05 UTC (cos i)\") + theme_base\n\n  # Prefer land cover as the 4th panel (fallback to slope)\n  p_lc <- NULL\n  if (\"lc\" %in% names(scen)) {\n    lc_df <- terra::as.data.frame(scen$lc, xy = TRUE, na.rm = FALSE)\n    names(lc_df) <- c(\"x\",\"y\",\"lc\")\n    lc_df$lc <- factor(lc_df$lc, levels = seq_along(lc_levels), labels = lc_levels)\n    lc_cols <- scen$lc_colors %||% c(\"forest\"=\"#2E8B57\",\"water\"=\"#5DADE2\",\"bare soil\"=\"#C49A6C\",\"maize\"=\"#F4D03F\")\n    p_lc <- ggplot2::ggplot(lc_df, ggplot2::aes(x, y, fill = lc)) +\n      ggplot2::geom_raster() + ggplot2::coord_equal() +\n      ggplot2::scale_fill_manual(values = lc_cols, drop = FALSE, name = \"Land cover\") +\n      ggplot2::labs(title = \"Land cover\") + theme_base\n  }\n  p2 <- if (!is.null(p_lc)) p_lc else p_slope\n\n  (p_elev | p2) / (p_I14 | p_I05) +\n    patchwork::plot_layout(guides = \"collect\") &\n    ggplot2::theme(\n      plot.margin = ggplot2::margin(5,5,5,5),\n      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1)\n    )\n}\nbuild_scenario <- function(\n    lake_mode = c(\"none\",\"water\",\"hollow\"),\n    hill_mode = c(\"none\",\"bump\"),\n    noise14 = noise14_r,\n    noise05 = noise05_r,\n    random_hills = 0,\n    hills_xy = NULL,\n    micro_hill_diam_m = 120,\n    micro_hill_height_m = 50,\n    micro_hill_smooth = TRUE,\n    micro_seed = NULL,\n    # LC rules (interpretable dials)\n    forest_hill_thr   = 0.20,\n    forest_slope_min  = 0.15,\n    forest_north_of_y0= TRUE,\n    bare_q            = 0.90,\n    meadow_slope_max  = 0.08,\n    meadow_dist2water_m = 60,\n    meadow_valley_band_m = 60\n) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n\n  # Base valley\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0; a <- 100 / ((len_y/2)^2); elev <- 500 + a * dy^2\n\n  # Lake/hollow\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Main hill\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h_main <- if (hill_smooth) exp(-(rH <- rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h_main\n  } else w_h_main <- 0\n\n  # Optional micro hills\n  centers <- NULL\n  if (!is.null(hills_xy)) centers <- as.matrix(hills_xy[,1:2, drop = FALSE])\n  if (random_hills > 0) {\n    if (!is.null(micro_seed)) set.seed(micro_seed)\n    margin <- micro_hill_diam_m/2 + 5\n    cx <- runif(random_hills, xmin + margin, xmax - margin)\n    cy <- runif(random_hills, ymin + margin, ymax - margin)\n    centers <- rbind(centers, cbind(cx, cy))\n  }\n  w_h_micro <- rep(0, nrow(XY))\n  if (!is.null(centers) && nrow(centers) > 0) {\n    hr_m <- max(1e-6, micro_hill_diam_m/2)\n    for (i in seq_len(nrow(centers))) {\n      r  <- sqrt((XY$x - centers[i,1])^2 + (XY$y - centers[i,2])^2)\n      wi <- if (micro_hill_smooth) exp(-(r/hr_m)^2) else as.numeric(r <= hr_m)\n      w_h_micro <- w_h_micro + wi\n    }\n    w_h_micro <- pmin(1, w_h_micro)\n    elev <- elev + micro_hill_height_m * w_h_micro\n  }\n\n  # Rasters\n  E     <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW_main  <- Rtemplate; terra::values(hillW_main)  <- w_h_main;  names(hillW_main)  <- \"hillW\"\n  hillW_micro <- Rtemplate; terra::values(hillW_micro) <- w_h_micro; names(hillW_micro) <- \"hillW\"\n  hillW <- terra::clamp(hillW_main + hillW_micro, lower = 0, upper = 1); names(hillW) <- \"hillW\"\n\n  # Terrain & sun\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  # Land cover (1 forest, 2 water, 3 bare soil, 4 meadow, 5 maize)\n  lc <- Rtemplate; terra::values(lc) <- 5L\n  lc <- terra::ifel(lakeR > 0, 2L, lc)\n\n  has_water <- any(terra::values(lakeR) > 0, na.rm = TRUE)\n  d_water <- if (has_water) terra::distance(lakeR > 0) else {r <- terra::rast(E); terra::values(r) <- Inf; r}\n\n  v_slp <- terra::values(slp0)\n  thr_slp <- stats::quantile(v_slp[is.finite(v_slp)], probs = bare_q, na.rm = TRUE)\n\n  Y      <- terra::init(E, \"y\")\n  forest_mask <- (hillW > forest_hill_thr) |\n    (slp0 > forest_slope_min & (!forest_north_of_y0 | (Y > y0)))\n  bare_mask   <- (slp0 >= thr_slp)\n  meadow_mask <- (slp0 <= meadow_slope_max) &\n    ((d_water <= meadow_dist2water_m) | (abs(Y - y0) <= meadow_valley_band_m))\n\n  lc <- terra::ifel((forest_mask) & (lakeR <= 0), 1L, lc)\n  lc <- terra::ifel((bare_mask) & (lakeR <= 0) & (!forest_mask), 3L, lc)\n  lc <- terra::ifel((meadow_mask) & (lakeR <= 0) & (!forest_mask) & (!bare_mask), 4L, lc)\n\n  lc <- terra::clamp(lc, lower = 1, upper = 5); names(lc) <- \"lc\"\n\n  # Physics-based T14/T05\n  phys <- build_physics_fields(list(E=E, slp=slp0, I14=I14, I05=I05, hillW=hillW), lc, noise14, noise05)\n\n  fix_nonfinite <- function(r) {\n    v <- terra::values(r); m <- stats::median(v[is.finite(v)], na.rm = TRUE)\n    v[!is.finite(v)] <- m; terra::values(r) <- v; r\n  }\n\n  list(\n    E = fix_nonfinite(E),\n    R14 = fix_nonfinite(phys$R14),\n    R05 = fix_nonfinite(phys$R05),\n    lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05,\n    lc = lc,\n    lc_levels = lc_levels, lc_colors = lc_colors\n  )\n}\n\n# Build scenario\nscen <- build_scenario(lake_choice, hill_choice, random_hills = no_hill)\n```\n:::\n\n\n\n## a) High-roughness, patchy midsummer (**current/actual**)\n\n* **Intent:** keep the left hill, a small lake, and many micro-hills (patchy roughness).\n* **What you already have:** `lake_choice <- \"water\"`, `hill_choice <- \"bump\"`, `no_hill <- 100`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscen_patchy_midsum <- build_scenario(\n  random_hills = 100,\n  micro_hill_diam_m = 120,\n  micro_hill_height_m = 50,\n  micro_hill_smooth = TRUE,\n  micro_seed = 42,\n  lake_mode = \"water\",\n  hill_mode = \"bump\"\n)\n\nplot_block_overview_2x2_en(scen_patchy_midsum)\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/unnamed-chunk-1-1.png){width=1350}\n:::\n:::\n\n\n\n**Expected:** strong small-scale structure; RF/GAM/KED benefit most; OK may struggle if blocks are large vs feature scale; pooling reduced over hill, locally perturbed by micro-hills.\n\n---\n\n## b) Smooth “just the pipe” midsummer (no extras)\n\n* **Intent:** remove hill, remove lake, no micro-hills, and make land cover effectively uniform to isolate pipe physics.\n* **Trick:** bias the LC rules so everything becomes *meadow* (no forest/bare triggers).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscen_smooth_midsum <- build_scenario(\n  lake_mode = \"none\",\n  hill_mode = \"none\",\n  random_hills = 0,\n  # land-cover rules that suppress heterogeneity\n  forest_hill_thr = 1.0,    # never forest by hill mask\n  forest_slope_min = 1.0,   # never forest by slope\n  bare_q = 1.0,             # never bare soil\n  meadow_slope_max = 1.0,   # allow meadow everywhere by slope\n  meadow_valley_band_m = 1e6 # whole domain ok for meadow\n)\nplot_block_overview_2x2_en(scen_smooth_midsum)\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/unnamed-chunk-2-1.png){width=1350}\n:::\n:::\n\n\n\n**Expected:** very smooth fields; OK/KED shine; ML models collapse toward smooth spatial surfaces; block size can be larger without over-penalizing.\n\n---\n\n## c) Big-lake midsummer (dominant water body)\n\n* **Intent:** keep lake but make it *large*, dominating pre-dawn warmth and daytime damping.\n* **Note:** `build_scenario()` uses global `lake_diam_m`/`lake_depth_m`. Temporarily bump them, build, then restore.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save current globals\n.lake_diam_old  <- lake_diam_m\n.lake_depth_old <- lake_depth_m\n\n# make a big, shallow-to-moderate lake\nlake_diam_m  <- 1200  # meters (diameter)\nlake_depth_m <- 12\n\nscen_biglake <- build_scenario(\n  lake_mode = \"water\",\n  hill_mode = \"bump\",   # keep hill or switch to \"none\" if you want symmetry\n  random_hills = 0\n)\n\nplot_block_overview_2x2_en(scen_biglake)\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/unnamed-chunk-3-1.png){width=1350}\n:::\n\n```{.r .cell-code}\n# restore globals if desired\nlake_diam_m  <- .lake_diam_old\nlake_depth_m <- .lake_depth_old\n```\n:::\n\n\n\n**Expected:** strong LC imprint around the lake—suppressed day heating (low α) and warm pre-dawn bias (+1.2 °C). KED with LC/drifts and GAM with `lc` usually capture this best; spatial CV should use blocks ≥ L50 so near-lake stations don’t leak.\n\n\n\n## 6. Quick inspection plots (land cover, terrain, sun)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_landcover_terrain <- function(scen, stations = NULL, show_contours = TRUE,\n                                   layout = c(\"grid\",\"vertical\")) {\n  layout <- match.arg(layout)\n  stopifnot(all(c(\"E\",\"slp\") %in% names(scen)))\n\n  if (!(\"lc\" %in% names(scen))) stop(\"Scenario missing 'lc' (should not happen here).\")\n\n  lc_df  <- as.data.frame(scen$lc,  xy = TRUE); names(lc_df)  <- c(\"x\",\"y\",\"lc\")\n  E_df   <- as.data.frame(scen$E,   xy = TRUE); names(E_df)   <- c(\"x\",\"y\",\"elev\")\n  slp_df <- as.data.frame(scen$slp, xy = TRUE); names(slp_df) <- c(\"x\",\"y\",\"slp\")\n\n  lc_df$lc <- factor(lc_df$lc, levels = seq_along(lc_levels), labels = lc_levels)\n  cols_lc  <- scen$lc_colors\n\n  p_lc <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = lc_df, ggplot2::aes(x, y, fill = lc)) +\n    ggplot2::scale_fill_manual(values = cols_lc, na.value = \"grey90\", name = \"Landuse\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Landuse\", x = \"Easting\", y = \"Northing\")\n\n  p_elev <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = E_df, ggplot2::aes(x, y, fill = elev)) +\n    ggplot2::scale_fill_viridis_c(name = \"Altitude [m]\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Altitude\", x = \"Easting\", y = \"Northing\")\n\n  p_slp <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = slp_df, ggplot2::aes(x, y, fill = slp)) +\n    ggplot2::scale_fill_viridis_c(name = \"Slope [rad]\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Slope\", x = \"Easting\", y = \"Northing\")\n\n  if (isTRUE(show_contours)) {\n    lake_df <- as.data.frame(scen$lake, xy = TRUE); names(lake_df) <- c(\"x\",\"y\",\"lake\")\n    hill_df <- as.data.frame(scen$hillW, xy = TRUE); names(hill_df) <- c(\"x\",\"y\",\"hillW\")\n    p_elev <- p_elev + ggplot2::geom_contour(data = E_df, ggplot2::aes(x, y, z = elev),\n                                             bins = 10, colour = \"black\", alpha = 0.25,\n                                             linewidth = 0.2, inherit.aes = FALSE)\n    p_lc  <- p_lc  + ggplot2::geom_contour(data = lake_df, ggplot2::aes(x, y, z = lake),\n                                           breaks = 0.5, colour = \"black\", linewidth = 0.35,\n                                           inherit.aes = FALSE) +\n                     ggplot2::geom_contour(data = hill_df, ggplot2::aes(x, y, z = hillW),\n                                           breaks = 0.5, colour = \"black\", linetype = \"22\",\n                                           linewidth = 0.3, inherit.aes = FALSE)\n    p_slp <- p_slp + ggplot2::geom_contour(data = lake_df, ggplot2::aes(x, y, z = lake),\n                                           breaks = 0.5, colour = \"black\", linewidth = 0.35,\n                                           inherit.aes = FALSE) +\n                     ggplot2::geom_contour(data = hill_df, ggplot2::aes(x, y, z = hillW),\n                                           breaks = 0.5, colour = \"black\", linetype = \"22\",\n                                           linewidth = 0.3, inherit.aes = FALSE)\n  }\n\n  if (!is.null(stations)) {\n    add_st <- list(ggplot2::geom_sf(data = stations, colour = \"black\", fill = \"white\",\n                                    shape = 21, size = 1.6, stroke = 0.25, inherit.aes = FALSE))\n    p_lc   <- p_lc   + add_st\n    p_elev <- p_elev + add_st\n    p_slp  <- p_slp  + add_st\n  }\n  if (layout == \"vertical\") {\n    (p_lc / p_elev / p_slp) + patchwork::plot_layout(guides = \"keep\", heights = c(1,1,1))\n  } else {\n    (p_lc | (p_elev | p_slp)) + patchwork::plot_layout(guides = \"keep\")\n  }\n}\n\nplot_landcover_terrain(scen = scen, layout = \"vertical\")\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/plot_landcover_terrain-1.png){width=1350}\n:::\n:::\n\n\n\nA compact **2×2** overview (elevation, land cover or slope, cos(i) at\n14/05 UTC):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_block_overview_2x2_en(scen)\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/overview-1.png){width=1350}\n:::\n:::\n\n\n\n## 7. Sampling “stations” & extracting covariates\n\n::: callout-note\n**Design choice.** The same script can switch between **random** stations\nand **transects** to explore how sampling geometry affects inference and\nCV.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Station coordinates ---------------------------------------------------\nif (station_mode == \"random\") {\n  pts <- tibble::tibble(\n    id = 1:n_st,\n    x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n    y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n  )\n} else if (station_mode == \"ns_transect\") {\n  x_const <- min(max(x0 + ns_offset_m, xmin + transect_margin_m), xmax - transect_margin_m)\n  y_seq   <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_const, y = y_seq)\n} else if (station_mode == \"ew_transect\") {\n  y_const <- min(max(y0 + ew_offset_m, ymin + transect_margin_m), ymax - transect_margin_m)\n  x_seq   <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_seq, y = y_const)\n} else stop(\"Unknown station_mode\")\n\npts_sf <- sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\nvpts   <- terra::vect(pts_sf)\n\n# Extract covariates & targets -----------------------------------------\npts$z_surf <- as.numeric(terra::extract(scen$E,   vpts, ID = FALSE)[,1])\npts$slp    <- as.numeric(terra::extract(scen$slp, vpts, ID = FALSE)[,1])\npts$I14    <- as.numeric(terra::extract(scen$I14, vpts, ID = FALSE)[,1])\npts$I05    <- as.numeric(terra::extract(scen$I05, vpts, ID = FALSE)[,1])\npts$lc     <- as.integer(terra::extract(scen$lc,  vpts, ID = FALSE)[,1])\npts$T14    <- as.numeric(terra::extract(scen$R14, vpts, ID = FALSE)[,1])\npts$T05    <- as.numeric(terra::extract(scen$R05, vpts, ID = FALSE)[,1])\n\n# Keep complete rows per time slot & cast to sf -------------------------\npts14 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I14\",\"lc\",\"T14\")]), ]\npts05 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I05\",\"lc\",\"T05\")]), ]\n\nstn_sf_14 <- pts14 |>\n  dplyr::transmute(\n    id, x, y,\n    z_surf = as.numeric(z_surf),\n    slp    = as.numeric(slp),\n    cosi   = as.numeric(I14),\n    lc     = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n    temp   = as.numeric(T14)\n  ) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\nstn_sf_05 <- pts05 |>\n  dplyr::transmute(\n    id, x, y,\n    z_surf = as.numeric(z_surf),\n    slp    = as.numeric(slp),\n    cosi   = as.numeric(I05),\n    lc     = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n    temp   = as.numeric(T05)\n  ) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\n# Quick sanity table\npts |>\n  dplyr::transmute(\n    id, easting = round(x), northing = round(y),\n    z_surf = round(z_surf,1), LC = lc_levels[lc],\n    T14_C = round(T14,1), T05_C = round(T05,1)\n  ) |>\n  knitr::kable(caption = \"Station sample (sanity check)\", digits = 1)\n```\n\n::: {.cell-output-display}\n\n\nTable: Station sample (sanity check)\n\n| id| easting| northing| z_surf|LC     | T14_C| T05_C|\n|--:|-------:|--------:|------:|:------|-----:|-----:|\n|  1|  600570|  5725103|  567.1|forest |  27.3|   9.2|\n|  2|  600025|  5724819|  582.4|forest |  26.0|   9.8|\n|  3|  600521|  5724909|  563.1|forest |  27.3|   8.5|\n|  4|  599915|  5725214|  620.1|forest |  25.9|   9.2|\n|  5|  599494|  5725000|  550.0|forest |  28.0|   7.0|\n|  6|  599915|  5724825|  599.3|forest |  26.6|   8.9|\n|  7|  600692|  5725177|  573.9|forest |  27.4|   8.4|\n|  8|  599977|  5724858|  582.0|forest |  27.4|   9.2|\n|  9|  599634|  5725204|  582.9|forest |  27.8|   9.4|\n| 10|  599644|  5725186|  575.8|forest |  27.5|   9.1|\n| 11|  600062|  5724825|  554.7|maize  |  27.2|   9.3|\n| 12|  600222|  5725137|  569.8|water  |  27.0|  10.0|\n| 13|  599758|  5724978|  590.7|forest |  27.1|   7.5|\n| 14|  599350|  5724825|  579.9|forest |  28.2|   9.0|\n| 15|  599928|  5725185|  604.5|forest |  27.7|   9.1|\n| 16|  600501|  5724922|  559.9|forest |  27.6|   8.4|\n| 17|  600110|  5724913|  562.0|forest |  27.4|   8.7|\n| 18|  599783|  5724954|  567.3|forest |  27.3|   8.2|\n| 19|  600070|  5724990|  539.2|forest |  27.6|   6.9|\n| 20|  600581|  5724937|  556.5|forest |  28.2|   8.1|\n| 21|  599985|  5724984|  550.4|forest |  27.9|   7.0|\n| 22|  599514|  5724784|  606.5|forest |  26.4|   9.1|\n| 23|  600064|  5724850|  545.1|maize  |  28.2|   9.0|\n| 24|  600683|  5725232|  588.5|forest |  27.5|   8.8|\n| 25|  599724|  5724918|  563.4|forest |  28.0|   8.3|\n| 26|  600474|  5724842|  576.5|forest |  26.6|   9.3|\n| 27|  599714|  5724994|  579.9|forest |  28.0|   7.9|\n| 28|  599534|  5724769|  600.6|forest |  26.6|   9.2|\n| 29|  599332|  5724923|  559.6|forest |  27.7|   8.9|\n| 30|  599624|  5724774|  587.7|maize  |  28.3|   8.9|\n| 31|  599780|  5725176|  599.8|forest |  27.0|   9.3|\n| 32|  599495|  5725111|  569.9|forest |  27.2|   9.4|\n| 33|  599710|  5724911|  563.7|forest |  27.5|   8.6|\n| 34|  599286|  5724945|  550.6|forest |  27.6|   8.4|\n| 35|  600735|  5724920|  512.9|maize  |  29.4|   7.6|\n| 36|  600451|  5724803|  584.7|forest |  26.3|   9.5|\n| 37|  599388|  5725123|  553.7|forest |  28.4|   9.8|\n| 38|  600548|  5725049|  553.9|forest |  27.6|   7.4|\n| 39|  600081|  5724830|  550.3|maize  |  28.0|   9.0|\n| 40|  599884|  5724776|  606.3|forest |  27.9|   8.9|\n| 41|  599360|  5724992|  550.1|forest |  28.0|   6.9|\n| 42|  600091|  5724973|  551.1|forest |  27.1|   6.9|\n| 43|  599365|  5724789|  578.4|maize  |  28.8|   9.0|\n| 44|  599573|  5724917|  560.9|forest |  27.4|   8.3|\n| 45|  600073|  5725182|  588.8|forest |  26.6|   9.1|\n| 46|  599973|  5725207|  615.1|forest |  27.0|   9.5|\n| 47|  599496|  5724948|  554.2|forest |  28.0|   7.5|\n| 48|  599481|  5724836|  592.8|forest |  27.2|   9.5|\n| 49|  599999|  5724914|  562.0|forest |  27.0|   8.7|\n| 50|  600652|  5724907|  563.7|forest |  27.3|   8.8|\n| 51|  599755|  5724812|  606.9|forest |  26.9|   9.6|\n| 52|  599539|  5725230|  620.1|forest |  27.2|   8.9|\n| 53|  599659|  5724999|  551.9|forest |  28.1|   7.5|\n| 54|  600046|  5724805|  570.8|maize  |  27.1|   9.3|\n| 55|  599292|  5724862|  576.1|forest |  28.0|   8.7|\n| 56|  600442|  5725207|  589.0|forest |  27.2|   8.9|\n| 57|  599423|  5724902|  565.2|forest |  27.1|   8.5|\n| 58|  600059|  5725074|  558.6|forest |  27.2|   7.9|\n| 59|  600105|  5725193|  573.9|forest |  27.4|   8.5|\n| 60|  600176|  5725236|  589.0|forest |  27.8|   8.9|\n\n\n:::\n\n```{.r .cell-code}\n# Overlay example\nplot_block_overview_2x2_en(scen, pts_sf = stn_sf_14)\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/Station-1.png){width=1350}\n:::\n:::\n\n\n\n## 8. Models (sf-only): learners & utilities\n\n::: callout-note\n**Learners included.** Voronoi (NN), IDW, OK, KED (UK+drifts), RF, GAM.\nAll take **sf points**; no `sp` dependency.\n:::\n\nhere’s a compact, practical explainer tailored to your sandbox.\n\n# a) Interpolation models — what they are, when to use them\n\n**Voronoi / Nearest Neighbor (NN)**\n\n* **Family:** deterministic, local, piecewise-constant.\n* **How it works:** every grid cell inherits the value of the closest station.\n* **Pros:** zero tuning, lightning fast, preserves sharp local features.\n* **Cons:** blocky “salt & pepper” maps, no smoothing, no uncertainty, very sensitive to station placement.\n* **Use when:** you want a trivial baseline or to visualize station influence zones.\n\n**IDW (Inverse Distance Weighting)**\n\n* **Family:** deterministic, local averaging with distance decay.\n* **How it works:** weighted mean of neighbors, weights ∝ distance^(-p).\n* **Pros:** simple, smoothes a bit, one main knob (`p`).\n* **Cons:** no physics or covariance, biased by clustered stations, can’t represent anisotropy or barriers, no uncertainty.\n* **Use when:** quick, sane baseline where distance–decay is plausible.\n\n**OK (Ordinary Kriging)**\n\n* **Family:** geostatistical (stochastic), linear predictor using a variogram.\n* **How it works:** fits a variogram; predicts as the best linear unbiased estimator under (weak) stationarity.\n* **Pros:** principled, can provide kriging variance, handles spatial autocorrelation.\n* **Cons:** needs a decent variogram; assumes a stationary mean; can misbehave if variogram is wrong; heavier compute for many points.\n* **Use when:** field is fairly smooth with one spatial scale and little trend.\n\n**KED (Kriging with External Drift) / Universal Kriging**\n\n* **Family:** geostatistical with covariates (drifts).\n* **How it works:** combines a regression on drifts (elevation, slope, cos i, land cover) with kriging of residuals.\n* **Pros:** handles non-stationary means (terrain/land-cover effects), often best daytime; still gives uncertainty.\n* **Cons:** needs good, smooth covariates; factor alignment matters; risk of leakage if drifts are derived from the targets.\n* **Use when:** physics/covariates explain big chunks of variation (e.g., sun/terrain at 14 UTC).\n\n**RF (Random Forest)**\n\n* **Family:** machine learning, nonparametric ensemble of trees.\n* **How it works:** learns nonlinear splits using features (x, y, elevation, slope, cos i, LC).\n* **Pros:** strong with mixed, nonlinear effects and interactions; little tuning pain.\n* **Cons:** no explicit spatial correlation; can look noisy unless you include smooth spatial features; extrapolation outside feature space is weak; uncertainty is ad-hoc.\n* **Use when:** relationships are complex/nonlinear; you supply spatial features (coords + smoothed drifts).\n\n**GAM (Generalized Additive Model)**\n\n* **Family:** semi-parametric regression with smoothers.\n* **How it works:** smooth terms `s(x,y)`, `s(elev)`, `s(slope)`, `s(cos i)` (+ optional LC) fitted by penalized splines.\n* **Pros:** interpretable partial effects; captures broad smooth spatial field + nonlinear covariate effects; regularization via `k`/REML limits overfit.\n* **Cons:** assumes smoothness; choose basis size sensibly; residual spatial correlation left unmodeled unless you krige residuals (not done here).\n* **Use when:** you want a transparent model that learns smooth structure and covariate responses (often great at night with pooling proxies).\n\n> quick rule of thumb\n>\n> * Start with **IDW/OK** for baselines.\n> * Prefer **KED** when covariates are strong (daytime radiation/terrain).\n> * Try **GAM** when you expect smooth, nonlinear responses or pooling gradients.\n> * Add **RF** when interactions are messy or LC effects are patchy.\n\n---\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Small guards/utilities -------------------------------------------------\nsafe_r2 <- function(obs, pred) {\n  idx <- is.finite(obs) & is.finite(pred)\n  if (sum(idx) < 2) return(NA_real_)\n  x <- obs[idx]; y <- pred[idx]\n  sx <- stats::sd(x); sy <- stats::sd(y)\n  if (!is.finite(sx) || !is.finite(sy) || sx == 0 || sy == 0) return(NA_real_)\n  stats::cor(x, y)^2\n}\n.align_factor_to_model <- function(x, lev_model) {\n  xs <- as.character(x)\n  if (length(lev_model) == 0L) return(factor(rep(NA_character_, length(xs))))\n  y <- factor(xs, levels = lev_model)\n  if (anyNA(y)) { xs[is.na(y)] <- lev_model[1]; y <- factor(xs, levels = lev_model) }\n  y\n}\n.default_vgm <- function(values, model = \"Exp\", range = 100) {\n  psill <- stats::var(values, na.rm = TRUE); nug <- 0.1 * psill\n  gstat::vgm(psill = psill, model = model, range = range, nugget = nug)\n}\n\n# Voronoi / nearest neighbour ------------------------------------------\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf)\n  as.numeric(train_sf$temp)[idx]\n}\n\n# IDW -------------------------------------------------------------------\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  pr <- suppressWarnings(gstat::idw(temp ~ 1, locations = train_sf, newdata = test_sf, idp = idp))\n  as.numeric(pr$var1.pred)\n}\n\n# Ordinary Kriging ------------------------------------------------------\npred_OK <- function(train_sf, test_sf) {\n  vg      <- suppressWarnings(gstat::variogram(temp ~ 1, data = train_sf))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- .default_vgm(train_sf$temp)\n  pr <- suppressWarnings(gstat::krige(temp ~ 1, locations = train_sf, newdata = test_sf, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n# KED / UK with external drift -----------------------------------------\npred_KED <- function(train_sf, test_sf, ...) {\n  stopifnot(inherits(train_sf, \"sf\"), inherits(test_sf, \"sf\"))\n  need <- c(\"z_surf\",\"slp\",\"cosi\")\n  miss <- setdiff(need, names(train_sf))\n  if (length(miss)) stop(\"pred_KED(): missing drift columns in training: \", paste(miss, collapse = \", \"))\n\n  # optional LC factor aligned\n  use_lc <- \"lc\" %in% names(train_sf) && \"lc\" %in% names(test_sf)\n  tr <- train_sf; te <- test_sf\n  if (use_lc) {\n    tr$lc <- droplevels(factor(tr$lc))\n    te$lc <- factor(as.character(te$lc), levels = levels(tr$lc))\n    te$lc[is.na(te$lc)] <- levels(tr$lc)[1]\n  }\n\n  for (nm in need) { m <- stats::median(tr[[nm]][is.finite(tr[[nm]])], na.rm = TRUE); te[[nm]][!is.finite(te[[nm]])] <- m }\n\n  keep_tr <- c(\"temp\", need, if (use_lc) \"lc\")\n  dtr <- sf::st_drop_geometry(tr)[, keep_tr, drop = FALSE]\n  ok  <- stats::complete.cases(dtr)\n  tr  <- tr[ok, ]\n  if (nrow(tr) < 5) return(rep(NA_real_, nrow(te)))\n\n  form <- stats::as.formula(paste(\"temp ~\", paste(c(need, if (use_lc) \"lc\"), collapse = \" + \")))\n\n  vg      <- suppressWarnings(gstat::variogram(form, data = tr))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) {\n    ps <- stats::var(sf::st_drop_geometry(tr)$temp, na.rm = TRUE)\n    vgm_fit <- gstat::vgm(psill = ps, model = \"Exp\", range = max(vg$dist, na.rm = TRUE)/3, nugget = 0.1*ps)\n  }\n\n  pr <- suppressWarnings(gstat::krige(form, locations = tr, newdata = te, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n# Random Forest ---------------------------------------------------------\npred_RF <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf)\n  if (!(\"lc\" %in% names(dtr))) dtr$lc <- factor(\"forest\", levels = lc_levels)\n  dtr$lc <- droplevels(factor(as.character(dtr$lc), levels = lc_levels))\n  dtr <- stats::na.omit(dtr)\n  if (nrow(dtr) < 5) return(rep(NA_real_, nrow(test_sf)))\n\n  rf  <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi + lc, data = dtr, na.action = na.omit)\n\n  dte <- sf::st_drop_geometry(test_sf)\n  if (!(\"lc\" %in% names(dte))) dte$lc <- factor(\"forest\", levels = lc_levels)\n  lev <- levels(dtr$lc)\n  dte$lc <- .align_factor_to_model(dte$lc, lev)\n\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\")])\n  out  <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(rf, dte[good, ])\n  out\n}\n\n# GAM (guarded) ---------------------------------------------------------\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.kcap_unique <- function(x, kmax) {\n  ux <- unique(x[is.finite(x)])\n  nu <- length(ux)\n  if (nu <= 3) return(0L)\n  max(4L, min(kmax, nu - 1L))\n}\nsafe_gam_formula <- function(d, include_lc = FALSE) {\n  stopifnot(all(c(\"temp\",\"x\",\"y\") %in% names(d)))\n  d <- d[stats::complete.cases(d[, c(\"temp\",\"x\",\"y\")]), , drop = FALSE]\n  n    <- nrow(d)\n  n_xy <- dplyr::n_distinct(paste0(round(d$x,3), \"_\", round(d$y,3)))\n\n  base <- if (n_xy >= 4) sprintf(\"temp ~ s(x,y,bs='tp',k=%d)\", .k_for_xy(n, n_xy)) else \"temp ~ x + y\"\n\n  add <- character(0)\n  if (\"z_surf\" %in% names(d) && dplyr::n_distinct(d$z_surf) > 3)\n    add <- c(add, sprintf(\"s(z_surf,bs='tp',k=%d)\", .kcap_unique(d$z_surf, 20)))\n  if (\"slp\" %in% names(d) && dplyr::n_distinct(d$slp) > 3)\n    add <- c(add, sprintf(\"s(slp,bs='tp',k=%d)\", .kcap_unique(d$slp, 12)))\n  if (\"cosi\" %in% names(d) && dplyr::n_distinct(d$cosi) > 3)\n    add <- c(add, sprintf(\"s(cosi,bs='tp',k=%d)\", .kcap_unique(d$cosi, 12)))\n\n  if (include_lc && \"lc\" %in% names(d)) {\n    d$lc <- droplevels(factor(d$lc))\n    if (nlevels(d$lc) >= 2) add <- c(add, \"lc\")\n  }\n\n  as.formula(paste(base, paste(add, collapse = \" + \"), sep = if (length(add)) \" + \" else \"\"))\n}\npred_GAM <- function(train_sf, test_sf) {\n  dtr  <- sf::st_drop_geometry(train_sf)\n  keep <- intersect(c(\"temp\",\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\"), names(dtr))\n  dtr  <- dtr[stats::complete.cases(dtr[, keep, drop = FALSE]), keep, drop = FALSE]\n  if (!nrow(dtr)) return(rep(NA_real_, nrow(test_sf)))\n  if (\"lc\" %in% names(dtr)) dtr$lc <- droplevels(factor(dtr$lc))\n  inc_lc <- \"lc\" %in% names(dtr) && nlevels(dtr$lc) >= 2\n  if (nrow(dtr) < 10) return(rep(NA_real_, nrow(test_sf)))\n  gm <- mgcv::gam(formula = safe_gam_formula(dtr, include_lc = inc_lc), data = dtr, method = \"REML\", select = TRUE)\n\n  dte <- sf::st_drop_geometry(test_sf)\n  vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (inc_lc) \"lc\"); vars <- intersect(vars, names(dte))\n  if (inc_lc) {\n    lev <- levels(model.frame(gm)$lc)\n    if (!(\"lc\" %in% names(dte))) dte$lc <- lev[1]\n    dte$lc <- .align_factor_to_model(dte$lc, lev)\n  }\n  good <- stats::complete.cases(dte[, vars, drop = FALSE])\n  out  <- rep(NA_real_, nrow(dte))\n  if (any(good)) out[good] <- stats::predict(gm, dte[good, vars, drop = FALSE], type = \"response\")\n  out\n}\n```\n:::\n\n\n\n## 9. Predicting full maps + baseline panels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full-grid prediction (1 cell = 1 row) --------------------------------\npredict_maps <- function(stn_sf, truth_raster,\n                         which_time = c(\"T14\",\"T05\"),\n                         scen, models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\"),\n                         lc_levels = NULL,\n                         feature_rasters = NULL) {\n  which_time <- match.arg(which_time)\n  lc_levels  <- lc_levels %||% scen$lc_levels\n\n  E      <- feature_rasters$E   %||% scen$E\n  slp_r  <- feature_rasters$slp %||% scen$slp\n  cosi_r <- feature_rasters$cosi%||% if (which_time == \"T14\") scen$I14 else scen$I05\n  has_lc <- (\"lc\" %in% names(scen)) && !is.null(scen$lc)\n  lc_r   <- if (has_lc) scen$lc else NULL\n\n  train_sf <- stn_sf\n  if (!all(c(\"x\",\"y\") %in% names(train_sf))) { xy <- sf::st_coordinates(train_sf); train_sf$x <- xy[,1]; train_sf$y <- xy[,2] }\n  if (!(\"z_surf\" %in% names(train_sf))) train_sf$z_surf <- as.numeric(terra::extract(E,      sf::st_coordinates(train_sf))[,1])\n  if (!(\"slp\" %in% names(train_sf)))    train_sf$slp    <- as.numeric(terra::extract(slp_r,  sf::st_coordinates(train_sf))[,1])\n  if (!(\"cosi\" %in% names(train_sf)))   train_sf$cosi   <- as.numeric(terra::extract(cosi_r, sf::st_coordinates(train_sf))[,1])\n  if (has_lc && !(\"lc\" %in% names(train_sf))) {\n    lc_codes <- as.integer(terra::extract(lc_r, sf::st_coordinates(train_sf))[,1]); lc_codes[is.na(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    train_sf$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n\n  xy <- as.data.frame(terra::xyFromCell(E, 1:terra::ncell(E))); names(xy) <- c(\"x\",\"y\")\n  grid_df <- xy\n  grid_df$z_surf <- as.numeric(terra::values(E))\n  grid_df$slp    <- as.numeric(terra::values(slp_r))\n  grid_df$cosi   <- as.numeric(terra::values(cosi_r))\n  if (has_lc) {\n    lc_codes <- as.integer(terra::values(lc_r)); lc_codes[!is.finite(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    grid_df$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\",\"y\"), crs = sf::st_crs(train_sf), remove = FALSE)\n\n  use_lc <- has_lc && (\"lc\" %in% names(train_sf)) && (\"lc\" %in% names(grid_sf))\n  if (use_lc) {\n    lev <- levels(droplevels(factor(train_sf$lc)))\n    train_sf$lc <- factor(as.character(train_sf$lc), levels = lev)\n    grid_sf$lc  <- factor(as.character(grid_sf$lc),  levels = lev)\n    if (anyNA(train_sf$lc) || anyNA(grid_sf$lc)) { use_lc <- FALSE; train_sf$lc <- NULL; grid_sf$lc <- NULL }\n  }\n\n  pred_list <- list()\n  if (\"Voronoi\" %in% models) pred_list$Voronoi <- pred_Voronoi(train_sf, grid_sf)\n  if (\"IDW\"     %in% models) pred_list$IDW     <- pred_IDW    (train_sf, grid_sf, idp = 2)\n  if (\"OK\"      %in% models) pred_list$OK      <- pred_OK     (train_sf, grid_sf)\n  if (\"KED\"     %in% models) pred_list$KED     <- pred_KED    (train_sf, grid_sf)\n\n  if (\"RF\" %in% models) {\n    dtr <- sf::st_drop_geometry(train_sf)\n    rf_vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (use_lc) \"lc\")\n    dtr <- stats::na.omit(dtr[, c(\"temp\", rf_vars), drop = FALSE])\n    pred_list$RF <- if (nrow(dtr) >= 5) {\n      rf <- randomForest::randomForest(stats::as.formula(paste(\"temp ~\", paste(rf_vars, collapse = \" + \"))), data = dtr, na.action = na.omit)\n      as.numeric(stats::predict(rf, sf::st_drop_geometry(grid_sf)[, rf_vars, drop = FALSE]))\n    } else rep(NA_real_, nrow(grid_sf))\n  }\n\n  if (\"GAM\" %in% models) {\n    dtr <- sf::st_drop_geometry(train_sf)\n    keep <- c(\"temp\",\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (use_lc) \"lc\")\n    dtr  <- dtr[stats::complete.cases(dtr[, keep, drop = FALSE]), keep, drop = FALSE]\n    if (nrow(dtr) >= 10) {\n      form <- safe_gam_formula(dtr, include_lc = use_lc)\n      gm   <- mgcv::gam(form, data = dtr, method = \"REML\", select = TRUE)\n      vars_needed <- setdiff(all.vars(formula(gm)), \"temp\")\n      nd <- sf::st_drop_geometry(grid_sf)[, vars_needed, drop = FALSE]\n      mf <- try(model.frame(gm), silent = TRUE)\n      if (!inherits(mf, \"try-error\")) {\n        for (vn in vars_needed) if (is.factor(mf[[vn]])) {\n          nd[[vn]] <- factor(as.character(nd[[vn]]), levels = levels(mf[[vn]]))\n          na_idx <- is.na(nd[[vn]]); if (any(na_idx)) nd[[vn]][na_idx] <- levels(mf[[vn]])[1L]\n        }\n      }\n      good <- stats::complete.cases(nd)\n      tmp  <- rep(NA_real_, nrow(grid_sf))\n      if (any(good)) tmp[good] <- stats::predict(gm, nd[good, , drop = FALSE], type = \"response\")\n      pred_list$GAM <- tmp\n    } else pred_list$GAM <- rep(NA_real_, nrow(grid_sf))\n  }\n\n  make_r <- function(vals, template = E) { r <- terra::rast(template); terra::values(r) <- as.numeric(vals); r }\n  pred_rasters <- lapply(pred_list, make_r)\n\n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE)\n  names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  lims <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n\n  pred_df <- dplyr::bind_rows(lapply(names(pred_list), function(nm) {\n    tibble::tibble(model = nm, x = grid_df$x, y = grid_df$y, pred = pred_list[[nm]])\n  }))\n\n  p_pred <- ggplot2::ggplot(pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time), x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3)\n\n  p_truth <- ggplot2::ggplot(truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims, oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time), x = \"Easting\", y = \"Northing\")\n\n  list(pred_df = pred_df, pred_rasters = pred_rasters, p_pred = p_pred, p_truth = p_truth)\n}\n```\n:::\n\n\n\n## 10. Blocked CV (leave-block-out) & diagnostics\n\n# b) Leave-Block-Out (LBO) CV & the metrics (densities, MAE, RMSE)\n\n**Why LBO?**\nPlain LOOCV is over-optimistic in spatial data: training points often sit meters from the test point, so you “peek” at near-duplicates. **LBO** fixes this by **holding out entire spatial blocks** at once, forcing the model to predict **into areas with no nearby training data** — a better proxy for real mapping.\n\n**How your LBO works (in the script):**\n\n1. **Tessellate** the domain into square blocks (e.g., 100 m).\n2. **For each block** `b`: train on all stations *outside* `b`, predict *inside* `b`.\n3. **Collect residuals** per test point and aggregate across blocks and models.\n4. Plot: observed vs predicted, **per-block** boxplots, and **residual densities**.\n\n**Choosing block size:**\n\n* Aim for the **process scale** so neighbors just outside the block don’t leak strong information.\n* You already estimate a scale via the variogram (L50/L95) and tune a drift radius **R\\***. As a heuristic:\n\n  * `block_size` ≈ **L50–L95**, or at least comparable to **R\\***.\n  * Too small → leakage (optimistic). Too big → few folds (high variance).\n\n**The metrics you derive and how to read them**\n\n* **Residual = Pred − Obs** (per hold-out point).\n\n  * *Map/overlay residuals*: spatial patterns ⇒ missing drift/physics or anisotropy.\n\n* **MAE (Mean Absolute Error)**\n\n  * *“Typical absolute miss”*. Robust to outliers, easy to interpret in °C.\n  * Compare medians across models (your per-block boxplots do this well).\n\n* **RMSE (Root Mean Squared Error)**\n\n  * Penalizes large errors more than MAE (sensitive to outliers and regime failures).\n  * Good when big mistakes are costly; expect RMSE ≥ MAE.\n\n* **Bias (mean residual)**\n\n  * Sign shows systematic over/under-prediction. Close to 0 is ideal; non-zero bias suggests missing trend or mis-scaled drift.\n\n* **R² (on held-out)**\n\n  * Squared correlation of Obs vs Pred. Summarizes alignment, but can hide bias and scale errors. Use alongside MAE/RMSE.\n\n* **Residual density plots (per model)**\n\n  * Narrow, centered at 0 ⇒ well-calibrated.\n  * **Skewed** ⇒ systematic bias in certain regimes.\n  * **Heavy tails** ⇒ occasional large misses (often in blocks with unusual LC/terrain).\n  * **Multimodal** ⇒ unmodeled regimes (e.g., lake vs forest nights).\n\n**How to act on what you see**\n\n* **High bias** → add or rescale drifts (elev lapse, cos i, pooling proxy), or move from OK → KED/GAM.\n* **High RMSE but OK MAE** → a few bad regimes; inspect residual maps for where/when; consider **R\\*** tuning (you already do) or LC refinements.\n* **Wide spread across blocks** → model unstable spatially; increase block size a bit, smooth features (your `R*`), or prefer models with smooth `s(x,y)` (GAM) or residual kriging after a drift.\n* **RF noisy surfaces** → include `s(x,y)` via GAM or add smoothed predictors, or post-smooth RF predictions (with care).\n\n**Good practice with LBO**\n\n* Ensure **each block has test points**; merge sparse blocks or jitter borders.\n* Compare models **paired by block** (your per-block boxplots do this).\n* Try a couple of **block sizes** around your inferred range (e.g., 0.7× and 1.3×).\n* Report **median and IQR** of per-block MAE/RMSE; don’t rely on a single overall mean.\n\n---\n\n### Tiny “which model when” cheat\n\n* **T14 (day, strong radiation/terrain):** KED or GAM with `cos i`, slope, elevation; OK is fine if trend small.\n* **T05 (pre-dawn pooling):** GAM with smooth `s(x,y)` and slope/pooling proxy; KED helps if pooling covariate captures valley axis/hill blockage; OK often underfits pooling troughs.\n* **Patchy LC and roughness:** RF or GAM+LC; stabilize with smoothed covariates or a small `s(x,y)` term.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make blocks and assign stations -------------------------------------\nmake_blocks_and_assign <- function(pts_sf, E, block_size = 100) {\n  bb <- sf::st_as_sfc(sf::st_bbox(c(xmin = terra::xmin(E), ymin = terra::ymin(E), xmax = terra::xmax(E), ymax = terra::ymax(E)), crs = sf::st_crs(pts_sf)))\n  gr <- sf::st_make_grid(bb, cellsize = c(block_size, block_size), what = \"polygons\")\n  blocks <- sf::st_sf(block_id = seq_along(gr), geometry = gr)\n  pts_blk <- sf::st_join(pts_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (any(is.na(pts_blk$block_id))) {\n    nearest <- sf::st_nearest_feature(pts_blk[is.na(pts_blk$block_id), ], blocks)\n    pts_blk$block_id[is.na(pts_blk$block_id)] <- blocks$block_id[nearest]\n  }\n  list(blocks = blocks, pts = pts_blk)\n}\n.discrete_cols <- function(n) scales::hue_pal()(n)\nplot_blocks_grid <- function(blocks, pts_blk, title = \"Blocks & stations\") {\n  crs_plot <- sf::st_crs(pts_blk)\n  bb       <- sf::st_bbox(blocks)\n  n_blocks <- dplyr::n_distinct(pts_blk$block_id)\n  cols     <- .discrete_cols(max(1, n_blocks))\n  ggplot2::ggplot() +\n    ggplot2::geom_sf(data = blocks, fill = NA, color = \"grey50\", linewidth = 0.25) +\n    ggplot2::geom_sf(data = pts_blk, ggplot2::aes(color = factor(block_id)), size = 2, alpha = 0.95) +\n    ggplot2::scale_color_manual(values = cols, name = \"Block\") +\n    ggplot2::coord_sf(crs = crs_plot, datum = NA,\n                      xlim = c(bb[\"xmin\"], bb[\"xmax\"]), ylim = c(bb[\"ymin\"], bb[\"ymax\"]), expand = FALSE) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = title, x = \"Easting (m)\", y = \"Northing (m)\")\n}\n\n# CV orchestrator -------------------------------------------------------\nrun_lbo_cv <- function(stn_sf, E, block_size = 100, models = models_use) {\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) { xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2] }\n  blk <- make_blocks_and_assign(stn_sf, E, block_size = block_size)\n  blocks_sf <- blk$blocks; stn_blk <- blk$pts\n  restore <- function(nm) if (!(nm %in% names(stn_blk))) stn_blk[[nm]] <<- stn_sf[[nm]][match(stn_blk$id, stn_sf$id)]\n  for (nm in c(\"temp\",\"z_surf\",\"slp\",\"cosi\",\"lc\",\"x\",\"y\")) restore(nm)\n\n  block_ids <- sort(unique(stn_blk$block_id))\n  out_list <- vector(\"list\", length(block_ids))\n  for (k in seq_along(block_ids)) {\n    b <- block_ids[k]\n    test_idx  <- which(stn_blk$block_id == b)\n    train_idx <- which(stn_blk$block_id != b)\n    train_sf <- stn_blk[train_idx, ]; test_sf <- stn_blk[test_idx, ]\n    pred_tbl <- lapply(models, function(m) {\n      p <- switch(m,\n        \"Voronoi\" = pred_Voronoi(train_sf, test_sf),\n        \"IDW\"     = pred_IDW(train_sf, test_sf),\n        \"OK\"      = pred_OK(train_sf, test_sf),\n        \"KED\"     = pred_KED(train_sf, test_sf, E = E),\n        \"RF\"      = pred_RF(train_sf, test_sf),\n        \"GAM\"     = pred_GAM(train_sf, test_sf),\n        stop(\"Unknown model: \", m)\n      )\n      tibble::tibble(model = m, id = test_sf$id, obs = test_sf$temp, pred = p, block_id = b)\n    })\n    out_list[[k]] <- dplyr::bind_rows(pred_tbl)\n  }\n\n  cv_tbl <- dplyr::bind_rows(out_list)\n  metrics <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(\n      n    = dplyr::n(),\n      n_ok = sum(is.finite(obs) & is.finite(pred)),\n      MAE  = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(abs(pred[i]-obs[i])) else NA_real_},\n      RMSE = {i <- is.finite(obs) & is.finite(pred); if (any(i)) sqrt(mean((pred[i]-obs[i])^2)) else NA_real_},\n      Bias = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(pred[i]-obs[i]) else NA_real_},\n      R2   = safe_r2(obs, pred),\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n\n  diag_plot <- ggplot2::ggplot(cv_tbl, ggplot2::aes(obs, pred)) +\n    ggplot2::geom_abline(slope=1, intercept=0, linetype=\"dashed\") +\n    ggplot2::geom_point(alpha=0.7) +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"LBO-CV (block = %dm) — Observed vs Predicted\", block_size), x = \"Observed\", y = \"Predicted\") +\n    ggplot2::facet_wrap(~ model)\n\n  blocks_plot <- plot_blocks_grid(blocks_sf, stn_blk, title = sprintf(\"Blocks (%.0f m) & stations\", block_size))\n  list(cv = cv_tbl, metrics = metrics, diag_plot = diag_plot, blocks_plot = blocks_plot)\n}\n```\n:::\n\n\n\n**Run baseline CV & maps**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.as_rast_like <- function(x, template) {\n  if (inherits(x, \"SpatRaster\")) return(x)\n  if (inherits(x, \"Raster\"))     return(terra::rast(x))\n  if (is.matrix(x))              return(terra::rast(x, ext = terra::ext(template), crs = terra::crs(template)))\n  stop(\"Unbekannter Typ für Raster-Koerzierung: \", paste(class(x), collapse = \", \"))\n}\nblock_metrics_long <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"block_id\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  cv_tbl |>\n    dplyr::group_by(model, block_id) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\") |>\n    tidyr::pivot_longer(c(RMSE, MAE), names_to = \"Metric\", values_to = \"Value\")\n}\norder_models_by_median_rmse <- function(cv_tbl) {\n  bm <- block_metrics_long(cv_tbl)\n  bm |>\n    dplyr::filter(Metric == \"RMSE\") |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(Value, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n}\nmake_block_metric_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  bm <- block_metrics_long(cv_tbl) |> dplyr::filter(is.finite(Value))\n  ymax <- if (!is.null(tail_cap)) stats::quantile(bm$Value, tail_cap, na.rm = TRUE)\n  lev <- order_models_by_median_rmse(cv_tbl)\n  bm$model <- factor(bm$model, levels = lev)\n  ggplot2::ggplot(bm, ggplot2::aes(model, Value)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.35, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Block-wise errors (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"Error\") +\n    ggplot2::facet_wrap(~ Metric, scales = \"free_y\")\n}\nmake_abs_error_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  df <- cv_tbl |> dplyr::mutate(abs_err = abs(pred - obs)) |> dplyr::filter(is.finite(abs_err))\n  ymax <- if (!is.null(tail_cap)) stats::quantile(df$abs_err, tail_cap, na.rm = TRUE) else max(df$abs_err, na.rm = TRUE)\n  lev <- df |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(abs_err, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n  df$model <- factor(df$model, levels = lev)\n  ggplot2::ggplot(df, ggplot2::aes(model, abs_err)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.3, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Absolute errors per station (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"|pred − obs|\")\n}\n.make_labeller <- function(cv_tbl) {\n  m <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)),\n                     MAE  = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\")\n  setNames(sprintf(\"%s  (RMSE=%.2f · MAE=%.2f)\", m$model, m$RMSE, m$MAE), m$model)\n}\nmake_obs_pred_scatter <- function(cv_tbl, which_time = \"T14\") {\n  lab <- .make_labeller(cv_tbl)\n  ggplot2::ggplot(cv_tbl, ggplot2::aes(obs, pred)) +\n    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    ggplot2::geom_point(alpha = 0.7, shape = 16) +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Observed vs Predicted (LBO-CV)\", which_time),\n                  x = \"Observed\", y = \"Predicted\") +\n    ggplot2::facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n}\nmake_residual_density <- function(cv_tbl, which_time = \"T14\") {\n  cv_tbl |> dplyr::mutate(resid = pred - obs) |>\n    ggplot2::ggplot(ggplot2::aes(resid, fill = model)) +\n    ggplot2::geom_density(alpha = 0.4) + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Residual density\", which_time),\n                  x = \"Residual (°C)\", y = \"Density\")\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T14 ...\")\nout14 <- quiet(run_for_time(stn_sf_14, scen$R14, \"T14\", layout = \"horizontal\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T05 ...\")\nout05 <- quiet(run_for_time(stn_sf_05, scen$R05, \"T05\", layout = \"horizontal\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nout14$res$blocks_plot; out14$res$diag_plot\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-1.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-2.png){width=1350}\n:::\n\n```{.r .cell-code}\nout05$res$blocks_plot; out05$res$diag_plot\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-3.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-4.png){width=1350}\n:::\n\n```{.r .cell-code}\nout14$panel\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-5.png){width=1350}\n:::\n\n```{.r .cell-code}\nout05$panel\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/baseline_cv-6.png){width=1350}\n:::\n:::\n\n\n\n\n\n\n## 11. Variogram scales (L50/L95) & **R\\*** tuning\n\n::: callout-tip\n**Concept.** Infer process scale from the **empirical variogram** (L50,\nL95), then scan a **Gaussian smoothing radius R** around that range.\nPick the **R\\*** that minimizes **blocked-CV RMSE** (a “U-curve”).\n:::\n\n# Scale error budget & the smoothing strategy (what’s going on in “the second half”)\n\nBelow is a plain-English tour of what the latter half of your script is doing (Sections 11–12): how it decomposes error by **scale**, how it **infers a physical length scale** from the data, and how it **tunes smoothing** to hit the sweet spot for prediction while keeping the cross-validation honest.\n\n---\n\n## 1) What “scale error budget” means here\n\nYour synthetic valley has structure at multiple spatial scales:\n\n* **Sub-grid/micro**: roughness from micro-hills, edges of land-cover patches (tens of meters).\n* **Meso**: the valley “half-pipe,” hill/pond footprints, pooling trough (hundreds of meters).\n* **Macro**: very broad trends across the domain (kilometers).\n\nInterpolation models do best when their **predictor features** (elevation, slope, cos (i)) are filtered to the **same scale** as the temperature field you’re trying to predict. If features are too rough (high-frequency), they inject noise; if they’re too smooth (low-pass too strong), they erase true meso-scale signals.\n\nThink of your total error as:\n\n$$\n\\text{RMSE}^2 \\;=\\; \\underbrace{\\text{Bias}^2}_{\\text{systematic}} \\;+\\; \\underbrace{\\text{Var}}_{\\text{random}} \\;+\\; \\underbrace{\\sigma_\\text{irreducible}^2}_{\\text{process/measurement noise}}\n$$\n\n* **Under-smoothing** → low bias, **high variance** (fits the bumps, generalizes poorly).\n* **Over-smoothing** → **high bias**, low variance (misses real structure, looks stable but wrong).\n* There’s an **R**\\* that minimizes RMSE by trading bias vs variance.\n\n---\n\n## 2) Inferring the process scale from the variogram (L50 / L95)\n\nYou compute an **empirical variogram** of station temperatures and extract two reference scales:\n\n* **L50**: the distance where the semivariance reaches \\~50% of the sill → a robust proxy for the **correlation length** (the “typical” range of coherent structure).\n* **L95**: where it reaches \\~95% of the sill → an upper bound for **most** of the spatial dependence.\n\nIntuition:\n\n* Below **L50**, points tend to “see” similar values (strong correlation).\n* Beyond **L95**, they’re largely uncorrelated.\n\nThese two numbers define the **candidate window** for smoothing.\n\n---\n\n## 3) Why blocked CV matters (and how it ties to scale)\n\nPlain leave-one-out leaks nearby information: neighbors inside the correlation length make the validation artificially rosy.\nYou use **Leave-Block-Out (LBO)**: hold out **entire spatial blocks** so the training data near the test points are removed within a block radius.\n\nRule of thumb the code follows:\n\n* Set **block size ≈ L50 (or larger)** so correlations across the train/test boundary are **weak**.\n* If blocks are **too small** relative to correlation length → optimistic CV (leakage).\n* If **too big** → pessimistic CV (very little training data left), but honest.\n\n---\n\n## 4) Smoothing strategy: predictor-side Gaussian low-pass\n\nYou **do not smooth the target** (temperature). You smooth the **DEM** and re-derive **slope** and **cos (i)** from the smoothed DEM:\n\n1. Build a Gaussian kernel with **radius R** meters (σ ≈ R/2).\n2. Convolve DEM → **E\\_s**.\n3. Recompute **slope\\_s**, **aspect\\_s**, then **cos (i)\\_s** from (E\\_s, slope\\_s, aspect\\_s).\n4. Extract these smoothed features at station locations and for the grid.\n5. Fit models (KED/GAM/RF/OK/IDW/Voronoi) using the **smoothed** features.\n\nWhy this is safe:\n\n* DEM + solar geometry are **exogenous** (not the target), so smoothing them **doesn’t leak** information from held-out blocks.\n\nWhat R does:\n\n* **Small R** keeps micro-roughness → higher variance in models (esp. RF/GAM).\n* **Large R** wipes meso-scale signal (e.g., shading gradients, pooling proxies) → bias.\n\n---\n\n## 5) Picking R\\* with a U-curve\n\nYou scan **R** in $[0.8\\,L50,\\,1.2\\,L95]$ and compute **blocked-CV RMSE** for each R.\nPlot RMSE vs R → a **U-shaped** curve. The minimum is **R**\\*:\n\n* **Left limb (small R)**: noisy predictors → unstable fits → larger RMSE.\n* **Bottom**: best bias/variance trade-off → **R**\\*.\n* **Right limb (large R)**: over-smoothed predictors can’t explain real structure → bias ↑ → RMSE ↑.\n\nOften:\n\n* **T14 (day)** prefers a **smaller R**\\* (radiation/shading vary faster).\n* **T05 (pre-dawn)** prefers a **larger R**\\* (pooling is broad-scale).\n\n---\n\n## 6) How this interacts with each interpolation family\n\n* **Voronoi / IDW**: no explicit drift. Smoothing features doesn’t change them; they set a **baseline** (often higher RMSE). Useful as a “no-covariate” reference.\n* **OK**: learns covariation implicitly; sensitive to variogram fit. If features aren’t used (OK), scale tuning matters via **block size** more than via R.\n* **KED (UK+drifts)**: **directly benefits** from well-scaled drifts (E\\_s, slope\\_s, cos (i)\\_s). Too small R → overfit to rough slopes; too big R → miss terrain-radiation contrasts.\n* **GAM**: flexible but can overfit rough predictors; smoothed covariates stabilize the spline terms and improve extrapolation into held-out blocks.\n* **RF**: loves signal, also loves noise. Smoothed features reduce spurious splits on micro-bumps.\n\nNet effect: after tuning **R**\\*, you should see **lower block-wise RMSE/MAE**, tighter **obs-vs-pred** clouds, and **narrower residual densities**.\n\n---\n\n## 7) Interpreting the diagnostics you produce\n\n* **Variogram with L50/L95**: sanity check the dominant scale. Flat variogram → weak spatial signal or too-noisy target.\n* **U-curve**: if it’s flat → either (a) features aren’t informative, (b) station network too sparse to resolve the range, or (c) block size too large/small.\n* **Block-wise RMSE/MAE boxplots**: look for reduced median **and** tighter IQR after tuning. If not, your R window might miss the true scale, or the physics is dominated by a driver you didn’t encode (e.g., land-cover effect too strong or mis-parametrized).\n* **Residual density**: should tighten around 0; multi-modal shapes suggest un-modelled regimes (e.g., water vs bare soil behaving differently).\n* **Maps (truth vs predictions)**: over-smoothing shows as washed-out shadows/contrasts; under-smoothing shows speckle and block-edge artifacts.\n\n---\n\n## 8) Practical recipe (TL;DR)\n\n1. **Compute** L50/L95 from station temps (per time slice).\n2. **Set block size** ≳ L50 for LBO-CV.\n3. **Scan R** in $[0.8\\,L50,\\,1.2\\,L95]$ (6–8 values is fine).\n4. **Pick R**\\* at the RMSE minimum.\n5. **Rebuild features** at R\\* (E\\_s, slope\\_s, cos (i)\\_s) and **re-run CV**.\n6. **Compare** base vs tuned panels: metrics, densities, scatter, and maps.\n7. If U-curve is flat or noisy, **revisit**: block size, station geometry, variogram cutoff, or land-cover physics.\n\n---\n\n## 9) Common pitfalls & fixes\n\n* **Leakage** (blocks too small): CV looks great, deployment doesn’t. Increase block size toward L50–L95.\n* **Anisotropy** (valley-parallel vs cross-valley): a single R may be sub-optimal. Consider anisotropic kernels or separate predictors (e.g., along/ across-valley smoothing).\n* **Non-stationarity** (lake/hill zones behave differently): allow **LC-aware drifts** (you already do via KED/GAM with `lc`) and keep those classes aligned between train/test.\n* **Sparse sampling**: if median inter-station spacing ≳ L50, variogram is unstable; widen R grid and prefer simpler models (KED with fewer drifts, or OK with robust variogram).\n* **Overly strong LC physics**: if LC dominates, consider **class-specific** R (advanced) or temper the LC coefficients so topography still contributes.\n\n---\n\n## 10) Why this works well in your sandbox\n\nBecause you control the “truth,” the variogram reflects the **actual micro/meso scales** baked into the physics (radiation, lapse/inversion, pooling). The tuned **R**\\* rediscovering those scales is a strong check that:\n\n* The **features** (E, slope, cos (i)) are the right **explanatory channels**, and\n* Your **CV design** respects spatial dependence (so reported gains are meaningful).\n\nThat’s the whole idea: match the **feature scale** to the **process scale** under **honest CV**, and the models fall into place.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Variogram-based scale inference --------------------------------------\ncompute_Ls_from_points <- function(stn_sf, value_col = \"temp\", maxdist = NULL, nlag = 18, smooth_k = 3) {\n  stopifnot(inherits(stn_sf, \"sf\"), value_col %in% names(stn_sf))\n  pts <- stn_sf[is.finite(stn_sf[[value_col]]), ]\n  if (is.null(maxdist)) {\n    bb <- sf::st_bbox(pts)\n    dom_diag <- sqrt((bb[\"xmax\"]-bb[\"xmin\"])^2 + (bb[\"ymax\"]-bb[\"ymin\"])^2)\n    maxdist <- dom_diag / 2\n  }\n  form <- stats::as.formula(sprintf(\"%s ~ 1\", value_col))\n  vg  <- gstat::variogram(form, data = pts, cutoff = maxdist, width = maxdist/nlag)\n  if (nrow(vg) >= smooth_k) {\n    vg$gamma <- stats::filter(vg$gamma, rep(1/smooth_k, smooth_k), sides = 2)\n    vg$gamma[!is.finite(vg$gamma)] <- zoo::na.approx(vg$gamma, na.rm = FALSE)\n    vg$gamma <- zoo::na.locf(zoo::na.locf(vg$gamma, fromLast = TRUE))\n  }\n  sill <- max(vg$gamma, na.rm = TRUE)\n  if (!is.finite(sill) || sill <= 0) sill <- stats::median(vg$gamma, na.rm = TRUE)\n\n  L_at_q <- function(q) {\n    thr <- q * sill; i <- which(vg$gamma >= thr)[1]\n    if (is.na(i)) return(NA_real_)\n    if (i == 1) return(vg$dist[1])\n    d0 <- vg$dist[i-1]; d1 <- vg$dist[i]; g0 <- vg$gamma[i-1]; g1 <- vg$gamma[i]\n    if (!is.finite(d0) || !is.finite(d1) || g1 == g0) return(d1)\n    d0 + (thr - g0) * (d1 - d0) / (g1 - g0)\n  }\n  list(vg = vg, sill = sill, L50 = L_at_q(0.5), L95 = L_at_q(0.95), cutoff = maxdist)\n}\n\nplot_variogram_with_scales <- function(vg, L50, L95, sill, title = \"Empirical variogram\") {\n  df <- as.data.frame(vg)\n  ggplot2::ggplot(df, ggplot2::aes(dist, gamma)) +\n    ggplot2::geom_point(size = 1.4) +\n    ggplot2::geom_line(alpha = 0.5) +\n    ggplot2::geom_hline(yintercept = sill, linetype = \"dotted\", linewidth = 0.4) +\n    ggplot2::geom_vline(xintercept = L50, colour = \"#2b8cbe\", linetype = \"dashed\") +\n    ggplot2::geom_vline(xintercept = L95, colour = \"#de2d26\", linetype = \"dashed\") +\n    ggplot2::annotate(\"text\", x = L50, y = 0, vjust = -0.5, label = sprintf(\"L50 = %.0f m\", L50)) +\n    ggplot2::annotate(\"text\", x = L95, y = 0, vjust = -0.5, label = sprintf(\"L95 = %.0f m\", L95), colour = \"#de2d26\") +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = title, x = \"Distance (m)\", y = \"Semivariance\")\n}\n\n# Gaussian DEM smoothing + derived predictors --------------------------\ngaussian_focal <- function(r, radius_m, sigma_m = NULL) {\n  resx <- terra::res(r)[1]\n  if (is.null(sigma_m)) sigma_m <- radius_m / 2\n  rad_px   <- max(1L, round(radius_m / resx))\n  sigma_px <- max(0.5, sigma_m / resx)\n  xs <- -rad_px:rad_px\n  k1 <- exp(-0.5 * (xs / sigma_px)^2); k1 <- k1 / sum(k1)\n  K  <- outer(k1, k1); K / sum(K)\n}\nsmooth_dem_and_derive <- function(E, alt, az, radius_m) {\n  K   <- gaussian_focal(E, radius_m)\n  Es  <- terra::focal(E, w = K, fun = mean, na.policy = \"omit\", pad = TRUE)\n  slp <- terra::terrain(Es, v = \"slope\",  unit = \"radians\")\n  asp <- terra::terrain(Es, v = \"aspect\", unit = \"radians\")\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp)*cos(zen) + sin(slp)*sin(zen)*cos(az - asp)\n  ci  <- terra::ifel(ci < 0, 0, ci)\n  list(Es = Es, slp = slp, cosi = ci)\n}\n\n# CV of GAM with R-smoothed predictors ---------------------------------\n.extract_to_pts <- function(r, pts_sf) {\n  out <- try(terra::extract(r, terra::vect(pts_sf), ID = FALSE)[,1], silent = TRUE)\n  if (inherits(out, \"try-error\") || length(out) == 0L) rep(NA_real_, nrow(pts_sf)) else out\n}\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.kcap_unique <- function(x, kmax) {\n  ux <- unique(x[is.finite(x)]); nu <- length(ux); if (nu <= 3) return(0L)\n  max(4L, min(kmax, nu - 1L))\n}\nsmooth_mean_R <- function(r, R_m) {\n  px <- mean(terra::res(r)); half <- max(1L, ceiling(R_m / px)); k <- 2L * half + 1L\n  W <- matrix(1, nrow = k, ncol = k); W / sum(W)\n}\ncv_gam_with_R <- function(stn_sf, E, alt = NULL, az = NULL, R, block_size_m = NULL) {\n  bs <- suppressWarnings(as.numeric(block_size_m)[1]); if (!is.finite(bs) || bs <= 0) bs <- .get_block_size()\n  if (!is.finite(bs) || bs <= 0) stop(\"cv_gam_with_R(): invalid block size.\")\n\n  zR   <- smooth_mean_R(E, R)\n  # zR existiert hier bereits und ist aktuell (falsch) eine Matrix\n  zR <- .as_rast_like(zR, template = E)  # E ist dein vorhandenes SpatRaster (Stack/Kovariaten/DEM)\n  names(zR) <- \"elev\"                     # optional, sauber benennen\n\n  slpR <- terra::terrain(zR, v = \"slope\",  unit = \"radians\")\n  aspR <- terra::terrain(zR, v = \"aspect\", unit = \"radians\")\n  cosiR <- if (!is.null(alt) && !is.null(az)) {\n    ci <- cos(slpR)*cos(pi/2 - alt) + sin(slpR)*sin(pi/2 - alt)*cos(az - aspR)\n    terra::ifel(ci < 0, 0, ci)\n  } else NULL\n\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) { xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2] }\n  fill_med <- function(v) { m <- stats::median(v[is.finite(v)], na.rm = TRUE); ifelse(is.finite(v), v, m) }\n  stn_sf$z_surf_R <- fill_med(.extract_to_pts(zR,   stn_sf))\n  stn_sf$slp_R    <- fill_med(.extract_to_pts(slpR, stn_sf))\n  stn_sf$cosi_R   <- if (is.null(cosiR)) rep(NA_real_, nrow(stn_sf)) else fill_med(.extract_to_pts(cosiR, stn_sf))\n\n  bb_poly <- sf::st_as_sfc(sf::st_bbox(stn_sf), crs = sf::st_crs(stn_sf))\n  blocks  <- sf::st_make_grid(bb_poly, cellsize = c(bs, bs), what = \"polygons\")\n  blocks  <- sf::st_sf(block_id = seq_along(blocks), geometry = blocks)\n\n  stn_blk <- sf::st_join(stn_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (anyNA(stn_blk$block_id)) {\n    i <- is.na(stn_blk$block_id)\n    stn_blk$block_id[i] <- blocks$block_id[sf::st_nearest_feature(stn_blk[i,], blocks)]\n  }\n  if (!all(c(\"x\",\"y\") %in% names(stn_blk))) { xy <- sf::st_coordinates(stn_blk); stn_blk$x <- xy[,1]; stn_blk$y <- xy[,2] }\n\n  bids  <- sort(unique(stn_blk$block_id))\n  preds <- vector(\"list\", length(bids)); j <- 0L\n  for (b in bids) {\n    te <- stn_blk[stn_blk$block_id == b, ]\n    tr <- stn_blk[stn_blk$block_id != b, ]\n\n    dtr <- sf::st_drop_geometry(tr)\n    need <- c(\"temp\",\"x\",\"y\",\"z_surf_R\",\"slp_R\",\"cosi_R\")\n    dtr  <- dtr[stats::complete.cases(dtr[, intersect(need, names(dtr)), drop = FALSE]), , drop = FALSE]\n    if (nrow(dtr) < 10) next\n\n    n_xy <- dplyr::n_distinct(paste0(round(dtr$x,3), \"_\", round(dtr$y,3)))\n    k_xy <- .k_for_xy(nrow(dtr), n_xy)\n    k_z  <- .kcap_unique(dtr$z_surf_R, 20)\n    k_sl <- .kcap_unique(dtr$slp_R,    12)\n    k_ci <- .kcap_unique(dtr$cosi_R,   12)\n\n    terms <- c()\n    terms <- c(terms, if (n_xy >= 4) sprintf(\"s(x,y,bs='tp',k=%d)\", k_xy) else \"x + y\")\n    terms <- c(terms, if (k_z  >= 4) sprintf(\"s(z_surf_R,bs='tp',k=%d)\", k_z)  else \"z_surf_R\")\n    if (length(unique(dtr$slp_R[is.finite(dtr$slp_R)])) > 1)\n      terms <- c(terms, if (k_sl >= 4) sprintf(\"s(slp_R,bs='tp',k=%d)\", k_sl) else \"slp_R\")\n    if (any(is.finite(dtr$cosi_R)) && length(unique(dtr$cosi_R[is.finite(dtr$cosi_R)])) > 1)\n      terms <- c(terms, if (k_ci >= 4) sprintf(\"s(cosi_R,bs='tp',k=%d)\", k_ci) else \"cosi_R\")\n\n    form <- as.formula(paste(\"temp ~\", paste(terms, collapse = \" + \")))\n    gm <- mgcv::gam(form, data = dtr, method = \"REML\", select = TRUE)\n\n    dte <- sf::st_drop_geometry(te)\n    ph  <- try(stats::predict(gm, newdata = dte, type = \"response\"), silent = TRUE)\n    if (inherits(ph, \"try-error\")) ph <- rep(NA_real_, nrow(dte))\n\n    j <- j + 1L\n    preds[[j]] <- tibble::tibble(id = te$id, obs = te$temp, pred = as.numeric(ph), block_id = b)\n  }\n\n  preds <- preds[seq_len(j)]\n  if (!length(preds)) {\n    return(list(cv = tibble::tibble(id = integer(), obs = numeric(), pred = numeric(), block_id = integer()),\n                RMSE = NA_real_))\n  }\n  out  <- dplyr::bind_rows(preds)\n  rmse <- sqrt(mean((out$pred - out$obs)^2, na.rm = TRUE))\n  list(cv = out, RMSE = rmse)\n}\n\n# U-curve scan over R ---------------------------------------------------\ntune_Rstar_ucurve <- function(stn_sf, E, alt, az, L50, L95, block_fallback = 120, n_grid = 6, extra = c(0.8, 1.2)) {\n  L50 <- as.numeric(L50); L95 <- as.numeric(L95)\n  if (!is.finite(L50) || !is.finite(L95) || L95 <= L50) {\n    e <- terra::ext(E)\n    dom_diag <- sqrt((terra::xmax(e)-terra::xmin(e))^2 + (terra::ymax(e)-terra::ymin(e))^2)\n    L50 <- dom_diag/10; L95 <- dom_diag/4\n  }\n  block_m <- max(block_fallback, round(L50))\n  R_min <- max(10, round(L50*extra[1])); R_max <- round(L95*extra[2])\n  R_grid <- unique(round(seq(R_min, R_max, length.out = n_grid)))\n  df <- do.call(rbind, lapply(R_grid, function(R) {\n    z <- cv_gam_with_R(stn_sf, E, alt, az, R = R, block_size_m = block_m); c(R = R, RMSE = z$RMSE)\n  })) |> as.data.frame()\n  R_star <- df$R[which.min(df$RMSE)]\n  list(grid = df, R_star = as.numeric(R_star), block_m = block_m)\n}\n\nplot_ucurve <- function(df, R_star, title = \"U-curve: tune R\") {\n  ggplot2::ggplot(df, ggplot2::aes(R, RMSE)) +\n    ggplot2::geom_line() + ggplot2::geom_point() +\n    ggplot2::geom_vline(xintercept = R_star, linetype = \"dashed\", colour = \"#de2d26\") +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = title, x = \"Drift radius R (m)\", y = \"RMSE (block-CV)\")\n}\n```\n:::\n\n\n\n**Apply on T14/T05**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLs14 <- compute_Ls_from_points(stn_sf_14, value_col = \"temp\")\nLs05 <- compute_Ls_from_points(stn_sf_05, value_col = \"temp\")\np_vg14 <- plot_variogram_with_scales(Ls14$vg, Ls14$L50, Ls14$L95, Ls14$sill,\n                                     title = \"T14 — empirical variogram with L50/L95\")\np_vg05 <- plot_variogram_with_scales(Ls05$vg, Ls05$L50, Ls05$L95, Ls05$sill,\n                                     title = \"T05 — empirical variogram with L50/L95\")\np_vg14; p_vg05\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/T14_T05-1.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/T14_T05-2.png){width=1350}\n:::\n\n```{.r .cell-code}\ntune14 <- tune_Rstar_ucurve(stn_sf_14, scen$E, sun14$alt, sun14$az, Ls14$L50, Ls14$L95, block_fallback = block_size, n_grid = 6)\ntune05 <- tune_Rstar_ucurve(stn_sf_05, scen$E, sun05$alt, sun05$az, Ls05$L50, Ls05$L95, block_fallback = block_size, n_grid = 6)\n\nplot_ucurve(tune14$grid, tune14$R_star, title = \"T14 — U-curve\")\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/T14_T05-3.png){width=1350}\n:::\n\n```{.r .cell-code}\nplot_ucurve(tune05$grid, tune05$R_star, title = \"T05 — U-curve\")\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/T14_T05-4.png){width=1350}\n:::\n\n```{.r .cell-code}\nmessage(sprintf(\"Chosen R* — T14: %d m | blocks ≈ %d m\", tune14$R_star, tune14$block_m))\nmessage(sprintf(\"Chosen R* — T05: %d m | blocks ≈ %d m\", tune05$R_star, tune05$block_m))\n```\n:::\n\n\n\n## 12. Tuning effects: rebuild features @ **R\\*** and re-evaluate\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Smoothed features @ R*\nfr14 <- smooth_dem_and_derive(scen$E, sun14$alt, sun14$az, radius_m = tune14$R_star)\nfr05 <- smooth_dem_and_derive(scen$E, sun05$alt, sun05$az, radius_m = tune05$R_star)\n\n# Add smoothed drifts to station points\nadd_drifts_at_R <- function(stn_sf, E, alt, az, R, lc = NULL, lc_levels = NULL) {\n  dr <- smooth_dem_and_derive(E, alt, az, radius_m = R)\n  XY <- sf::st_coordinates(stn_sf)\n  stn_sf$z_surf <- as.numeric(terra::extract(dr$Es,   XY)[,1])\n  stn_sf$slp    <- as.numeric(terra::extract(dr$slp,  XY)[,1])\n  stn_sf$cosi   <- as.numeric(terra::extract(dr$cosi, XY)[,1])\n  if (!is.null(lc)) {\n    lc_codes <- as.integer(terra::extract(lc, XY)[,1])\n    if (!is.null(lc_levels)) {\n      lc_codes[is.na(lc_codes)] <- 1L\n      lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n      stn_sf$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n    } else stn_sf$lc <- factor(lc_codes)\n  }\n  stn_sf\n}\nstn14_R <- add_drifts_at_R(stn_sf_14, scen$E, sun14$alt, sun14$az, tune14$R_star, lc = scen$lc, lc_levels = scen$lc_levels)\nstn05_R <- add_drifts_at_R(stn_sf_05, scen$E, sun05$alt, sun05$az, tune05$R_star, lc = scen$lc, lc_levels = scen$lc_levels)\n\n# Re-run blocked CV & maps with smoothed features\nbench14 <- run_lbo_cv(stn14_R, E = fr14$Es, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nbench05 <- run_lbo_cv(stn05_R, E = fr05$Es, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps14_tuned <- predict_maps(\n  stn_sf = stn14_R, truth_raster = scen$R14, which_time = \"T14\",\n  scen = scen, models = models_use, lc_levels = scen$lc_levels,\n  feature_rasters = list(E = fr14$Es, slp = fr14$slp, cosi = fr14$cosi)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps05_tuned <- predict_maps(\n  stn_sf = stn05_R, truth_raster = scen$R05, which_time = \"T05\",\n  scen = scen, models = models_use, lc_levels = scen$lc_levels,\n  feature_rasters = list(E = fr05$Es, slp = fr05$slp, cosi = fr05$cosi)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n:::\n\n\n\n**Side-by-side diagnostic panels (truth | predictions | errors):**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npanel14_tuned <- build_panels_with_errors(maps14_tuned, scen$R14, bench14$cv, stn14_R, \"T14\",\n                                          temp_palette = temp_palette, stretch_q = stretch_q, layout = \"horizontal\")\npanel05_tuned <- build_panels_with_errors(maps05_tuned, scen$R05, bench05$cv, stn05_R, \"T05\",\n                                          temp_palette = temp_palette, stretch_q = stretch_q, layout = \"horizontal\")\n\npanel14_tuned; panel05_tuned\n```\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/diagnostic_panels-1.png){width=1350}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_2025_new_files/figure-html/diagnostic_panels-2.png){width=1350}\n:::\n:::\n\n\n\n## 13. Export: figures, tables, rasters, session info\n\n::: callout-note\n**Tip.** Use fixed paths so repeated runs don’t overwrite the entire\nproject; export both **baseline** and **tuned** assets.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Output folders --------------------------------------------------------\nout_dir <- \"exports\"\nfig_dir <- file.path(out_dir, \"figs\")\ntab_dir <- file.path(out_dir, \"tables\")\nras_dir <- file.path(out_dir, \"rasters\")\ndat_dir <- file.path(out_dir, \"data\")\ndir.create(out_dir, showWarnings = FALSE)\nfor (d in c(fig_dir, tab_dir, ras_dir, dat_dir)) dir.create(d, showWarnings = FALSE)\n\n# Helpers\nsafe_save_plot <- function(p, file, w = 9, h = 6, dpi = 300) {\n  if (!is.null(p) && inherits(p, c(\"gg\",\"ggplot\",\"patchwork\"))) {\n    try(ggplot2::ggsave(filename = file, plot = p, width = w, height = h, dpi = dpi, bg = \"white\"), silent = TRUE)\n  }\n}\nsafe_write_csv <- function(x, file) { if (!is.null(x)) try(utils::write.csv(x, file, row.names = FALSE), silent = TRUE) }\nsafe_save_kable <- function(df, file_html, caption = NULL) {\n  if (!is.null(df) && requireNamespace(\"kableExtra\", quietly = TRUE)) {\n    tab <- knitr::kable(df, digits = 3, caption = caption, format = \"html\")\n    kableExtra::save_kable(tab, file_html, self_contained = TRUE)\n  }\n}\n\n# Save plots ------------------------------------------------------------\nplots <- list(\n  \"T14_panel_tuned.png\"  = if (exists(\"panel14_tuned\")) panel14_tuned else NULL,\n  \"T05_panel_tuned.png\"  = if (exists(\"panel05_tuned\")) panel05_tuned else NULL,\n  \"T14_blocks.png\"       = if (exists(\"out14\")) out14$res$blocks_plot else NULL,\n  \"T14_diag.png\"         = if (exists(\"out14\")) out14$res$diag_plot   else NULL,\n  \"T05_blocks.png\"       = if (exists(\"out05\")) out05$res$blocks_plot else NULL,\n  \"T05_diag.png\"         = if (exists(\"out05\")) out05$res$diag_plot   else NULL,\n  \"T14_truth.png\"        = if (exists(\"out14\")) out14$maps$p_truth else NULL,\n  \"T14_pred.png\"         = if (exists(\"out14\")) out14$maps$p_pred  else NULL,\n  \"T05_truth.png\"        = if (exists(\"out05\")) out05$maps$p_truth else NULL,\n  \"T05_pred.png\"         = if (exists(\"out05\")) out05$maps$p_pred  else NULL,\n  \"T14_variogram.png\"    = if (exists(\"p_vg14\")) p_vg14 else NULL,\n  \"T05_variogram.png\"    = if (exists(\"p_vg05\")) p_vg05 else NULL\n)\nfor (nm in names(plots)) safe_save_plot(plots[[nm]], file.path(fig_dir, nm), w = 9, h = 6, dpi = 300)\n\n# Save tables & CSVs ----------------------------------------------------\nif (exists(\"out14\")) { safe_write_csv(out14$res$cv, file.path(dat_dir, \"cv_points_T14.csv\"))\n                       safe_write_csv(out14$maps$pred_df, file.path(dat_dir, \"grid_pred_T14.csv\"))\n                       safe_write_csv(out14$res$metrics, file.path(tab_dir, \"metrics_T14_base.csv\"))\n                       safe_save_kable(out14$res$metrics, file_path <- file.path(tab_dir, \"metrics_T14_base.html\"), \"LBO-CV metrics — T14\") }\nif (exists(\"out05\")) { safe_write_csv(out05$res$cv, file.path(dat_dir, \"cv_points_T05.csv\"))\n                       safe_write_csv(out05$maps$pred_df, file.path(dat_dir, \"grid_pred_T05.csv\"))\n                       safe_write_csv(out05$res$metrics, file.path(tab_dir, \"metrics_T05_base.csv\"))\n                       safe_save_kable(out05$res$metrics, file.path(tab_dir, \"metrics_T05_base.html\"), \"LBO-CV metrics — T05\") }\nif (exists(\"bench14\")) { safe_write_csv(bench14$metrics, file.path(tab_dir, \"metrics_T14_tuned.csv\"))\n                         safe_save_kable(bench14$metrics, file.path(tab_dir, \"metrics_T14_tuned.html\"), \"Metrics — tuned @ R* (T14)\") }\nif (exists(\"bench05\")) { safe_write_csv(bench05$metrics, file.path(tab_dir, \"metrics_T05_tuned.csv\"))\n                         safe_save_kable(bench05$metrics, file.path(tab_dir, \"metrics_T05_tuned.html\"), \"Metrics — tuned @ R* (T05)\") }\n\n# Scales & R* summaries -------------------------------------------------\nif (exists(\"tune14\") && exists(\"Ls14\")) {\n  utils::write.csv(tune14$grid, file.path(tab_dir, \"Ucurve_T14.csv\"), row.names = FALSE)\n  utils::write.csv(data.frame(L50 = Ls14$L50, L95 = Ls14$L95, R_star = tune14$R_star),\n                   file.path(tab_dir, \"scales_T14.csv\"), row.names = FALSE)\n}\nif (exists(\"tune05\") && exists(\"Ls05\")) {\n  utils::write.csv(tune05$grid, file.path(tab_dir, \"Ucurve_T05.csv\"), row.names = FALSE)\n  utils::write.csv(data.frame(L50 = Ls05$L50, L95 = Ls05$L95, R_star = tune05$R_star),\n                   file.path(tab_dir, \"scales_T05.csv\"), row.names = FALSE)\n}\n\n# Raster exports --------------------------------------------------------\nif (exists(\"scen\")) {\n  try(terra::writeRaster(scen$E,   file.path(ras_dir, \"E_dem.tif\"),    overwrite = TRUE), silent = TRUE)\n  try(terra::writeRaster(scen$R14, file.path(ras_dir, \"R14_truth.tif\"), overwrite = TRUE), silent = TRUE)\n  try(terra::writeRaster(scen$R05, file.path(ras_dir, \"R05_truth.tif\"), overwrite = TRUE), silent = TRUE)\n  if (\"lc\" %in% names(scen)) try(terra::writeRaster(scen$lc, file.path(ras_dir, \"landcover.tif\"),\n                                                    overwrite = TRUE), silent = TRUE)\n}\n\n# Session info ----------------------------------------------------------\ntry(saveRDS(sessionInfo(), file.path(out_dir, \"sessionInfo.rds\")), silent = TRUE)\nmessage(\"✔ Export complete. See folder: \", normalizePath(out_dir))\n```\n:::\n\n\n\n## What \n# 1) Start with causes, hunt for signatures\n\nBefore touching algorithms, write the **causal story** for each time slice.\n\n* **Day (T14):** shortwave forcing filtered by slope/aspect and canopy ⇒ warm-on-sunward facets, muted under forest/water.\n* **Pre-dawn (T05):** gravity drainage + pooling in the trough, partly blocked by hills; water stays warmest; bare soil cools fastest.\n\nEach cause implies a **spatial signature** you can try to see directly:\n\n* Sun → patterns aligned with solar azimuth; strong **facet contrasts**.\n* Pooling → a **cross-valley trough** and longer correlation **along** the valley than **across** (anisotropy).\n* Land cover → **patch-scale** steps (forest edges, water rim).\n\nIf you can’t sketch the signature, don’t expect the model to learn it.\n\n# 2) Orient the space, then measure the scales\n\nRaw x–y is rarely the right basis in valleys.\n\n* Rotate into **(s, t)**: *s* along-valley, *t* cross-valley.\n  This turns “anisotropy” into “different scales on s vs t.”\n* Compute **directional variograms** (s vs t). You’re not fitting a full anisotropic model yet—just asking: *is range$_s$ » range$_t$?*\n\nFrom there, estimate **L50/L95** (the correlation length(s)) *per direction* and *per process slice* (T14 vs T05). That gives you the **least amount of smoothing** the data can justify without hallucinating detail.\n\n# 3) Encode the physics as drifts, not as post-hoc fixes\n\nDon’t hide process inside a black box if a **mechanistic drift** is at hand.\n\n* Day: $\\cos(i)$ with the **correct sun**, optionally at two neighborhoods (facet vs meso).\n* Night: **distance to axis**, **cross-valley curvature**, and a **hill block mask** to weaken pooling upwind of bumps.\n* Land cover: class + **local fractions** in a neighborhood (LC acts at patch scale and via roughness).\n\nThese drifts act like **prewhitening**: they remove the explainable structure so your residual field is closer to stationary, which helps any learner.\n\n# 4) Match feature scale to process scale (the “R\\*” idea)\n\nYou’re not smoothing the *targets*; you’re recomputing the **features** (z, slope, cos(i)) at a physically plausible radius $R$. Then:\n\n* Scan $R \\in [L50, L95]$ (per slice).\n* Pick $R^*$ where **blocked** RMSE is minimal.\n* If patchiness is real (your “high-roughness” case), add a second radius $R_2$ and let models combine $(R^*, R_2)$.\n\nThis is how you balance **detail vs stability** without overfitting noise.\n\n# 5) Validate the idea, not just the metric\n\nMetrics can be flat between several “okay” choices. So add **idea tests**:\n\n* **Directional residual variograms:** after adding drifts + $R^*$, short-lag structure and s–t anisotropy in residuals should shrink.\n* **Axis-holdout:** remove a cross-valley strip; can the model rebuild the trough from the physics + along-valley samples?\n* **Sun-flip sanity:** if you rotate solar azimuth to an impossible angle, performance should degrade for T14. If it doesn’t, your day-physics isn’t doing work.\n\n# 6) Where anisotropy matters (and where it doesn’t)\n\n* If your rotated (s, t) view shows **range$_s$ \\~ 3–10× range$_t$**, anisotropy is structural. You can either:\n\n  * Keep isotropic models but **feed anisotropy in the coordinates** (s, t) + cross-valley features; or\n  * Use an **anisotropic variogram** (for OK/KED) once residuals are close to stationary.\n* If ranges are similar, anisotropy is a distraction. Focus on $R^*$ and good drifts.\n\n# 7) “Can I just brute-force RF?”\n\nRF will *often* look good, especially with rich features, but:\n\n* RF fixes **nonlinearity**; it does **not** fix **leakage** (wrong CV scale) or **nonstationarity** (missing drifts).\n* You’ll get lower error but poorer **explainability** and fragile **extrapolation** (e.g., a new hill or bigger lake).\n  A solid pattern: use RF after you’ve done steps 1–4, not instead of them.\n\n# 8) Reading the error budget (what each piece buys)\n\n* **Blocking at the right scale**: prevents optimistic RMSE; typically the single biggest honesty gain.\n* **R\\*** on features: reduces oversharp slopes/asp artifacts; stabilizes day fields a lot, night fields somewhat.\n* **Anisotropy handling** (rotate + features): buys you cross-valley accuracy on pooled minima and reduces banding.\n* **LC fractions & dist-to-water**: crucial in patchy/“big lake” scenarios; otherwise marginal.\n\n# 9) A practical rhythm\n\n1. Sketch the causal map → list expected signatures.\n2. Rotate to (s, t); check directional ranges.\n3. Build drifts that match the story.\n4. Tune $R^*$ on features with **blocked CV**.\n5. Inspect residuals for leftover anisotropy/structure; iterate drifts, not just models.\n6. Only then compare learners (OK/KED/GAM/RF) under the **same** blocking.\n\nIf you keep that rhythm, you’re not “dot-pointing”—you’re *teasing out patterns that exist*, then letting the learner mop up what’s left. That’s the art.\n\n\n1. Process priors (simple physics before stats)\n   ✅ Covered — valley parabola + hill/pond, LC knobs, pooling, lapse/inversion.\n   **Where:** `build_scenario()`, `build_physics_fields()`, LC tables.\n\n2. Data-driven scale inference\n   ✅ Covered — empirical variogram → L50/L95.\n   **Where:** `compute_Ls_from_points()`, `plot_variogram_with_scales()`.\n\n3. Tuned feature scale (R\\*)\n   ✅ Covered — U-curve scan to pick **R\\***, then rebuild smoothed drifts.\n   **Where:** `tune_Rstar_ucurve()`, `smooth_dem_and_derive()`, `add_drifts_at_R()`.\n\n4. Honest spatial validation\n   ✅ Covered — Leave-Block-Out CV with block map + per-model metrics.\n   **Where:** `run_lbo_cv()`, `make_blocks_and_assign()`, `blocks_plot`, `diag_plot`.\n\n5. Model diversity (bias–variance spectrum)\n   ✅ Covered — Voronoi, IDW, OK, KED, RF, GAM.\n   **Where:** `pred_*()` family; `predict_maps()` panels.\n\n6. Anisotropy awareness\n   🟡 Partial — implicit via slope/cosi/valley geometry; no directional variogram yet.\n   **Add next:** rotated coords (along/cross-valley), `variogram(..., alpha=)` sweep, anisotropic OK/KED.\n\n7. Sampling geometry experiments\n   ✅ Covered — random vs. NS/EW transects; adjustable counts/margins.\n   **Where:** “Stations” chunk (`station_mode`, `n_st`, offsets).\n\n8. Heterogeneity / roughness scenarios\n   ✅ Covered — patchy (micro-hills), smooth pipe, big-lake wrappers.\n   **Where:** `scenario_patchy()`, `scenario_smooth()`, `scenario_biglake()`.\n\n9. Error budget diagnostics\n   🟡 Partial — MAE/RMSE/Bias/R², residual densities, block-wise boxes. Uncertainty maps not exported.\n   **Add next:** kriging variance surfaces, residual rasters, spatially varying RMSE.\n\n10. Reproducibility & exports\n    ✅ Covered — figures, CSVs (CV points, grid preds, metrics), rasters, session info.\n    **Where:** “Export” chunk (`safe_save_plot`, `safe_write_csv`, `writeRaster`, `sessionInfo`).\n\n\n\n# PipeModel — executive summary\n\nAn idealized “half-pipe” valley with optional hill and lake, plus land-cover physics, to expose the dominant microclimate drivers (radiation, elevation lapse/inversion, cold-air pooling, canopy/soil effects). You sample stations, fit several interpolators, and evaluate them with spatial **leave-block-out cross-validation (LBO-CV)**.\n\n## Core workflow\n\n1. **Process first:** encode plausible physics before modeling (parabolic valley, hill/pond, LC response, pooling, lapse/inversion).\n2. **Measure scale:** use the empirical variogram to get **L50/L95** correlation lengths.\n3. **Tune feature scale (R\\*):** smooth **features** (DEM, slope, cos i) over candidate radii between L50 and L95; pick **R\\*** via **blocked RMSE** (“U-curve”).\n4. **Validate honestly:** run **LBO-CV** at a physically sensible block size; inspect metrics and residual structure.\n5. **Compare learners:** Voronoi, IDW, OK, KED, RF, GAM under the same CV and features.\n6. **Stress with scenarios:** patchy/rough, smooth pipe, big-lake variants.\n\n## Methods covered (where in code)\n\n* **Physics & scenario:** `build_scenario()`, `build_physics_fields()` (+ LC response tables).\n* **Scale inference:** `compute_Ls_from_points()` → **L50/L95**; `plot_variogram_with_scales()`.\n* **R\\* tuning:** `tune_Rstar_ucurve()`, `smooth_dem_and_derive()`, `add_drifts_at_R()`.\n* **Models:** `pred_Voronoi()`, `pred_IDW()`, `pred_OK()`, `pred_KED()`, `pred_RF()`, `pred_GAM()`; grid maps via `predict_maps()`.\n* **Validation:** `run_lbo_cv()`, `make_blocks_and_assign()` with diagnostics (blocks map, obs–pred, residual density, boxplots).\n* **Scenarios:** `scenario_patchy()`, `scenario_smooth()`, `scenario_biglake()`.\n* **Exports:** figures, CSVs, rasters, session info.\n\n## Validation & metrics\n\n* **LBO-CV** ensures spatial independence at the chosen block size.\n* Report **MAE**, **RMSE**, **Bias**, **R²**, residual densities, and block-wise error distributions.\n* Panels show truth vs. predictions, plus CV residual overlays.\n\n## Scale & anisotropy\n\n* Rotate the valley to along/cross axes (**s**, **t**) conceptually; use variograms to test if range\\_s » range\\_t (anisotropy).\n* In this script anisotropy is handled implicitly (via slope/cos i and valley geometry). Directional variograms and anisotropic kriging are noted as a next step.\n\n## Scenarios included\n\n* **Patchy midsummer:** micro-hills + canopy heterogeneity (roughness).\n* **Smooth pipe:** no features; essentially uniform meadow.\n* **Big lake:** enlarged water body to probe strong LC forcing.\n\n## What’s partially covered / next\n\n* **Anisotropy (explicit):** add rotated coords and directional variograms; try anisotropic OK/KED.\n* **Uncertainty maps:** export kriging variance and spatial patterns of |residual|.\n* **Temporal breadth:** add more hours (e.g., 08/12/16 UTC) to show daily scale drift.\n\n## Practical rhythm to reuse\n\n1. Sketch the causal map and expected spatial signatures.\n2. Inspect scales (variogram) and pick a blocked CV size accordingly.\n3. Encode physics as **drifts**, not post-hoc fixes.\n4. Tune **R\\*** on features with blocked RMSE.\n5. Check residuals (structure/anisotropy) → refine drifts.\n6. Compare models under identical validation.\n7. Stress-test with alternative scenarios and sampling layouts.\n\nThat’s the tutorial in a nutshell: start from causes, quantify scale, tune features (not targets), validate at the right spatial grain, and then let diverse learners mop up the residuals.\n\n\n",
    "supporting": [
      "pipemodel_2025_new_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}