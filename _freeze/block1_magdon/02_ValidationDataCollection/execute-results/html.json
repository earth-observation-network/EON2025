{
  "hash": "16af20b2bfae239c8c934f07743f0617",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Collection of validation data in the context of remote sensing based \n        forest monitoring\"\nsubtitle: \"Tutorial for the EON Summer School 2025\"\nauthor: Paul Magdon[University of Applied Sciences and Arts (HAWK), paul.magdon@hawk.de]\ndate: \"2025-08-26\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.10.2, GDAL 3.4.1, PROJ 7.2.1; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.23\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(rprojroot)\nlibrary(patchwork)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttache Paket: 'patchwork'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDas folgende Objekt ist maskiert 'package:terra':\n\n    area\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_dir=paste0(find_rstudio_root_file(),\"/block1_magdon/data/\")\n```\n:::\n\n\n\n\n# Introduction\nIn this tutorial we will explore the principles of design-based sampling. The\nsimulation part is based on a presentation of Gerad Heuveling from Wageningen \nUniversity, which he gave in the OpenGeoHub Summer School[https://opengeohub.org/summer-school/ogh-summer-school-2021/].  \n\n1. Learn how to draw a spatial random sample\n2. Learn how to draw a systematic grid for a given area of interest\n3. Run a simulation for design-based sampling\n\n# Data sets\n\nFor demonstration purposes we will work with a map of forest above ground\nbiomass (AGB) produced by the Joint Research Center(JRC) for the European Union\nEuropean Commission (Joint Research Centre (JRC) (2020) http://data.europa.eu/89h/d1fdf7aa-df33-49af-b7d5-40d226ec0da3.)\n\nTo provide a synthetic example we will assume that this map (agb_pop) is an\nerror free representation of the population. Additionally we use a second map\n(agb_model) compiled using a machine learning model (RF) also depicting the AGB \ndistribution. \n\nBefore we can start you may download the following files:\n\n1. [AGB_pop](https://cloud.hawk.de/index.php/s/BBHMksRC3bjc2WD)\n2. [AGB_model](https://cloud.hawk.de/index.php/s/fJzigXwzbHRLNdy)\n3. [National park boundary](https://cloud.hawk.de/index.php/s/2G4XCatn87S8FsX)\n\nPlace all files into the sub folder 'data' of this tutorial. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Import the boundary of the national park\nnp_boundary = st_transform(st_read(paste0(data_dir,\"nlp-harz_aussengrenze.gpkg\")),25832)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `nlp-harz_aussengrenze' from data source \n  `F:\\EON2025\\block1_magdon\\data\\nlp-harz_aussengrenze.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1 feature and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 591196.6 ymin: 5725081 xmax: 619212.6 ymax: 5751232\nProjected CRS: WGS 84 / UTM zone 32N\n```\n\n\n:::\n\n```{.r .cell-code}\nagb_pop <- terra::rast(paste0(data_dir,\"agb_np_harz_truth.tif\"))\n\nagb_model <-terra::rast(paste0(data_dir,\"agb_np_harz_model.tif\"))\n```\n:::\n\n\n\n\nIf we assume the $z(x_i)=$ agb.pop to be an exact representation of the \npopulation we can calculate the Root mean Square Error (RMSE) as the difference\nbetween the model predictions $\\hat{z(x_i)}$ and the population map with:\n\n$$\nRMSE = \\sqrt{\\frac{1}{N}\\sum{(z(x_{})-\\hat{z}(x_{i}))^2}}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRMSE_pop = as.numeric(sqrt(terra::global((agb_pop-agb_model)^2,fun='mean',na.rm=TRUE)))\n```\n:::\n\n\n\n\nBy looking at the difference from the \"true\" AGB and the difference we get a true\nRMSE of *41.23* t/ha. \n\n# Collect a random sample\n\nSince we know the true RMSE, we can test if a random sample estimate has \na similar RMSE. We start with a random sample with $n=100$ sample points. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn=100\n\np1 = sf::st_sample(np_boundary,size=n)\nggplot()+geom_sf(data=np_boundary,fill=NA)+\n  geom_sf(data=p1)\n```\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/RMSEest-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can now extract the population values and the model values at the sample\nlocations and calculate the RMSE for all sample points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample <- terra::extract((agb_pop-agb_model),vect(p1))\nnames(sample)<-c('ID','Diff')\nRMSE_est <- sqrt(mean((sample$Diff)^2,na.rm=T))\n```\n:::\n\n\n\n\nThe random sample estimates the RMSE as 40.98. \n\nBut is this an unbiased estimate?\n\n# Simulation of many random samples\n\nTo check if our sample based estimates are unbiased we will repeat the sampling\n$k$ times. \n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 53\n[1] 54\n[1] 55\n[1] 56\n[1] 57\n[1] 58\n[1] 59\n[1] 60\n[1] 61\n[1] 62\n[1] 63\n[1] 64\n[1] 65\n[1] 66\n[1] 67\n[1] 68\n[1] 69\n[1] 70\n[1] 71\n[1] 72\n[1] 73\n[1] 74\n[1] 75\n[1] 76\n[1] 77\n[1] 78\n[1] 79\n[1] 80\n[1] 81\n[1] 82\n[1] 83\n[1] 84\n[1] 85\n[1] 86\n[1] 87\n[1] 88\n[1] 89\n[1] 90\n[1] 91\n[1] 92\n[1] 93\n[1] 94\n[1] 95\n[1] 96\n[1] 97\n[1] 98\n[1] 99\n[1] 100\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/simulation-1.png){width=672}\n:::\n:::\n\n\n\nWe see that the true RMSE and the mean of the $k$ simulation runs are almost equal.\nThus, we can assume an unbiased estimate of the RMSE.\n\nBut how does the sample size $n$ affects the accuracy?\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 53\n[1] 54\n[1] 55\n[1] 56\n[1] 57\n[1] 58\n[1] 59\n[1] 60\n[1] 61\n[1] 62\n[1] 63\n[1] 64\n[1] 65\n[1] 66\n[1] 67\n[1] 68\n[1] 69\n[1] 70\n[1] 71\n[1] 72\n[1] 73\n[1] 74\n[1] 75\n[1] 76\n[1] 77\n[1] 78\n[1] 79\n[1] 80\n[1] 81\n[1] 82\n[1] 83\n[1] 84\n[1] 85\n[1] 86\n[1] 87\n[1] 88\n[1] 89\n[1] 90\n[1] 91\n[1] 92\n[1] 93\n[1] 94\n[1] 95\n[1] 96\n[1] 97\n[1] 98\n[1] 99\n[1] 100\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/Simulation2-1.png){width=672}\n:::\n:::\n\n\n\n\nWe see that the precision of the estimates is increased. How much did the\nuncertainty decrease when we increase the sample size from $n=50$ \nto $n=100$?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(RMSE_2)/sd(RMSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6458648\n```\n\n\n:::\n:::\n\n\n\n\n\n# Systematic sampling\n\nInstead of a random sampling, systematic designs are more common in forest \ninventories for the following reasons:\n\n* Easy to establish and to document\n* Ensures a balanced spatial coverage\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = sf::st_sample(np_boundary,size=n,type='regular')\n\nggplot()+geom_sf(data=np_boundary,fill=NA)+\n  geom_sf(data=p1)\n```\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/systematicSample-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\nn <- 100\nRMSE_3 <- rep(0,k) \n\nfor (i in 1:k) {\n  print(i)\n  p1 = sf::st_sample(np_boundary,size=n,type='regular')\n  error<- terra::extract(dif,vect(p1))\n  RMSE_3[i] <- sqrt(mean((error$dif)^2,na.rm=T))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 53\n[1] 54\n[1] 55\n[1] 56\n[1] 57\n[1] 58\n[1] 59\n[1] 60\n[1] 61\n[1] 62\n[1] 63\n[1] 64\n[1] 65\n[1] 66\n[1] 67\n[1] 68\n[1] 69\n[1] 70\n[1] 71\n[1] 72\n[1] 73\n[1] 74\n[1] 75\n[1] 76\n[1] 77\n[1] 78\n[1] 79\n[1] 80\n[1] 81\n[1] 82\n[1] 83\n[1] 84\n[1] 85\n[1] 86\n[1] 87\n[1] 88\n[1] 89\n[1] 90\n[1] 91\n[1] 92\n[1] 93\n[1] 94\n[1] 95\n[1] 96\n[1] 97\n[1] 98\n[1] 99\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_3<- data.frame(x=RMSE_3, y=rep('c',k))\ndf<-rbind(df,df_3)\n\nggplot(data=df,aes(x=x, fill=y))+\n  geom_density(alpha=0.5)+\n  scale_fill_discrete(labels=c('Random, n=50', 'Random, n=100','Systematic, n=100'))+\n  xlab('RMSE (t/ha)')+geom_vline(xintercept=RMSE_pop,linewidth=1.5,\n                          color ='black', linetype='longdash')+\n  geom_vline(xintercept=mean(df$x),linewidth=1.5,\n                       color ='black')\n```\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/SystematicSimlation-1.png){width=672}\n:::\n:::\n\n\n\n\n# Evaluating the AGB-Model \n\n## Systematic sample to collect reference data for map validation\n\nTo validate the map we use a systematic sample grid. In a real world\napplication we do not know the true population values. Therefore, field\nwork would be needed to collect reference data at the selected sample\npoints. In this workshop we assume that the agp_pop map represents the\ntrue value without any errors. Thus, we don't need to go to field but we\ncan sample the data by extracting the true values from the map at the\nsample locations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we will use n=100 sample plots\nn=100\np1 = sf::st_sample(np_boundary,size=n,type='regular')\n\nggplot()+geom_sf(data=np_boundary,fill=NA)+\n  geom_sf(data=p1)\n```\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/Sample-1.png){width=672}\n:::\n:::\n\n\n\n\nAt each sample point we extract the predicted and observed AGB value.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobs <- terra::extract(agb_pop,vect(p1))\nnames(obs)<-c('ID','obs')\n\npred <- terra::extract(agb_model,vect(p1))\nnames(pred)<-c('ID','pred')\nvalidation<-data.frame(observed=obs$obs, predicted=pred$pred)\n\n# we need to remove the na values from this dataframe. In real world applications\n# such NA values can,  occur for example at inaccessible field plots.\n\nvalidation<-validation[complete.cases(validation),]\n```\n:::\n\n\n\n\n## Assessment of the ABG-model performance\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=validation,aes(x=observed, y=predicted))+\n  geom_point(alpha=0.5)+\n  xlab('Observed AGB t/ha')+ylab('Predicted AGB t/ha')\n```\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/Collect Values-1.png){width=672}\n:::\n:::\n\n\n\n\n### Sample RMSE\nAgain we can use the RMSE to express the mean difference between observed and\npredicted AGB.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRMSE_sample = sqrt(sum((validation$observed-validation$predicted)^2)/nrow(validation))\n```\n:::\n\n\n\n\nThe sample RMSE is 40.2\\* t/ha.\nTo better compare the values between different target variables and models is\ncan also express as a proportion relative to the mean value of the predictions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrRMSE = RMSE_sample/mean(validation$predicted)\n```\n:::\n\n\n\n\nOn average we expect that the AGB estimate of our model has an error of \n24.3 %.\n\n### Error distribution\n\nBut is this RMSE valid for the entire range of the observed values or do we\nexpect higher errors for higher AGB values?\n\nTo see how the model performs over target value range we can use the following\nanalysis plots.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalidation$resid<-validation$observed-validation$predicted\n\np1<-ggplot(data=validation,aes(x=observed, y=predicted))+\n  geom_point(alpha=0.5)+\n  xlab('Observed AGB t/ha')+ylab('Predicted AGB t/ha')+\n  xlim(0,250)+ylim(0,250)+\n  geom_abline(slope=1,intercept = 0)+\n  stat_summary(fun.data= mean_cl_normal) + \n  geom_smooth(method='lm')\n\n\n\np2<-ggplot(data=validation,aes(x=observed, y=resid))+\n  geom_point(alpha=0.5)+\n  xlab('Observed AGB t/ha')+ylab('Residuals')+\n  xlim(0,250)+ylim(-50,+50)+\n  geom_abline(slope=0,intercept = 1)\n\np3<-ggplot(data=validation,aes(x=resid))+\n  geom_histogram(aes(y=..density..),fill='grey',binwidth=10)+\n  xlab('Observed AGB t/ha')+ylab('Density')+\n  xlim(-150,150)+\n  stat_function(fun = dnorm, geom=\"polygon\",args = list(mean = mean(validation$resid), sd = sd(validation$resid)),color='blue',alpha=0.4,fill='blue')+\n  geom_vline(xintercept=0,color='blue')+\n  geom_vline(xintercept=mean(validation$resid),color='red')\np1+p2+p3+plot_layout(ncol=3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing non-finite outside the scale range\n(`stat_summary()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 98 rows containing missing values or values outside the scale range\n(`geom_segment()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 22 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\ni Please use `after_stat(density)` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](02_ValidationDataCollection_files/figure-html/Model-Performance-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}