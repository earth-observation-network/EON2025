{
  "hash": "ebbf192792a469a615b17c8ce4ebfb25",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel Idealized valley microclimate sandbox \"\nsubtitle: \"EON Summer School 2025\"\nauthor: Chris Reudenbach, Philipps University Marburg (PUM)\ndate: \"2025-08-30\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    code-fold: true\n    number-sections: false\n    embed-resources: true\nexecute:\n  echo: true\n  warning: false\n  message: false\n  results: hide\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\nThe **PipeModel** is a deliberately idealized yet physically plausible\nvalley scenario. It distills terrain to the essentials (parabolic\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\ncross-valley profile) and optional features (left-side hill, right-side\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\npond or hollow), so that dominant **microclimate drivers** become\nvisible and testable:\n\n-   **Radiation** via terrain exposure `cos(i)` from slope & aspect\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n-   **Elevation**: daytime negative lapse; pre-dawn weak inversion\n-   **Cold-air pooling** along the valley axis (Gaussian trough)\n-   **Surface type / land-cover** (grass / forest / water / bare soil /\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n    maize) alters heating, shading, roughness and nocturnal behaviour\n\nYou can sample synthetic stations, train interpolators (IDW, Kriging\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\nvariants, RF, GAM), and assess them with **spatial LBO-CV**.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n![](images/pipe.png)\n\n## What the `pipemodel` is\n\nA didactic, reproducible pipeline for micro-scale spatial prediction\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\nwith **process-aware features** and **scale tuning**. It simulates or\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\ningests a domain (“scenario”), learns from station points, validates\nwith **leave-block-out CV**, infers a characteristic **scale (R\\*)**\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\nfrom data, re-trains at that scale, and produces tuned maps,\n<!-- TABLE: Metrics_T14_Tuned — bench14$metrics. -->\n<!-- TABLE: Metrics_T05_Tuned — bench05$metrics. -->\n<!-- MAP: Panel_T14_Tuned — first page of panel_T14 (truth | preds | residuals). -->\n<!-- MAP: Panel_T05_Tuned — first page of panel_T05. -->\ndiagnostics, and optional exports.\n\n## Architecture\n\n1.  **Main (orchestrator):** `main_ultra.R` is intentionally *thin*: it\n    wires pieces together, runs the stages in order, shows live\n    previews, and—optionally—saves outputs at the end. No heavy lifting.\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n    \n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\n\n  # =====================================================================\n  # main_ultra.R — minimal: run + (optional) save-at-end\n  #\n  # Purpose:\n  #   1) Source packages + your function library + scenario registry\n  #   2) Build scenario + station sets from a chosen scenario \"make()\" factory\n  #   3) Live preview: domain/land-cover/terrain + 2x2 overview + scenario preview\n  #   4) Baseline: leave-block-out CV (LBO-CV) and prediction maps (T14, T05)\n  #   5) Scale inference: empirical variogram -> (L50,L95) -> U-curve -> R*\n  #   6) Tuned CV & maps at R*\n  #   7) OPTIONAL: save all plots/tables/rasters at the end\n  #\n  # Design notes:\n  #   - This script stays \"thin\": all heavy lifting lives in fun_pipemodel.R\n  #     and the scenario files. This keeps the main pipe reproducible and\n  #     testable.\n  #   - Keep side effects (saving files) to the very end; set `export <- FALSE`\n  #     if you just want to run and eyeball plots interactively.\n  # =====================================================================\n  \n  message(\"=== pipe main (ultra) ===\")\n  \n  # Toggle: set to FALSE to only run/plot without saving anything\n  export <- TRUE\n  \n  # ---------------------------------------------------------------------\n  # 0) Setup & packages (centralized in your packages.R)\n  #    - Loads CRAN pkgs (terra, sf, ggplot2, mgcv, gstat, suncalc, ...)\n  #    - Sets knitr options (if used in a notebook context)\n  #    - We also disable spherical geometry in sf to keep planar ops robust\n  #      for projected domains (UTM in our scenarios).\n  # ---------------------------------------------------------------------\n  source(here::here(\"block4_5/src/packages.R\"))\n  sf::sf_use_s2(FALSE)\n  set.seed(42)  # one seed here (scenarios may set more where needed)\n  \n  # ---------------------------------------------------------------------\n  # 1) Functions + Scenario registry\n  #    - fun_pipemodel.R: your full function library (NO side effects)\n  #    - registry.R: maps scenario names to files; exposes source_scenario()\n  #      which returns a `make()` function to build the object.\n  # ---------------------------------------------------------------------\n  source(here::here(\"block4_5/src/fun_pipemodel.R\"))\n  source(here::here(\"block4_5/src/fun_learn_predict_core.R\"))\n  source(here::here(\"block4_5/scenarios/registry.R\"))\n  \n  # ---------------------------------------------------------------------\n  # 2) Pick a scenario\n  #    - Choose via env var SCEN (e.g., export SCEN=scen_scaled_demo)\n  #    - Defaults to \"lake_bump_dense\" which is a realistic didactic scene\n  #      (valley, lake, bump hill, dense micro-relief, LC = forest/water/bare/baseline meadow).\n  # ---------------------------------------------------------------------\n  #scen_name <- Sys.getenv(\"SCEN\", \"lake_bump_dense\")\n  scen_name <- Sys.getenv(\"SCEN\", \"scen_scaled_demo\")\n  make_fun  <- source_scenario(scen_name)  # returns a function make(overrides=list(), do_cv=FALSE)\n  \n  # ---------------------------------------------------------------------\n  # 3) Build the object (domain + scenario + stations + params)\n  #    - `obj` is a list with a stable contract used downstream:\n  #        scen: list of rasters (E, R14, R05, I14, I05, lc, sun, ...)\n  #        stn_sf_14 / stn_sf_05: station sf at 14/05 UTC (features + temp)\n  #        block_size: integer (meters) used by LBO-CV\n  #        params$models: character vector of model names to run\n  # ---------------------------------------------------------------------\n  obj  <- make_fun()\n  scen <- obj$scen\n  st14 <- obj$stn_sf_14\n  st05 <- obj$stn_sf_05\n  bs   <- obj$block_size\n  mods <- obj$params$models\n  \n  # --- Safety checks that catch common wiring issues early ----------------------\n  stopifnot(inherits(st14, \"sf\"), inherits(st05, \"sf\"))\n  stopifnot(all(c(\"E\",\"R14\",\"R05\") %in% names(scen)))\n  \n  # Sun geometry must be present for the R*-tuning (cosine-of-incidence features)\n  if (is.null(scen$sun) || is.null(scen$sun$T14) || is.null(scen$sun$T05)) {\n    stop(\"Scenario did not populate scen$sun$T14 / scen$sun$T05 (alt/az). \",\n         \"Fix in the scenario builder (build_scenario) before tuning.\")\n  }\n  if (any(is.null(c(scen$sun$T14$alt, scen$sun$T14$az,\n                    scen$sun$T05$alt, scen$sun$T05$az)))) {\n    stop(\"Sun angles (alt/az) are NULL. Scenario must supply numeric alt/az for T14/T05.\")\n  }\n  \n  # ---------------------------------------------------------------------\n  # 4) Live preview: plots during the run (no side effects)\n  #    Why plot first?\n  #      - Instant sanity checks: station placement, LC, illumination maps\n  #      - Early visual cues if something is off (e.g., CRS mismatch)\n  # ---------------------------------------------------------------------\n  print(plot_landcover_terrain(scen, stations = st14, layout = \"vertical\"))\n  print(plot_block_overview_2x2_en(scen, pts_sf = st14))\n  # preview_scenario() may show truth fields, histograms, thumbnails, etc.\n  print(preview_scenario(obj))  # accepts obj or obj$scen in the robust version\n  \n    # ---------------------------------------------------------------------\n  # 5) Baseline LBO-CV & prediction maps\n  #    - For each time slice (T14 day / T05 pre-dawn):\n  #      1) Run leave-block-out CV on station data\n  #      2) Produce truth vs predicted raster maps (model ensemble)\n  #    - Diagnostics printed/printed:\n  #      * Metrics table (RMSE/MAE/R2 per model)\n  #      * Blocks plot (spatial CV blocks)\n  #      * Pred-vs-obs scatter plot\n  #      * Truth and prediction maps\n  # ---------------------------------------------------------------------\n  run14 <- run_for_time(st14, scen$R14, \"T14\", scen_local = scen, block_m = bs, models = mods)\n  run05 <- run_for_time(st05, scen$R05, \"T05\", scen_local = scen, block_m = bs, models = mods)\n  \n  cat(\"\\n== Metrics T14 ==\\n\"); print(run14$res$metrics)\n  cat(\"\\n== Metrics T05 ==\\n\"); print(run05$res$metrics)\n  \n  print(run14$res$blocks_plot); print(run14$res$diag_plot)\n  print(run05$res$blocks_plot); print(run05$res$diag_plot)\n  print(run14$maps$p_truth);    print(run14$maps$p_pred)\n  print(run05$maps$p_truth);    print(run05$maps$p_pred)\n  \n  # =====================================================================\n  # 6) SCALE → R* tuning → tuned CV + maps\n  #\n  # Pipeline rationale:\n  #   (a) Variogram reveals correlation ranges in the point field.\n  #   (b) U-curve scans DEM-smoothing radii ~ [L50, L95] to find data-driven R*.\n  #       Each radius implies a different \"macro-signal\" (E*, slope*, cosi*).\n  #       We refit CV at each R and pick the RMSE-minimizer (R*).\n  #   (c) With R* in hand, we derive feature rasters at that scale: E*, slp*, cosi*.\n  #   (d) Re-extract station features at R* to ensure training/prediction consistency.\n  #   (e) Run LBO-CV again (tuned) using E* as the reference raster for blocks/domain.\n  #   (f) Predict tuned maps by injecting the feature rasters.\n  #   (g) Build compact multi-model panels with residual diagnostics.\n  #\n  # Performance tips if tuning feels slow:\n  #   - Reduce n_grid in the U-curve (e.g., 5 instead of 9).\n  #     n_grid sets how many candidate smoothing radii are tested in the U-curve search for R*\n  #   - Trim `mods` to a smaller set while teaching the concept.\n  #   - Increase block size slightly (fewer blocks → fewer CV folds).\n  # =====================================================================\n  \n  # --- (a) Variogram → L50/L95 -------------------------------------------------\n  Ls14 <- compute_Ls_from_points(st14, value_col = \"temp\")\n  Ls05 <- compute_Ls_from_points(st05, value_col = \"temp\")\n  \n  p_vg14 <- plot_variogram_with_scales(Ls14$vg, Ls14$L50, Ls14$L95, Ls14$sill,\n                                       \"T14 — empirical variogram\")\n  p_vg05 <- plot_variogram_with_scales(Ls05$vg, Ls05$L50, Ls05$L95, Ls05$sill,\n                                       \"T05 — empirical variogram\")\n  print(p_vg14); print(p_vg05)\n  \n  # --- (b) U-curve → R* --------------------------------------------------------\n  # We pass *explicit* sun angles so tune_Rstar_ucurve() can build cosi@R\n  # consistently with the scenario's solar geometry.\n  tune14 <- tune_Rstar_ucurve(\n    stn_sf = st14,\n    E      = scen$E,\n    alt    = scen$sun$T14$alt,\n    az     = scen$sun$T14$az,\n    L50    = Ls14$L50,\n    L95    = Ls14$L95,\n    block_fallback = bs,\n    n_grid = 6\n  )\n  \n  tune05 <- tune_Rstar_ucurve(\n    stn_sf = st05,\n    E      = scen$E,\n    alt    = scen$sun$T05$alt,\n    az     = scen$sun$T05$az,\n    L50    = Ls05$L50,\n    L95    = Ls05$L95,\n    block_fallback = bs,\n    n_grid = 6\n  )\n  \n  # Plot the U-curves and report chosen R* (rounded for readability).\n  p_uc14 <- plot_ucurve(tune14$grid, tune14$R_star, \"T14 — U-curve\")\n  p_uc05 <- plot_ucurve(tune05$grid, tune05$R_star, \"T05 — U-curve\")\n  print(p_uc14); print(p_uc05)\n  \n  # IMPORTANT: use %.0f (not %d) because R* is numeric (may be non-integer).\n  message(sprintf(\"Chosen R* — T14: %.0f m | blocks ≈ %d m\", tune14$R_star, tune14$block_m))\n  message(sprintf(\"Chosen R* — T05: %.0f m | blocks ≈ %d m\", tune05$R_star, tune05$block_m))\n  \n  # --- (c) Feature rasters @R* -------------------------------------------------\n  # Smooth DEM at R* and derive slope/incident-cosine given the scenario sun angles.\n  fr14 <- smooth_dem_and_derive(\n    scen$E, scen$sun$T14$alt, scen$sun$T14$az, radius_m = tune14$R_star\n  )\n  fr05 <- smooth_dem_and_derive(\n    scen$E, scen$sun$T05$alt, scen$sun$T05$az, radius_m = tune05$R_star\n  )\n  \n  # --- (d) Station features @R* ------------------------------------------------\n  # Re-extract E*, slope*, cosi* (plus consistent LC factors) at station points.\n  # This keeps training features aligned with the tuned raster features.\n  st14_R <- add_drifts_at_R(\n    st14, scen$E, scen$sun$T14$alt, scen$sun$T14$az, tune14$R_star,\n    lc = scen$lc, lc_levels = scen$lc_levels,\n    na_action = \"fill\"   # or \"drop\" if you prefer to omit affected stations\n  )\n  st05_R <- add_drifts_at_R(\n    st05, scen$E, scen$sun$T05$alt, scen$sun$T05$az, tune05$R_star,\n    lc = scen$lc, lc_levels = scen$lc_levels,\n    na_action = \"fill\"   # or \"drop\" if you prefer to omit affected stations\n  )\n  \n  # --- (e) LBO-CV @R* ----------------------------------------------------------\n  # Use the tuned smoothed DEM (E*) as the reference for CV blocks and domain\n  # geometry so the CV respects the working resolution/scale of the model.\n  bench14 <- run_lbo_cv(st14_R, E = scen$E, block_size = bs, models = mods)\n  bench05 <- run_lbo_cv(st05_R, E = scen$E, block_size = bs, models = mods)\n  print(bench14$metrics); print(bench05$metrics)\n  \n  # --- (f) Tuned maps ----------------------------------------------------------\n  # Inject the tuned feature rasters so model predictions operate at R* scale.\n  maps14_tuned <- predict_maps(\n    stn_sf = st14_R, truth_raster = scen$R14, which_time = \"T14\",\n    scen = scen, models = mods, lc_levels = scen$lc_levels,\n    feature_rasters = list(E = fr14$Es, slp = fr14$slp, cosi = fr14$cosi)\n  )\n  maps05_tuned <- predict_maps(\n    stn_sf = st05_R, truth_raster = scen$R05, which_time = \"T05\",\n    scen = scen, models = mods, lc_levels = scen$lc_levels,\n    feature_rasters = list(E = fr05$Es, slp = fr05$slp, cosi = fr05$cosi)\n  )\n  \n  # --- (g) Panels: truth | predictions | residual diagnostics ------------------\n  panel_T14 <- build_panels_truth_preds_errors_paged(\n    maps = maps14_tuned, truth_raster = scen$R14, cv_tbl = bench14$cv,\n    which_time = \"T14\", models_per_page = 7, scatter_next_to_truth = TRUE\n  )\n  panel_T05 <- build_panels_truth_preds_errors_paged(\n    maps = maps05_tuned, truth_raster = scen$R05, cv_tbl = bench05$cv,\n    which_time = \"T05\", models_per_page = 7, scatter_next_to_truth = TRUE\n  )\n  print(panel_T14[[1]]); print(panel_T05[[1]])\n  \n  \n  # Sensor noise (°C) – from specs or co-location\n  sigma_inst <- 0.5\n  \n  # α from residual variogram (microscale share) – T14 and T05\n  alpha14 <- nugget_fraction_from_cv(bench14$cv, model = \"RF\", crs_ref = st14)\n  alpha05 <- nugget_fraction_from_cv(bench05$cv, model = \"RF\", crs_ref = st05)\n  \n  # Fallbacks if the fit fails\n  if (!is.finite(alpha14)) alpha14 <- 0.6\n  if (!is.finite(alpha05)) alpha05 <- 0.6\n  \n  # Fehlerbudgets berechnen (Base = runXX$res, Tuned = benchXX)\n  eb14_base  <- simple_error_budget(run14$res, sigma_inst, alpha14) |>\n    dplyr::mutate(Time = \"T14\", Mode = \"Base\")\n  eb05_base  <- simple_error_budget(run05$res, sigma_inst, alpha05) |>\n    dplyr::mutate(Time = \"T05\", Mode = \"Base\")\n  eb14_tuned <- simple_error_budget(bench14,   sigma_inst, alpha14) |>\n    dplyr::mutate(Time = \"T14\", Mode = \"Tuned\")\n  eb05_tuned <- simple_error_budget(bench05,   sigma_inst, alpha05) |>\n    dplyr::mutate(Time = \"T05\", Mode = \"Tuned\")\n  \n  eb_all <- dplyr::bind_rows(eb14_base, eb05_base, eb14_tuned, eb05_tuned) |>\n    dplyr::relocate(Time, Mode)\n  \n  print(eb_all)\n  \n  # einfache Stacked-Bar-Plot-Funktion\n  plot_error_budget <- function(df) {\n    d <- df |>\n      dplyr::filter(Component %in% c(\"Instrument var\",\"Microscale var\",\"Mesoscale var\"))\n    ggplot2::ggplot(d,\n                    ggplot2::aes(x = interaction(Time, Mode, sep = \" \"), y = Value, fill = Component)\n    ) +\n      ggplot2::geom_col(position = \"stack\") +\n      ggplot2::theme_minimal() +\n      ggplot2::labs(x = NULL, y = \"Variance (°C²)\", title = \"Error budget by time & mode\")\n  }\n  p_eb <- plot_error_budget(eb_all)\n  print(p_eb)\n  # =====================================================================\n  # 7) Optional: save everything at the end (plots + tables + rasters)\n  #    - Change `export <- FALSE` at the top to only run/plot interactively\n  #    - We wrap saves in try() so a single failed save does not abort the run.\n  # =====================================================================\n  if (export) {\n    # ---------- Ausgabe-Verzeichnis: results_<scen-name> ----------\n    out_root <- here::here(\"block4_5\")\n    out_dir  <- file.path(out_root, sprintf(\"results_%s\", scen_name))\n    fig_dir  <- file.path(out_dir, \"fig\")\n    tab_dir  <- file.path(out_dir, \"tab\")\n    ras_dir  <- file.path(out_dir, \"ras\")\n    # ohne Rückfrage, rekursiv, ohne Warnungen\n    dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)\n    dir.create(tab_dir, recursive = TRUE, showWarnings = FALSE)\n    dir.create(ras_dir, recursive = TRUE, showWarnings = FALSE)\n    \n  \n    \n    # ---------- Baseline: Previews & CV-Plots ----------------------\n    save_plot_min(plot_landcover_terrain(scen, stations = st14, layout = \"vertical\"),\n                  fn_fig(\"landcover_terrain\"))\n    save_plot_min(plot_block_overview_2x2_en(scen, pts_sf = st14), fn_fig(\"overview_2x2\"))\n    save_plot_min(run14$res$blocks_plot, fn_fig(\"T14_blocks\"))\n    save_plot_min(run14$res$diag_plot,   fn_fig(\"T14_diag\"))\n    save_plot_min(run05$res$blocks_plot, fn_fig(\"T05_blocks\"))\n    save_plot_min(run05$res$diag_plot,   fn_fig(\"T05_diag\"))\n    save_plot_min(run14$maps$p_truth,    fn_fig(\"T14_truth\"))\n    save_plot_min(run14$maps$p_pred,     fn_fig(\"T14_pred\"))\n    save_plot_min(run05$maps$p_truth,    fn_fig(\"T05_truth\"))\n    save_plot_min(run05$maps$p_pred,     fn_fig(\"T05_pred\"))\n    \n    # --- Tuned Panels ---\n    save_plot_min(panel_T14[[1]], fn_fig(\"T14_panel_tuned\"))\n    save_plot_min(panel_T05[[1]], fn_fig(\"T05_panel_tuned\"))\n    \n    # --- Raster ---\n    save_raster_min(scen$E,   fn_ras(\"E_dem\"))\n    save_raster_min(scen$R14, fn_ras(\"R14_truth\"))\n    save_raster_min(scen$R05, fn_ras(\"R05_truth\"))\n    if (\"lc\" %in% names(scen)) save_raster_min(scen$lc, fn_ras(\"landcover\"))\n    # ---------- Scale inference + tuned panels ----------------------\n    safe_save_plot(p_vg14, fn_fig(\"T14_variogram\"))\n    safe_save_plot(p_vg05, fn_fig(\"T05_variogram\"))\n    safe_save_plot(p_uc14, fn_fig(\"T14_ucurve\"))\n    safe_save_plot(p_uc05, fn_fig(\"T05_ucurve\"))\n    safe_save_plot(panel_T14[[1]], fn_fig(\"T14_panel_tuned\"))\n    safe_save_plot(panel_T05[[1]], fn_fig(\"T05_panel_tuned\"))\n    \n    save_table_readable(bench14$metrics, \"metrics_T14_tuned\", \"Tuned metrics — T14\")\n    save_table_readable(bench05$metrics, \"metrics_T05_tuned\", \"Tuned metrics — T05\")\n    save_table_readable(tune14$grid,     \"Ucurve_T14\",       \"U-curve grid — T14\")\n    save_table_readable(tune05$grid,     \"Ucurve_T05\",       \"U-curve grid — T05\")\n    save_table_readable(data.frame(L50 = Ls14$L50, L95 = Ls14$L95, R_star = tune14$R_star),\n                        \"scales_T14\", \"Scales — T14 (L50/L95/R*)\")\n    save_table_readable(data.frame(L50 = Ls05$L50, L95 = Ls05$L95, R_star = tune05$R_star),\n                        \"scales_T05\", \"Scales — T05 (L50/L95/R*)\")\n    save_table_readable(run14$res$metrics, file.path(tab_dir, sprintf(\"metrics_T14_%s\", scen_name)))\n    save_table_readable(run05$res$metrics, file.path(tab_dir, sprintf(\"metrics_T05_%s\", scen_name)))\n    save_table_readable(bench14$metrics,   file.path(tab_dir, sprintf(\"metrics_T14_tuned_%s\", scen_name)))\n    save_table_readable(bench05$metrics,   file.path(tab_dir, sprintf(\"metrics_T05_tuned_%s\", scen_name)))\n    save_table_readable(eb_all,            file.path(tab_dir, sprintf(\"error_budget_%s\", scen_name)))\n    #\n    # ---------- Raster mit Szenario-Präfix --------------------------\n    try(terra::writeRaster(scen$E,   fn_ras(\"E_dem\")),     silent = TRUE)\n    try(terra::writeRaster(scen$R14, fn_ras(\"R14_truth\")), silent = TRUE)\n    try(terra::writeRaster(scen$R05, fn_ras(\"R05_truth\")), silent = TRUE)\n    if (\"lc\" %in% names(scen))\n      try(terra::writeRaster(scen$lc, fn_ras(\"landcover\")), silent = TRUE)\n    \n    # ---------- Sessioninfo -----------------------------------------\n    try(saveRDS(sessionInfo(), file.path(out_dir, sprintf(\"%s_sessionInfo.rds\", scen_name))),\n        silent = TRUE)\n    \n    message(\"✔ Exports written to: \", normalizePath(out_dir, winslash = \"/\"))\n  }\n```\n````\n:::\n\n\n\n2.  **Helpers / Core library:**\n\n    -   `packages.R`: centralized package loading and global run options\n        (e.g., `sf_use_s2(FALSE)`, seeds).\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\n# --- Paketliste an EINER Stelle pflegen ---------------------------------\n.req_pkgs <- list(\n  core      = c(\"terra\",\"sf\",\"suncalc\",\"gstat\"),\n  modeling  = c(\"randomForest\",\"mgcv\"),\n  wrangling = c(\"dplyr\",\"tibble\",\"tidyr\"),\n  viz       = c(\"ggplot2\",\"scales\",\"patchwork\",\"RColorBrewer\"),\n  report    = c(\"knitr\",\"kableExtra\",\"here\",\"zoo\", \"gt\", \"openxlsx\", \"writexl\")\n\n)\n\nensure_packages <- function(pkgs = unlist(.req_pkgs)) {\n  inst <- rownames(installed.packages())\n  missing <- setdiff(pkgs, inst)\n  if (length(missing)) install.packages(missing, dependencies = TRUE)\n  invisible(lapply(pkgs, require, character.only = TRUE))\n}\n\nafter_load <- function() {\n  if (requireNamespace(\"sf\", quietly = TRUE)) sf::sf_use_s2(FALSE)  # wie bisher\n}\n\n# Aufruf:\nensure_packages()\nafter_load()\n\n# ---- Pfade ------------------------------------------------------------\nbase_dir <- tryCatch(here::here(), error = function(e) getwd())\nsrc_dir  <- file.path(base_dir, \"block4_5\", \"src\")\nout_dir  <- file.path(base_dir, \"block4_5\", \"exports\")\nfig_dir  <- file.path(out_dir, \"figs\")\ntab_dir  <- file.path(out_dir, \"tables\")\nras_dir  <- file.path(out_dir, \"rasters\")\ndat_dir  <- file.path(out_dir, \"data\")\n\ndir.create(out_dir, showWarnings = FALSE, recursive = TRUE)\nfor (d in c(fig_dir, tab_dir, ras_dir, dat_dir)) dir.create(d, showWarnings = FALSE, recursive = TRUE)\n```\n````\n:::\n\n\n    -   `fun_pipemodel.R`: domain modeling utilities (plots, feature\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n        derivation, variogram utilities, U-curve tuning, panels, saving\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n        helpers).\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\n\n## ======================================================================\n## pipemodel_functions.R  —  nur Funktionen, keine Seiteneffekte\n## ======================================================================\n# ========================= I/O helpers (tables & plots) ======================\n\n\n# ---- Export-Helper (einfügen NACH out_dir/fig_dir/tab_dir/ras_dir) ----\nfn_fig <- function(stem, ext = \"png\") file.path(fig_dir, sprintf(\"%s.%s\", stem, ext))\nfn_ras <- function(stem, ext = \"tif\") file.path(ras_dir, sprintf(\"%s.%s\", stem, ext))\n\nsave_plot_min <- function(p, file, width = 9, height = 6, dpi = 150, bg = \"white\") {\n  # Speichert ggplot ODER \"druckbare\" Plot-Objekte\n  dir.create(dirname(file), recursive = TRUE, showWarnings = FALSE)\n  if (inherits(p, \"ggplot\")) {\n    ggplot2::ggsave(filename = file, plot = p, width = width, height = height, dpi = dpi, bg = bg)\n  } else {\n    grDevices::png(filename = file, width = width, height = height, units = \"in\", res = dpi, bg = bg)\n    print(p)\n    grDevices::dev.off()\n  }\n  invisible(normalizePath(file, winslash = \"/\"))\n}\n\nsafe_save_plot <- function(p, file, width = 9, height = 6, dpi = 150, bg = \"white\") {\n  try(save_plot_min(p, file, width, height, dpi, bg), silent = TRUE)\n}\n\nsave_raster_min <- function(r, file, overwrite = TRUE) {\n  dir.create(dirname(file), recursive = TRUE, showWarnings = FALSE)\n  terra::writeRaster(r, file, overwrite = overwrite)\n  invisible(normalizePath(file, winslash = \"/\"))\n}\n\n\n# Save a table in CSV (+ optional HTML via gt, XLSX via openxlsx/writexl)\n# Robust to tibbles, list cols (ignored), and mistaken positional args.\n# Save a table as CSV (always), HTML (if gt is installed), and XLSX\n# file_stem: full path without extension, e.g. fn_tab(\"metrics_T14_base\")\nsave_table_readable <- function(df, file_stem,\n                                title = NULL,\n                                digits = 3,\n                                make_dirs = TRUE,\n                                verbose = FALSE) {\n  if (!inherits(df, \"data.frame\")) df <- as.data.frame(df)\n  \n  # Drop list-cols so write.csv/openxlsx don't choke\n  is_listcol <- vapply(df, is.list, logical(1))\n  if (any(is_listcol)) df <- df[ , !is_listcol, drop = FALSE]\n  \n  if (isTRUE(make_dirs)) dir.create(dirname(file_stem), showWarnings = FALSE, recursive = TRUE)\n  \n  # Round numeric columns safely\n  numcols <- vapply(df, is.numeric, TRUE)\n  if (any(numcols)) {\n    for (nm in names(df)[numcols]) df[[nm]] <- round(df[[nm]], digits)\n  }\n  \n  paths <- list()\n  \n  ## CSV\n  csv_path <- paste0(file_stem, \".csv\")\n  utils::write.csv(df, csv_path, row.names = FALSE)\n  paths$csv <- csv_path\n  \n  ## HTML via gt (optional)\n  if (requireNamespace(\"gt\", quietly = TRUE)) {\n    gt_tbl <- gt::gt(df)\n    if (!is.null(title)) gt_tbl <- gt::tab_header(gt_tbl, title = title)\n    gt::gtsave(gt_tbl, paste0(file_stem, \".html\"))\n    paths$html <- paste0(file_stem, \".html\")\n  } else if (verbose) {\n    message(\"[save_table_readable] Package 'gt' not installed → skipping HTML.\")\n  }\n  \n  ## XLSX via openxlsx (preferred) or writexl (fallback)\n  xlsx_path <- paste0(file_stem, \".xlsx\")\n  if (requireNamespace(\"openxlsx\", quietly = TRUE)) {\n    wb <- openxlsx::createWorkbook()\n    openxlsx::addWorksheet(wb, \"table\")\n    \n    # Optional title in A1, style it a bit\n    start_row <- 1L\n    if (!is.null(title)) {\n      openxlsx::writeData(wb, \"table\", title, startRow = start_row, startCol = 1)\n      # bold, bigger font for title\n      st <- openxlsx::createStyle(textDecoration = \"bold\", fontSize = 14)\n      openxlsx::addStyle(wb, \"table\", st, rows = start_row, cols = 1, gridExpand = TRUE, stack = TRUE)\n      start_row <- start_row + 2L  # blank row after title\n    }\n    \n    openxlsx::writeData(wb, \"table\", df, startRow = start_row, startCol = 1)\n    openxlsx::saveWorkbook(wb, xlsx_path, overwrite = TRUE)\n    paths$xlsx <- xlsx_path\n  } else if (requireNamespace(\"writexl\", quietly = TRUE)) {\n    writexl::write_xlsx(df, xlsx_path)\n    paths$xlsx <- xlsx_path\n  } else if (verbose) {\n    message(\"[save_table_readable] Neither 'openxlsx' nor 'writexl' installed → skipping XLSX.\")\n  }\n  \n  invisible(paths)\n}\n\n\n\n#' Save a ggplot/patchwork safely (no-op if not a plot)\n#'\n#' @param p A ggplot/patchwork object.\n#' @param file Output path (with extension, e.g. \\code{.png}).\n#' @param width,height Figure size in inches.\n#' @param dpi Resolution in dots per inch.\n#' @param bg Background color (default \\code{\"white\"}).\n#' @keywords io export plot\nsave_plot_safe <- function(p, file, width = 9, height = 6, dpi = 300, bg = \"white\") {\n  if (inherits(p, c(\"gg\", \"ggplot\", \"patchwork\"))) {\n    dir.create(dirname(file), showWarnings = FALSE, recursive = TRUE)\n    try(ggplot2::ggsave(file, p, width = width, height = height, dpi = dpi, bg = bg),\n        silent = TRUE)\n  }\n}\n# =============================================================================\n\norder_models_by_median_rmse <- function(cv_tbl) {\n  bm <- block_metrics_long(cv_tbl)\n  bm |>\n    dplyr::filter(Metric == \"RMSE\") |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(Value, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n}\n\n# Block-wise metrics (RMSE, MAE)\nblock_metrics_long <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"block_id\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  cv_tbl |>\n    dplyr::group_by(model, block_id) |>\n    dplyr::summarise(\n      RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)),\n      MAE  = mean(abs(obs - pred), na.rm = TRUE),\n      .groups = \"drop\"\n    ) |>\n    tidyr::pivot_longer(c(RMSE, MAE), names_to = \"Metric\", values_to = \"Value\")\n}\nmake_block_metric_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  bm <- block_metrics_long(cv_tbl) |>\n    dplyr::filter(is.finite(Value))\n  if (!is.null(tail_cap)) {\n    ymax <- stats::quantile(bm$Value, tail_cap, na.rm = TRUE)\n  }\n  lev <- order_models_by_median_rmse(cv_tbl)\n  bm$model <- factor(bm$model, levels = lev)\n  \n  ggplot2::ggplot(bm, ggplot2::aes(model, Value)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.35, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Block-wise errors (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"Error\") +\n    ggplot2::facet_wrap(~ Metric, scales = \"free_y\")\n}\n\nmake_abs_error_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  df <- cv_tbl |>\n    dplyr::mutate(abs_err = abs(pred - obs)) |>\n    dplyr::filter(is.finite(abs_err))\n  ymax <- if (!is.null(tail_cap)) stats::quantile(df$abs_err, tail_cap, na.rm = TRUE) else max(df$abs_err, na.rm = TRUE)\n  lev <- df |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(abs_err, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n  df$model <- factor(df$model, levels = lev)\n  \n  ggplot2::ggplot(df, ggplot2::aes(model, abs_err)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.3, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Absolute errors per station (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"|pred − obs|\")\n}\n\n\nmake_obs_pred_scatter <- function(cv_tbl, which_time = \"T14\") {\n  lab <- .make_labeller(cv_tbl)\n  ggplot(cv_tbl, aes(obs, pred)) +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    geom_point(alpha = 0.7, shape = 16) +\n    coord_equal() + theme_minimal() +\n    labs(title = sprintf(\"%s — Observed vs Predicted (LBO-CV)\", which_time), x = \"Observed\", y = \"Predicted\") +\n    facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n}\n\nmake_residual_density <- function(cv_tbl, which_time = \"T14\") {\n  cv_tbl |> dplyr::mutate(resid = pred - obs) |> ggplot2::ggplot(ggplot2::aes(resid, fill = model)) +\n    ggplot2::geom_density(alpha = 0.4) + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Residual density\", which_time), x = \"Residual (°C)\", y = \"Density\")\n}\n\n# Prediction maps & error panels ---------------------------------------\n.make_labeller <- function(cv_tbl) {\n  m <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE  = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\")\n  setNames(sprintf(\"%s  (RMSE=%.2f · MAE=%.2f)\", m$model, m$RMSE, m$MAE), m$model)\n}\n.plot_raster_gg <- function(r, title = \"\", palette = temp_palette, q = c(0.02,0.98), lims = NULL) {\n  stopifnot(terra::nlyr(r) == 1)\n  df <- as.data.frame(r, xy = TRUE, na.rm = FALSE)\n  nm <- names(df)[3]\n  if (is.null(lims)) {\n    vv <- terra::values(r, na.rm = TRUE)\n    lims <- stats::quantile(vv, probs = q, na.rm = TRUE, names = FALSE)\n  }\n  ggplot2::ggplot(df, ggplot2::aes(.data$x, .data$y, fill = .data[[nm]])) +\n    ggplot2::geom_raster() +\n    ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = palette, limits = lims, oob = scales::squish) +\n    ggplot2::labs(title = title, x = NULL, y = NULL, fill = \"°C\") +\n    ggplot2::theme_minimal(base_size = 11) +\n    ggplot2::theme(legend.position = \"right\",\n                   plot.title = ggplot2::element_text(face = \"bold\"))\n}\n\n.get_preds_from_maps <- function(maps) {\n  # 1) SpatRaster direkt\n  if (inherits(maps, \"SpatRaster\")) {\n    ul <- terra::unstack(maps)\n    names(ul) <- names(maps)\n    return(ul)\n  }\n  # 2) Liste mit typischen Feldern\n  if (is.list(maps)) {\n    if (!is.null(maps$preds))          return(maps$preds)\n    if (!is.null(maps$pred_rasters))   return(maps$pred_rasters)\n    if (!is.null(maps$pred_stack) && inherits(maps$pred_stack, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$pred_stack); names(ul) <- names(maps$pred_stack); return(ul)\n    }\n    if (!is.null(maps$stack) && inherits(maps$stack, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$stack); names(ul) <- names(maps$stack); return(ul)\n    }\n    if (!is.null(maps$maps) && inherits(maps$maps, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$maps); names(ul) <- names(maps$maps); return(ul)\n    }\n    # 3) Liste, die bereits einzelne SpatRaster oder ggplots enthält\n    cand <- maps[ vapply(maps, function(x) inherits(x, \"SpatRaster\") || inherits(x, \"ggplot\"), logical(1)) ]\n    if (length(cand) > 0) return(cand)\n  }\n  stop(\"build_panels_with_errors(): In 'maps' keine Vorhersagen gefunden.\")\n}\n# --- Kartenplot mit optionalen Achsenticks/labels ----------------------\n.plot_map_axes <- function(r, title, cols, lims, q = c(0.02,0.98),\n                           base_size = 14, tick_n = 5,\n                           show_axis_labels = FALSE, show_axis_ticks = TRUE) {\n  stopifnot(terra::nlyr(r) == 1)\n  df <- as.data.frame(r, xy = TRUE, na.rm = FALSE)\n  nm <- names(df)[3]\n  \n  if (is.null(lims) || !all(is.finite(lims)) || lims[1] >= lims[2]) {\n    vv <- terra::values(r, na.rm = TRUE)\n    lims <- stats::quantile(vv, probs = q, na.rm = TRUE, names = FALSE)\n    if (!all(is.finite(lims)) || lims[1] == lims[2]) lims <- range(vv, na.rm = TRUE) + c(-1e-6, 1e-6)\n  }\n  if (is.function(cols)) cols <- cols(256)\n  if (!is.atomic(cols) || length(cols) < 2) cols <- grDevices::hcl.colors(256, \"YlOrRd\")\n  \n  ggplot2::ggplot(df, ggplot2::aes(x, y, fill = .data[[nm]])) +\n    ggplot2::geom_raster() +\n    ggplot2::coord_equal(expand = FALSE) +\n    ggplot2::scale_x_continuous(expand = c(0,0), breaks = scales::breaks_pretty(n = tick_n)) +\n    ggplot2::scale_y_continuous(expand = c(0,0), breaks = scales::breaks_pretty(n = tick_n)) +\n    ggplot2::scale_fill_gradientn(colours = cols, limits = lims, oob = scales::squish) +\n    ggplot2::labs(title = title, x = NULL, y = NULL, fill = \"°C\") +\n    ggplot2::theme_minimal(base_size = base_size) +\n    ggplot2::theme(\n      legend.position = \"right\",\n      plot.title = ggplot2::element_text(face = \"bold\"),\n      axis.title   = ggplot2::element_blank(),\n      axis.text    = if (show_axis_labels) ggplot2::element_text(size = base_size - 3) else ggplot2::element_blank(),\n      axis.ticks   = if (show_axis_ticks)  ggplot2::element_line(linewidth = 0.25) else ggplot2::element_blank(),\n      panel.border = ggplot2::element_rect(fill = NA, colour = \"grey40\", linewidth = .4)\n    )\n}\nbuild_panels_truth_preds_errors_paged <- function(\n    maps, truth_raster, cv_tbl, which_time,\n    models_per_page = 4,\n    model_order      = NULL,\n    temp_pal         = temp_palette,     # Vektor ODER Funktion -> wird zu Vektor\n    stretch_q        = c(0.02, 0.98),\n    errors_height    = 1.2,\n    scatter_next_to_truth = TRUE,        # Scatter rechts von Truth?\n    top_widths       = c(1.1, 0.9),      # Breitenverhältnis Truth | Scatter\n    show_second_legend = FALSE           # zweite °C-Legende bei den Preds unterdrücken\n) {\n  stopifnot(length(stretch_q) == 2)\n  if (is.function(temp_pal)) temp_pal <- temp_pal(256)\n  stopifnot(is.atomic(temp_pal), length(temp_pal) >= 2)\n  \n  # Vorhersagen einsammeln / Reihenfolge\n  preds_raw  <- .get_preds_from_maps(maps)\n  pred_names <- names(preds_raw) %||% paste0(\"model_\", seq_along(preds_raw))\n  if (!is.null(model_order)) {\n    keep <- intersect(model_order, pred_names)\n    if (!length(keep)) stop(\"model_order enthält keine gültigen Modellnamen.\")\n    preds_raw  <- preds_raw[keep]\n    pred_names <- keep\n  }\n  \n  # Gemeinsame Farbskala\n  all_vals <- c(terra::values(truth_raster, na.rm = TRUE))\n  for (p in preds_raw) if (inherits(p, \"SpatRaster\")) all_vals <- c(all_vals, terra::values(p, na.rm = TRUE))\n  lims <- stats::quantile(all_vals, probs = stretch_q, na.rm = TRUE, names = FALSE)\n  if (all(is.finite(lims)) && lims[1] == lims[2]) {\n    eps <- .Machine$double.eps * max(1, abs(lims[1])); lims <- lims + c(-eps, eps)\n  }\n  \n  # Helfer: Raster -> ggplot\n  make_tile <- function(obj, title_txt, show_legend = TRUE) {\n    if (inherits(obj, \"SpatRaster\")) {\n      g <- .plot_raster_gg(obj, title = title_txt, palette = temp_pal, q = stretch_q, lims = lims)\n      if (!show_legend) g <- g + ggplot2::theme(legend.position = \"none\")\n      g\n    } else if (inherits(obj, \"ggplot\")) {\n      obj + ggplot2::labs(title = title_txt)\n    } else stop(\"Nicht unterstützter Prediction-Typ: \", class(obj)[1])\n  }\n  \n  # Truth (+ optional Scatter daneben)\n  p_truth   <- .plot_raster_gg(truth_raster, title = paste0(which_time, \" — truth\"),\n                               palette = temp_pal, q = stretch_q, lims = lims)\n  p_scatter <- make_obs_pred_scatter(cv_tbl, which_time = which_time)\n  \n  # Prediction-Kacheln bauen (nur erste mit °C-Legende falls gewünscht)\n  pred_tiles <- lapply(seq_along(preds_raw), function(i) {\n    show_leg <- if (isTRUE(show_second_legend)) TRUE else (i == 1L)\n    make_tile(preds_raw[[i]], pred_names[i], show_legend = show_leg)\n  })\n  \n  # Paginierung\n  n <- length(pred_tiles)\n  idx_split <- split(seq_len(n), ceiling(seq_len(n) / models_per_page))\n  \n  pages <- lapply(idx_split, function(idx) {\n    preds_row <- patchwork::wrap_plots(pred_tiles[idx], nrow = 1, ncol = length(idx))\n    \n    top_row <- if (isTRUE(scatter_next_to_truth)) {\n      (p_truth | (p_scatter + ggplot2::theme(legend.position = \"none\"))) +\n        patchwork::plot_layout(widths = top_widths)\n    } else {\n      p_truth\n    }\n    \n    # Errors unten: wenn Scatter schon oben, unten nur Dichte\n    p_box_rmse <- make_block_metric_box(cv_tbl, which_time = which_time, tail_cap = 0.995)\n    p_box_ae   <- make_abs_error_box  (cv_tbl, which_time = which_time, tail_cap = 0.995)\n    p_dens     <- make_residual_density(cv_tbl, which_time = which_time)\n    p_errors   <- (p_box_rmse | p_box_ae) / p_dens\n    \n    (top_row / preds_row / p_errors) +\n      patchwork::plot_layout(heights = c(1, 1, errors_height), guides = \"collect\") &\n      ggplot2::theme(legend.position = \"right\")\n  })\n  \n  pages\n}\n.pm_verbose <- function(v = NULL) {\n  if (!is.null(v)) return(isTRUE(v))\n  isTRUE(getOption(\"pipemodel.verbose\", FALSE))\n}\npm_say <- function(fmt, ..., v = NULL) {\n  if (.pm_verbose(v)) message(sprintf(fmt, ...))\n}\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.kcap_unique <- function(x, kmax) {\n  ux <- unique(x[is.finite(x)])\n  nu <- length(ux)\n  if (nu <= 3) return(0L)                # treat as constant/near-constant\n  max(4L, min(kmax, nu - 1L))\n}\n\n`%||%` <- function(a, b) if (!is.null(a)) a else b\n# --- Sun helper (self-contained in the lib) --------------------------\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  list(\n    alt = sp$altitude,\n    az  = (sp$azimuth + pi) %% (2*pi)  # convert to [0, 2π) from north\n  )\n}\n\n# Sun helper: pull sun14/sun05 from scen; else compute; else fallback\n.get_sun <- function(scen, which = c(\"T14\",\"T05\")) {\n  which <- match.arg(which)\n  key   <- if (which == \"T14\") \"sun14\" else \"sun05\"\n  \n  # 1) stored in scen?\n  s <- scen[[key]]\n  if (is.list(s) && is.finite(s$alt) && is.finite(s$az)) return(s)\n  \n  # 2) compute from lat/lon/sun_date if available\n  if (all(c(\"lat\",\"lon\",\"sun_date\") %in% names(scen))) {\n    hour <- if (which == \"T14\") 14L else 5L\n    return(sun_pos_utc(scen$sun_date, hour, scen$lat, scen$lon))\n  }\n  \n  # 3) hard fallback\n  list(alt = if (which == \"T14\") 0.75 else 0.10, az = 0.0)\n}\n\n# -------------------------- Defaults -----------------------------------\nlc_levels_default <- c(\"forest\",\"water\",\"bare soil\",\"meadows\")\nlc_levels <- getOption(\"pipemodel.lc_levels\", lc_levels_default)\n\nlc_colors_default <- c(\n  \"forest\"   = \"#2E8B57\",\n  \"water\"    = \"#5DADE2\",\n  \"bare soil\"= \"#C49A6C\",\n  \"meadows\"  = \"#7FBF7B\"\n)\ntemp_palette <- grDevices::colorRampPalette(c(\"#0000FF\",\"#FF0000\"))\nstretch_q    <- c(0.02, 0.98)\n# Normalize any CRS input to a non-empty character string\nnorm_crs <- function(crs, fallback = \"EPSG:32632\") {\n  # allow sf::crs, numeric EPSG, character EPSG/WKT\n  if (inherits(crs, \"crs\")) {\n    out <- sf::st_crs(crs)$wkt\n  } else if (is.numeric(crs) && length(crs) == 1 && is.finite(crs)) {\n    out <- sprintf(\"EPSG:%d\", as.integer(crs))\n  } else if (is.character(crs) && length(crs) >= 1) {\n    out <- crs[1]\n  } else {\n    out <- NA_character_\n  }\n  if (!length(out) || is.na(out) || identical(out, \"\")) out <- fallback\n  out\n}\n\n# -------------------------- Domain/Template -----------------------------\nmake_domain <- function(center_E, center_N, len_x, len_y, res, crs = \"EPSG:32632\") {\n  crs <- norm_crs(crs)\n  ext <- terra::ext(center_E - len_x/2, center_E + len_x/2,\n                    center_N - len_y/2, center_N + len_y/2)\n  Rtemplate <- terra::rast(ext, resolution = res, crs = crs)\n  list(\n    xmin = terra::xmin(ext), xmax = terra::xmax(ext),\n    ymin = terra::ymin(ext), ymax = terra::ymax(ext),\n    x0 = center_E, y0 = center_N,\n    res = as.numeric(res), crs = crs,\n    Rtemplate = Rtemplate\n  )\n}\n\n\ncompute_block_size <- function(len_x, len_y, n_st,\n                               target_st_per_block = 3,\n                               min_blocks_axis = 3,\n                               round_to = 50) {\n  area <- len_x * len_y\n  B_target <- max(min_blocks_axis^2, round(n_st / target_st_per_block))\n  bs <- sqrt(area / B_target)\n  bs <- min(bs, len_x / min_blocks_axis, len_y / min_blocks_axis)\n  bs <- max(round_to, round(bs / round_to) * round_to)\n  as.integer(bs)\n}\n\n# -------------------------- Sonne/Geometrie -----------------------------\n\n# Cosine of incidence on a slope/aspect for a given sun (radians)\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n\n# Sun position at a given UTC date + hour (numeric hour), return radians\nsun_pos_utc <- function(sun_date, hour_utc, lat, lon) {\n  stopifnot(inherits(sun_date, \"Date\"), length(hour_utc) == 1)\n  t  <- as.POSIXct(sprintf(\"%s %02d:00:00\", format(sun_date, \"%Y-%m-%d\"), as.integer(hour_utc)), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  list(\n    alt = as.numeric(sp$altitude),                   # radians\n    az  = as.numeric((sp$azimuth + pi) %% (2*pi))    # convert to [0..2π) from north\n  )\n}\n\n\n# -------------------------- Rauschen ------------------------------------\nmake_noise_pair <- function(template, sd14 = 0.3, sd05 = 0.3,\n                            seed14 = 1001, seed05 = 1002) {\n  set.seed(seed14)\n  n14 <- terra::setValues(terra::rast(template), rnorm(terra::ncell(template), 0, sd14))\n  set.seed(seed05)\n  n05 <- terra::setValues(terra::rast(template), rnorm(terra::ncell(template), 0, sd05))\n  list(noise14 = n14, noise05 = n05)\n}\n\n# -------------------------- Topographie ---------------------------------\nbuild_topography <- function(domain,\n                             lake_mode = c(\"none\",\"water\",\"hollow\"),\n                             hill_mode = c(\"none\",\"bump\"),\n                             lake_diam_m  = 50,  lake_depth_m = 10, smooth_edges = FALSE,\n                             hill_diam_m  = 80,  hill_height_m = 50, hill_smooth  = FALSE) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n  Rtemplate <- domain$Rtemplate\n  x0 <- domain$x0; y0 <- domain$y0\n  xmin <- domain$xmin; xmax <- domain$xmax\n  len_x <- xmax - xmin; y_hc <- y0\n  x_hc <- xmin + len_x/3; x_lc <- xmin + 2*len_x/3; y_lc <- y0\n  \n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate)))\n  names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / (( (domain$ymax - domain$ymin)/2 )^2)\n  elev <- 500 + a * dy^2\n  \n  # See/Grube\n  rl <- sqrt((XY$x - x_lc)^2 + (XY$y - y_lc)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n  \n  # Haupt-Hügel\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hc)^2 + (XY$y - y_hc)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h <- if (hill_smooth) exp(-(rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else w_h <- 0\n  \n  E <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW <- Rtemplate; terra::values(hillW) <- w_h; names(hillW) <- \"hillW\"\n  \n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  \n  list(E = E, lake = lakeR, hillW = hillW,\n       slp = terra::ifel(is.na(slp), 0, slp),\n       asp = terra::ifel(is.na(asp), 0, asp))\n}\n# --- Sun helpers (UTC) -------------------------------------------------\nsun_pos_utc <- function(date, hour, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%s %02d:00:00\", as.Date(date), hour), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  # Azimut: 0 = Nord, positiv im Uhrzeigersinn\n  list(alt = sp$altitude, az = (sp$azimuth + pi) %% (2*pi))\n}\n\n# -------------------------- Physikfelder --------------------------------\nbuild_physics_fields <- function(topography, landcover,\n                                 noise14, noise05,\n                                 alpha_I_by_lc = c(\"forest\" = 3.5, \"water\" = 1.5, \"bare soil\" = 6.0, \"meadows\" = 4.0),\n                                 shade_fac_by_lc = c(\"forest\" = 0.60, \"water\" = 1.00, \"bare soil\" = 1.00, \"meadows\" = 0.95),\n                                 dawn_bias_by_lc = c(\"forest\" = 0.30, \"water\" = 1.20, \"bare soil\" = -0.50, \"meadows\" = 0.05),\n                                 pool_fac_by_lc  = c(\"forest\" = 0.70, \"water\" = 0.80, \"bare soil\" = 1.10, \"meadows\" = 1.05),\n                                 pool_block_gain = 0.4,\n                                 sun14 = list(alt = 0.75, az = 0.0),\n                                 sun05 = list(alt = 0.10, az = 0.0))\n                                 {\n  E    <- topography$E\n  slp0 <- topography$slp\n  asp0 <- topography$asp\n  hillW<- topography$hillW\n  \n  # Sonnen-Inzidenz\n  I14 <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05 <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n  \n  lc <- if (inherits(landcover, \"SpatRaster\")) landcover else landcover$lc\n  stopifnot(inherits(lc, \"SpatRaster\"))\n  \n  v <- as.integer(terra::values(lc))\n  v[!is.finite(v)] <- 1L\n  v <- pmax(1L, pmin(v, length(lc_levels_default)))\n  lc_char <- factor(lc_levels_default[v], levels = lc_levels_default)\n  \n  to_r <- function(x) terra::setValues(terra::rast(E), x)\n  alpha_I <- to_r(as.numeric(alpha_I_by_lc[lc_char]))\n  shade_f <- to_r(as.numeric(shade_fac_by_lc[lc_char]))\n  dawn_b  <- to_r(as.numeric(dawn_bias_by_lc[lc_char]))\n  pool_f  <- to_r(as.numeric(pool_fac_by_lc[lc_char]))\n  \n  I14_eff <- I14 * shade_f\n  \n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\")\n  dist2ax <- abs(Y - (terra::ymax(E)+terra::ymin(E))/2)\n  w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool_mod  <- pool_base * (1 - pool_block_gain * hillW) * pool_f\n  \n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_I * I14_eff + noise14; names(R14) <- \"T14\"\n  \n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool_mod + dawn_b + noise05; names(R05) <- \"T05\"\n  \n  list(R14 = R14, R05 = R05, I14 = I14, I05 = I05)\n}\n\n# --- Sun + cos(i) helpers (safe to keep once in your lib) --------------------\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n\nsun_pos_utc <- function(sun_date, hour_utc, lat, lon) {\n  stopifnot(inherits(sun_date, \"Date\"))\n  t  <- as.POSIXct(sprintf(\"%s %02d:00:00\",\n                           format(sun_date, \"%Y-%m-%d\"),\n                           as.integer(hour_utc)), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  list(\n    alt = as.numeric(sp$altitude),                  # radians\n    az  = as.numeric((sp$azimuth + pi) %% (2*pi))   # [0..2π) from north\n  )\n}\n\nbuild_scenario <- function(\n    domain,\n    lake_mode = c(\"none\",\"water\",\"hollow\"),\n    hill_mode = c(\"none\",\"bump\"),\n    # main hill / lake geometry (meters)\n    lake_diam_m  = 50,  lake_depth_m = 10, smooth_edges = FALSE,\n    hill_diam_m  = 80,  hill_height_m = 50, hill_smooth  = FALSE,\n    # micro-relief (meters)\n    random_hills        = 0,\n    micro_hill_diam_m   = 30,\n    micro_hill_height_m = 50,\n    micro_hill_smooth   = TRUE,\n    micro_seed          = NULL,\n    # sun / geo\n    lat = 51.8, lon = 10.6, sun_date = as.Date(\"2024-06-21\"),\n    # optional noise\n    noise14 = NULL, noise05 = NULL\n) {\n  lake_mode <- match.arg(lake_mode)\n  hill_mode <- match.arg(hill_mode)\n  \n  # --- 0) Template & CRS guard (must be meters) -----------------------\n  ext <- terra::ext(domain$xmin, domain$xmax, domain$ymin, domain$ymax)\n  Rtemplate <- terra::rast(ext, resolution = domain$res, crs = domain$crs)\n  \n  crs_sf <- sf::st_crs(terra::crs(Rtemplate, proj=TRUE))\n  if (isTRUE(sf::st_is_longlat(crs_sf))) {\n    stop(\n      \"build_scenario(): Domain CRS is geographic (degrees). \",\n      \"All geometry is in meters. Use a projected CRS (e.g. UTM / EPSG:32632).\"\n    )\n  }\n  \n  xmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\n  ymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\n  len_x <- xmax - xmin;     len_y <- ymax - ymin\n  x0 <- (xmin + xmax)/2;    y0 <- (ymin + ymax)/2\n  \n  # coordinate rasters\n  X <- terra::init(Rtemplate, \"x\")\n  Y <- terra::init(Rtemplate, \"y\")\n  \n  # quick sanity for scale\n  px <- mean(terra::res(Rtemplate))\n  lr_px <- (lake_diam_m/2) / px\n  hr_px <- (hill_diam_m/2) / px\n  message(sprintf(\"[build_scenario] pixel=%.2f m; lake r=%.1f px; hill r=%.1f px\", px, lr_px, hr_px))\n  \n  # --- 1) Base valley --------------------------------------------------\n  a  <- 100 / ((len_y/2)^2)\n  E  <- 500 + a * (Y - y0)^2\n  names(E) <- \"elev\"\n  \n  # --- 2) Lake (mirror of hill, negative) ------------------------------\n  x_lc <- xmin + 2*len_x/3;  y_lc <- y0\n  lr   <- max(1e-6, lake_diam_m/2)\n  rl   <- sqrt((X - x_lc)^2 + (Y - y_lc)^2)\n  \n  w_l <- if (isTRUE(smooth_edges)) {\n    exp(-(rl/lr)^2)            # Gaussian \"bump\"\n  } else {\n    terra::ifel(rl <= lr, 1, 0) # hard disc\n  }\n  \n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    E <- E - as.numeric(lake_depth_m) * w_l\n  }\n  lakeR <- if (identical(lake_mode, \"water\")) terra::ifel(w_l > 1e-6, 1L, 0L)\n  else terra::setValues(terra::rast(Rtemplate), 0L)\n  names(lakeR) <- \"lake\"\n  \n  # --- 3) Main hill ----------------------------------------------------\n  x_hc <- xmin + len_x/3;  y_hc <- y0\n  hr   <- max(1e-6, hill_diam_m/2)\n  rh   <- sqrt((X - x_hc)^2 + (Y - y_hc)^2)\n  \n  w_h_main <- if (hill_mode == \"bump\") {\n    if (isTRUE(hill_smooth)) exp(-(rh/hr)^2) else terra::ifel(rh <= hr, 1, 0)\n  } else {\n    0 * X\n  }\n  E <- E + as.numeric(hill_height_m) * w_h_main\n  \n  # --- 4) Micro hills (additive, clamped to 1) ------------------------\n  w_h_micro <- 0 * X\n  if (random_hills > 0) {\n    if (!is.null(micro_seed)) set.seed(micro_seed)\n    margin <- micro_hill_diam_m/2 + 5\n    hrm <- max(1e-6, micro_hill_diam_m/2)\n    for (i in seq_len(random_hills)) {\n      cx <- runif(1, xmin + margin, xmax - margin)\n      cy <- runif(1, ymin + margin, ymax - margin)\n      r  <- sqrt((X - cx)^2 + (Y - cy)^2)\n      wi <- if (isTRUE(micro_hill_smooth)) exp(-(r/hrm)^2) else terra::ifel(r <= hrm, 1, 0)\n      sum_i <- w_h_micro + wi\n      w_h_micro <- terra::ifel(sum_i > 1, 1, sum_i)  # clamp without pmin()\n    }\n    E <- E + as.numeric(micro_hill_height_m) * w_h_micro\n  }\n  \n  hillW <- w_h_main + w_h_micro\n  hillW <- terra::ifel(hillW > 1, 1, hillW); names(hillW) <- \"hillW\"\n  \n  # --- 5) Derivatives --------------------------------------------------\n  slp <- terra::terrain(E, v = \"slope\",  unit = \"radians\")\n  asp <- terra::terrain(E, v = \"aspect\", unit = \"radians\")\n  \n  # --- 6) Sun & cos(i) -------------------------------------------------\n  sun14 <- sun_pos_utc(sun_date, 14L, lat, lon)\n  sun05 <- sun_pos_utc(sun_date,  5L, lat, lon)\n  I14   <- cosi_fun(sun14$alt, sun14$az, slp, asp); names(I14) <- \"I14\"\n  I05   <- cosi_fun(sun05$alt, sun05$az, slp, asp); names(I05) <- \"I05\"\n  \n  # --- 7) Land cover (1 forest, 2 water, 3 bare, 4 meadows) -----------\n  lc <- terra::setValues(terra::rast(Rtemplate), 4L)  # meadows\n  lc <- terra::ifel(lakeR > 0, 2L, lc)                # water overrides\n  forest_mask <- terra::ifel((hillW > 0.2) | ((slp > 0.15) & (Y > y0)), 1, 0)\n  lc <- terra::ifel((forest_mask == 1) & (lakeR <= 0), 1L, lc)\n  v_slp   <- terra::values(slp)\n  thr_slp <- stats::quantile(v_slp[is.finite(v_slp)], 0.90, na.rm = TRUE)\n  bare_mask <- terra::ifel((slp >= thr_slp) & (lakeR <= 0) & (forest_mask == 0), 1, 0)\n  lc <- terra::ifel(bare_mask == 1, 3L, lc)\n  lc <- terra::clamp(lc, 1L, 4L); names(lc) <- \"lc\"\n  \n  lc_levels <- c(\"forest\",\"water\",\"bare soil\",\"meadows\")\n  lc_colors <- c(\"forest\"=\"#2E8B57\",\"water\"=\"#5DADE2\",\"bare soil\"=\"#C49A6C\",\"meadows\"=\"#7FBF7B\")\n  \n  # --- 8) Noise --------------------------------------------------------\n  if (is.null(noise14)) {\n    set.seed(1001)\n    noise14 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  }\n  if (is.null(noise05)) {\n    set.seed(1002)\n    noise05 <- terra::setValues(terra::rast(E), rnorm(terra::ncell(E), 0, 0.3))\n  }\n  \n  # --- 9) Physics fields ----------------------------------------------\n  topo <- list(E = E, slp = slp, asp = asp, hillW = hillW)\n  phys <- build_physics_fields(\n    topography = topo, landcover = lc,\n    noise14 = noise14, noise05 = noise05,\n    sun14 = sun14, sun05 = sun05\n  )\n  R14 <- phys$R14; R05 <- phys$R05\n  \n  # --- 10) Return ------------------------------------------------------\n  list(\n    E = E, slp = slp, asp = asp,\n    I14 = I14, I05 = I05,\n    R14 = R14, R05 = R05,\n    lake = lakeR, hillW = hillW,\n    lc = lc, lc_levels = lc_levels, lc_colors = lc_colors,\n    sun = list(T14 = sun14, T05 = sun05)\n  )\n}\n\n\n\n\n# -------------------------- Stationen/Features -------------------------\nmake_stations <- function(domain, n_st = 60,\n                          station_mode = c(\"random\",\"ns_transect\",\"ew_transect\"),\n                          transect_margin_m = 10, ns_offset_m = 0, ew_offset_m = 0,\n                          crs = sf::st_crs(domain$Rtemplate)) {\n  station_mode <- match.arg(station_mode)\n  with(domain, {\n    if (station_mode == \"random\") {\n      pts <- tibble::tibble(\n        id = 1:n_st,\n        x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n        y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n      )\n    } else if (station_mode == \"ns_transect\") {\n      x_const <- min(max(x0 + ns_offset_m, xmin + transect_margin_m), xmax - transect_margin_m)\n      y_seq   <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n      pts <- tibble::tibble(id = 1:n_st, x = x_const, y = y_seq)\n    } else {\n      y_const <- min(max(y0 + ew_offset_m, ymin + transect_margin_m), ymax - transect_margin_m)\n      x_seq   <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n      pts <- tibble::tibble(id = 1:n_st, x = x_seq, y = y_const)\n    }\n    sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs, remove = FALSE)\n  })\n}\n\nstations_from_scenario <- function(scen, pts_sf) {\n  vpts <- terra::vect(pts_sf)\n  df <- tibble::as_tibble(pts_sf) %>%\n    dplyr::mutate(\n      z_surf = as.numeric(terra::extract(scen$E,   vpts, ID = FALSE)[,1]),\n      slp    = as.numeric(terra::extract(scen$slp, vpts, ID = FALSE)[,1]),\n      I14    = as.numeric(terra::extract(scen$I14, vpts, ID = FALSE)[,1]),\n      I05    = as.numeric(terra::extract(scen$I05, vpts, ID = FALSE)[,1]),\n      lc     = as.integer(terra::extract(scen$lc,  vpts, ID = FALSE)[,1]),\n      T14    = as.numeric(terra::extract(scen$R14, vpts, ID = FALSE)[,1]),\n      T05    = as.numeric(terra::extract(scen$R05, vpts, ID = FALSE)[,1])\n    )\n  lc_levels <- scen$lc_levels\n  pts14 <- df[stats::complete.cases(df[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I14\",\"lc\",\"T14\")]), ]\n  pts05 <- df[stats::complete.cases(df[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I05\",\"lc\",\"T05\")]), ]\n  stn_sf_14 <- pts14 %>%\n    dplyr::transmute(id, x, y,\n                     z_surf = as.numeric(z_surf), slp = as.numeric(slp), cosi = as.numeric(I14),\n                     lc = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n                     temp = as.numeric(T14)) %>%\n    sf::st_as_sf(coords = c(\"x\",\"y\"), crs = sf::st_crs(pts_sf), remove = FALSE)\n  stn_sf_05 <- pts05 %>%\n    dplyr::transmute(id, x, y,\n                     z_surf = as.numeric(z_surf), slp = as.numeric(slp), cosi = as.numeric(I05),\n                     lc = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n                     temp = as.numeric(T05)) %>%\n    sf::st_as_sf(coords = c(\"x\",\"y\"), crs = sf::st_crs(pts_sf), remove = FALSE)\n  list(T14 = stn_sf_14, T05 = stn_sf_05)\n}\n\n# -------------------------- Plots: Übersicht ---------------------------\n\n# -------------------------- Preview: Domain ----------------------------\n# Zeigt Extent, optional ein Grid, und annotiert Kern-Parameter.\npreview_domain <- function(domain, grid = TRUE, grid_step = NULL, annotate = TRUE) {\n  stopifnot(is.list(domain), !is.null(domain$Rtemplate))\n  crs <- sf::st_crs(domain$Rtemplate)\n  bb  <- sf::st_as_sfc(sf::st_bbox(c(\n    xmin = domain$xmin, ymin = domain$ymin,\n    xmax = domain$xmax, ymax = domain$ymax\n  ), crs = crs))\n\n  p <- ggplot2::ggplot() +\n    ggplot2::geom_sf(data = bb, fill = NA, color = \"black\", linewidth = 0.7) +\n    ggplot2::coord_sf(crs = crs, datum = NA, expand = FALSE) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Domain preview\", x = \"Easting (m)\", y = \"Northing (m)\")\n\n  if (isTRUE(grid)) {\n    len_x <- domain$xmax - domain$xmin\n    len_y <- domain$ymax - domain$ymin\n    step  <- if (is.null(grid_step)) max(100, round(min(len_x, len_y)/6, -2)) else grid_step\n    gr    <- sf::st_make_grid(bb, cellsize = c(step, step), what = \"polygons\")\n    gr_ln <- sf::st_as_sf(sf::st_boundary(gr))\n    p <- p + ggplot2::geom_sf(data = gr_ln, color = \"grey70\", linewidth = 0.2)\n  }\n\n  if (isTRUE(annotate)) {\n    r   <- terra::res(domain$Rtemplate)\n    txt <- sprintf(\n      \"Center: (%.0f, %.0f)\\nSize: %.0f × %.0f m\\nRes: %.0f × %.0f m\\nCRS: %s\",\n      domain$x0, domain$y0,\n      domain$xmax - domain$xmin, domain$ymax - domain$ymin,\n      r[1], r[2], as.character(terra::crs(domain$Rtemplate))\n    )\n    p <- p + ggplot2::annotate(\n      \"label\",\n      x = domain$xmin + 0.02 * (domain$xmax - domain$xmin),\n      y = domain$ymin + 0.06 * (domain$ymax - domain$ymin),\n      label = txt, hjust = 0, vjust = 0, size = 3\n    )\n  }\n\n  print(p)\n  invisible(p)\n}\n\n# -------------------------- Preview: Szenario-Raster -------------------\n# Visualisiert die vorhandenen Raster im Szenario (ohne Modelle/CV).\npreview_scenario <- function(x,\n                             which = c(\"lc\",\"E\",\"slp\",\"R14\",\"R05\"),\n                             stations = NULL,\n                             show_contours = TRUE,\n                             layout = c(\"grid\",\"vertical\")) {\n  layout <- match.arg(layout)\n  \n  # ---- Szenario + Stationen erkennen ---------------------------------\n  scen <- if (is.list(x) && !is.null(x$scen)) x$scen else x\n  if (is.null(stations) && is.list(x)) {\n    stations <- x$pts_sf %||% x$stn_sf_14 %||% x$stn_sf_05\n  }\n  \n  # ---- Verfügbare Ebenen sammeln -------------------------------------\n  layers <- list(\n    lc  = scen$lc,\n    E   = scen$E,\n    slp = scen$slp,\n    R14 = scen$R14,\n    R05 = scen$R05\n  )\n  keep <- names(layers) %in% which & vapply(layers, function(r) inherits(r,\"SpatRaster\"), TRUE)\n  layers <- layers[keep]\n  if (!length(layers)) stop(\"preview_scenario(): Keine der angefragten Ebenen im Szenario vorhanden.\")\n  \n  # ---- optionale Konturen vorbereiten --------------------------------\n  add_contours <- function(p) p\n  if (isTRUE(show_contours)) {\n    adders <- list()\n    \n    has_lake <- !is.null(scen$lake) && inherits(scen$lake, \"SpatRaster\")\n    if (has_lake) {\n      lake_df <- as.data.frame(scen$lake, xy = TRUE); names(lake_df) <- c(\"x\",\"y\",\"lake\")\n      adders[[length(adders)+1]] <- ggplot2::geom_contour(\n        data = lake_df,\n        mapping = ggplot2::aes(x = x, y = y, z = lake),\n        breaks = 0.5, colour = \"black\", linewidth = 0.35,\n        inherit.aes = FALSE\n      )\n    }\n    \n    has_hill <- !is.null(scen$hillW) && inherits(scen$hillW, \"SpatRaster\")\n    if (has_hill) {\n      hill_df <- as.data.frame(scen$hillW, xy = TRUE); names(hill_df) <- c(\"x\",\"y\",\"hillW\")\n      adders[[length(adders)+1]] <- ggplot2::geom_contour(\n        data = hill_df,\n        mapping = ggplot2::aes(x = x, y = y, z = hillW),\n        breaks = 0.5, colour = \"black\", linetype = \"22\", linewidth = 0.3,\n        inherit.aes = FALSE\n      )\n    }\n    \n    add_contours <- function(p) {\n      if (length(adders)) for (a in adders) p <- p + a\n      p\n    }\n  }\n  \n  # ---- Einzelplots bauen ----------------------------------------------\n  make_plot <- function(name, r) {\n    df <- as.data.frame(r, xy = TRUE); names(df) <- c(\"x\",\"y\",\"val\")\n    \n    if (name == \"lc\") {\n      levs <- scen$lc_levels %||% c(\"1\",\"2\",\"3\",\"4\")\n      pal  <- scen$lc_colors %||% setNames(scales::hue_pal()(length(levs)), levs)\n      df$val <- factor(df$val, levels = seq_along(levs), labels = levs)\n      p <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = val)) +\n        ggplot2::geom_raster() +\n        ggplot2::scale_fill_manual(\n          values = pal[levels(df$val)],  # <-- sicher auf Levels abbilden\n          na.value = \"grey90\", name = \"Landuse\"\n        ) +\n        ggplot2::coord_equal() + ggplot2::theme_minimal() +\n        ggplot2::labs(title = \"Landuse\", x = \"Easting\", y = \"Northing\")\n    } else {\n      p <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = val)) +\n        ggplot2::geom_raster() +\n        ggplot2::coord_equal() + ggplot2::theme_minimal() +\n        ggplot2::labs(\n          title = switch(name,\n                         E   = \"Elevation (m)\",\n                         slp = \"Slope (rad)\",\n                         R14 = \"T 14 UTC\",\n                         R05 = \"T 05 UTC\",\n                         name),\n          x = \"Easting\", y = \"Northing\"\n        )\n      if (name %in% c(\"E\",\"slp\")) {\n        p <- p + ggplot2::scale_fill_viridis_c()\n      } else {\n        p <- p + ggplot2::scale_fill_gradientn(colors = temp_palette(256), name = \"Temp\")\n      }\n    }\n    \n    # Konturen (nur falls vorhanden)\n    p <- add_contours(p)\n    \n    # Stationen optional\n    if (!is.null(stations) && inherits(stations, \"sf\")) {\n      # stilles CRS-Align (Fehlermeldungen unterdrücken)\n      suppressWarnings({\n        stations_plot <- try(sf::st_transform(stations, sf::st_crs(scen$lc %||% scen$E)), silent = TRUE)\n        if (inherits(stations_plot, \"try-error\")) stations_plot <- stations\n        p <- p + ggplot2::geom_sf(\n          data = stations_plot, colour = \"black\", fill = \"white\",\n          shape = 21, size = 1.6, stroke = 0.25, inherit.aes = FALSE\n        )\n      })\n    }\n    p\n  }\n  \n  plots <- Map(make_plot, names(layers), layers)\n  \n  # ---- kombinieren ----------------------------------------------------\n  if (length(plots) == 1) {\n    p_out <- plots[[1]]\n  } else if (layout == \"vertical\") {\n    p_out <- patchwork::wrap_plots(plots, ncol = 1)\n  } else {\n    p_out <- patchwork::wrap_plots(plots, ncol = min(3, length(plots)))\n  }\n  \n  print(p_out)\n  invisible(p_out)\n}\n\n\n\n\nplot_landcover_terrain <- function(scen, stations = NULL, show_contours = TRUE,\n                                   layout = c(\"grid\",\"vertical\")) {\n  layout <- match.arg(layout)\n  lc_df  <- as.data.frame(scen$lc,  xy = TRUE); names(lc_df)  <- c(\"x\",\"y\",\"lc\")\n  E_df   <- as.data.frame(scen$E,   xy = TRUE); names(E_df)   <- c(\"x\",\"y\",\"elev\")\n  slp_df <- as.data.frame(scen$slp, xy = TRUE); names(slp_df) <- c(\"x\",\"y\",\"slp\")\n  lc_df$lc <- factor(lc_df$lc, levels = seq_along(scen$lc_levels), labels = scen$lc_levels)\n  \n  p_lc <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = lc_df, ggplot2::aes(x, y, fill = lc)) +\n    ggplot2::scale_fill_manual(values = scen$lc_colors, na.value = \"grey90\", name = \"Landuse\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Landuse\", x = \"Easting\", y = \"Northing\")\n  \n  p_elev <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = E_df, ggplot2::aes(x, y, fill = elev)) +\n    ggplot2::scale_fill_viridis_c(name = \"Altitude [m]\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Altitude\", x = \"Easting\", y = \"Northing\")\n  \n  p_slp <- ggplot2::ggplot() +\n    ggplot2::geom_raster(data = slp_df, ggplot2::aes(x, y, fill = slp)) +\n    ggplot2::scale_fill_viridis_c(name = \"Slope [rad]\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = \"Slope\", x = \"Easting\", y = \"Northing\")\n  \n  if (isTRUE(show_contours)) {\n    lake_df <- as.data.frame(scen$lake, xy = TRUE); names(lake_df) <- c(\"x\",\"y\",\"lake\")\n    hill_df <- as.data.frame(scen$hillW, xy = TRUE); names(hill_df) <- c(\"x\",\"y\",\"hillW\")\n    p_lc  <- p_lc  +\n      ggplot2::geom_contour(data = lake_df, ggplot2::aes(x, y, z = lake),\n                            breaks = 0.5, colour = \"black\", linewidth = 0.35) +\n      ggplot2::geom_contour(data = hill_df, ggplot2::aes(x, y, z = hillW),\n                            breaks = 0.5, colour = \"black\", linetype = \"22\", linewidth = 0.3)\n    p_slp <- p_slp +\n      ggplot2::geom_contour(data = lake_df, ggplot2::aes(x, y, z = lake),\n                            breaks = 0.5, colour = \"black\", linewidth = 0.35) +\n      ggplot2::geom_contour(data = hill_df, ggplot2::aes(x, y, z = hillW),\n                            breaks = 0.5, colour = \"black\", linetype = \"22\", linewidth = 0.3)\n  }\n  if (!is.null(stations)) {\n    add_st <- list(ggplot2::geom_sf(data = stations, colour = \"black\", fill = \"white\",\n                                    shape = 21, size = 1.6, stroke = 0.25, inherit.aes = FALSE))\n    p_lc   <- p_lc   + add_st\n    p_elev <- p_elev + add_st\n    p_slp  <- p_slp  + add_st\n  }\n  if (layout == \"vertical\") {\n    (p_lc / p_elev / p_slp) + patchwork::plot_layout(guides = \"keep\")\n  } else {\n    (p_lc | (p_elev | p_slp)) + patchwork::plot_layout(guides = \"keep\")\n  }\n}\n\nplot_block_overview_2x2_en <- function(scen, pts_sf = NULL) {\n  Rstack <- c(scen$E, scen$slp, scen$I14, scen$I05)\n  df <- terra::as.data.frame(Rstack, xy = TRUE, na.rm = FALSE)\n  names(df) <- c(\"x\",\"y\",\"elev\",\"slope\",\"I14\",\"I05\")\n  theme_base <- ggplot2::theme_minimal(base_size = 11)\n  pal_terrain <- grDevices::hcl.colors(256, \"Terrain\")\n  pal_slope   <- grDevices::hcl.colors(256, \"Viridis\")\n  pal_hot     <- grDevices::hcl.colors(256, \"YlOrRd\")\n  pal_cool    <- grDevices::hcl.colors(256, \"PuBuGn\")\n  p_elev <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = elev)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_terrain, name = \"m\") +\n    ggplot2::labs(title = \"Terrain (Elevation)\") + theme_base\n  p_slope <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = slope)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_slope, name = \"rad\") +\n    ggplot2::labs(title = \"Slope (radians)\") + theme_base\n  p_I14 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I14)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_hot, name = \"\") +\n    ggplot2::labs(title = \"Insolation 14 UTC (cos i)\") + theme_base\n  p_I05 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I05)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_cool, name = \"\") +\n    ggplot2::labs(title = \"Insolation 05 UTC (cos i)\") + theme_base\n  if (!is.null(pts_sf)) {\n    pts_df <- sf::st_drop_geometry(pts_sf)\n    add_pts <- function(p)\n      p + ggplot2::geom_point(data = pts_df, ggplot2::aes(x = x, y = y),\n                              inherit.aes = FALSE, size = 0.7, alpha = 0.7,\n                              colour = \"black\")\n    p_elev  <- add_pts(p_elev); p_slope <- add_pts(p_slope)\n    p_I14   <- add_pts(p_I14);  p_I05   <- add_pts(p_I05)\n  }\n  (p_elev | (p_slope)) / (p_I14 | p_I05) + patchwork::plot_layout(guides = \"collect\")\n}\n\n# -------------------------- Geostat/Models -----------------------------\n# helpers\n.align_factor_to_model <- function(x, lev_model) {\n  xs <- as.character(x)\n  if (!length(lev_model)) return(factor(rep(NA_character_, length(xs))))\n  y <- factor(xs, levels = lev_model)\n  if (anyNA(y)) { xs[is.na(y)] <- lev_model[1]; y <- factor(xs, levels = lev_model) }\n  y\n}\n.default_vgm <- function(values, model = \"Exp\", range = 100) {\n  psill <- stats::var(values, na.rm = TRUE); nug <- 0.1 * psill\n  gstat::vgm(psill = psill, model = model, range = range, nugget = nug)\n}\nsafe_r2 <- function(obs, pred) {\n  idx <- is.finite(obs) & is.finite(pred)\n  if (sum(idx) < 2) return(NA_real_)\n  x <- obs[idx]; y <- pred[idx]\n  sx <- stats::sd(x); sy <- stats::sd(y)\n  if (!is.finite(sx) || !is.finite(sy) || sx == 0 || sy == 0) return(NA_real_)\n  stats::cor(x, y)^2\n}\nsafe_gam_formula <- function(d, include_lc = FALSE) {\n  stopifnot(all(c(\"temp\",\"x\",\"y\") %in% names(d)))\n  d <- d[stats::complete.cases(d[, c(\"temp\",\"x\",\"y\")]), , drop = FALSE]\n  n    <- nrow(d)\n  n_xy <- dplyr::n_distinct(paste0(round(d$x,3), \"_\", round(d$y,3)))\n  k_xy <- max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n  base <- if (n_xy >= 4) sprintf(\"temp ~ s(x,y,bs='tp',k=%d)\", k_xy) else \"temp ~ x + y\"\n  add <- character(0)\n  kcap <- function(x, kmax) {\n    ux <- unique(x[is.finite(x)]); nu <- length(ux)\n    if (nu <= 3) return(0L); max(4L, min(kmax, nu - 1L))\n  }\n  if (\"z_surf\" %in% names(d) && dplyr::n_distinct(d$z_surf) > 3) add <- c(add, sprintf(\"s(z_surf,bs='tp',k=%d)\", kcap(d$z_surf, 20)))\n  if (\"slp\"    %in% names(d) && dplyr::n_distinct(d$slp)    > 3) add <- c(add, sprintf(\"s(slp,bs='tp',k=%d)\",    kcap(d$slp, 12)))\n  if (\"cosi\"   %in% names(d) && dplyr::n_distinct(d$cosi)   > 3) add <- c(add, sprintf(\"s(cosi,bs='tp',k=%d)\",   kcap(d$cosi, 12)))\n  if (include_lc && \"lc\" %in% names(d)) { d$lc <- droplevels(factor(d$lc)); if (nlevels(d$lc) >= 2) add <- c(add, \"lc\") }\n  stats::as.formula(paste(base, paste(add, collapse = \" + \"), sep = if (length(add)) \" + \" else \"\"))\n}\n# learners\n# NOTE:\n# The following learner functions have been moved to a dedicated file\n# (e.g., learners_geostat_core.R):\n#   - pred_Voronoi\n#   - pred_IDW\n#   - pred_OK\n#   - pred_KED\n#   - pred_RF\n#   - pred_GAM\n#\n# Source that file alongside your helpers BEFORE any code that calls them.\n# -------------------------- Block-CV -----------------------------------\nmake_blocks_and_assign <- function(pts_sf, E, block_size = 100) {\n  bb <- sf::st_as_sfc(sf::st_bbox(c(xmin = terra::xmin(E), ymin = terra::ymin(E),\n                                    xmax = terra::xmax(E), ymax = terra::ymax(E)),\n                                  crs = sf::st_crs(pts_sf)))\n  gr <- sf::st_make_grid(bb, cellsize = c(block_size, block_size), what = \"polygons\")\n  blocks <- sf::st_sf(block_id = seq_along(gr), geometry = gr)\n  pts_blk <- sf::st_join(pts_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (any(is.na(pts_blk$block_id))) {\n    nearest <- sf::st_nearest_feature(pts_blk[is.na(pts_blk$block_id), ], blocks)\n    pts_blk$block_id[is.na(pts_blk$block_id)] <- blocks$block_id[nearest]\n  }\n  list(blocks = blocks, pts = pts_blk)\n}\nplot_blocks_grid <- function(blocks, pts_blk, title = \"Blocks & stations\") {\n  crs_plot <- sf::st_crs(pts_blk)\n  bb       <- sf::st_bbox(blocks)\n  n_blocks <- dplyr::n_distinct(pts_blk$block_id)\n  cols     <- scales::hue_pal()(max(1, n_blocks))\n  ggplot2::ggplot() +\n    ggplot2::geom_sf(data = blocks, fill = NA, color = \"grey50\", linewidth = 0.25) +\n    ggplot2::geom_sf(data = pts_blk, ggplot2::aes(color = factor(block_id)), size = 2, alpha = 0.95) +\n    ggplot2::scale_color_manual(values = cols, name = \"Block\") +\n    ggplot2::coord_sf(crs  = crs_plot, datum = NA,\n                      xlim = c(bb[\"xmin\"], bb[\"xmax\"]),\n                      ylim = c(bb[\"ymin\"], bb[\"ymax\"]), expand = FALSE) +\n    ggplot2::theme_minimal() + ggplot2::labs(title = title, x = \"Easting (m)\", y = \"Northing (m)\")\n}\nrun_lbo_cv <- function(stn_sf, E, block_size = 100, models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\")) {\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) { xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2] }\n  blk <- make_blocks_and_assign(stn_sf, E, block_size = block_size)\n  blocks_sf <- blk$blocks; stn_blk <- blk$pts\n  for (nm in c(\"temp\",\"z_surf\",\"slp\",\"cosi\",\"lc\",\"x\",\"y\")) if (!(nm %in% names(stn_blk))) stn_blk[[nm]] <- stn_sf[[nm]][match(stn_blk$id, stn_sf$id)]\n  \n  block_ids <- sort(unique(stn_blk$block_id))\n  out_list <- vector(\"list\", length(block_ids))\n  for (k in seq_along(block_ids)) {\n    b <- block_ids[k]\n    test_idx  <- which(stn_blk$block_id == b)\n    train_idx <- which(stn_blk$block_id != b)\n    train_sf <- stn_blk[train_idx, ]; test_sf <- stn_blk[test_idx, ]\n    pred_tbl <- lapply(models, function(m) {\n      p <- switch(m,\n                  \"Voronoi\" = pred_Voronoi(train_sf, test_sf),\n                  \"IDW\"     = pred_IDW    (train_sf, test_sf),\n                  \"OK\"      = pred_OK     (train_sf, test_sf),\n                  \"KED\"     = pred_KED    (train_sf, test_sf, E = E),\n                  \"RF\"      = pred_RF     (train_sf, test_sf),\n                  \"GAM\"     = pred_GAM    (train_sf, test_sf),\n                  stop(\"Unknown model: \", m)\n      )\n      tibble::tibble(model = m, id = test_sf$id, obs = test_sf$temp, pred = p, block_id = b)\n    })\n    out_list[[k]] <- dplyr::bind_rows(pred_tbl)\n  }\n  \n  cv_tbl <- dplyr::bind_rows(out_list)\n  metrics <- cv_tbl %>%\n    dplyr::group_by(model) %>%\n    dplyr::summarise(\n      n    = dplyr::n(),\n      n_ok = sum(is.finite(obs) & is.finite(pred)),\n      MAE  = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(abs(pred[i]-obs[i])) else NA_real_},\n      RMSE = {i <- is.finite(obs) & is.finite(pred); if (any(i)) sqrt(mean((pred[i]-obs[i])^2)) else NA_real_},\n      Bias = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(pred[i]-obs[i]) else NA_real_},\n      R2   = safe_r2(obs, pred),\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n  \n  diag_plot <- ggplot2::ggplot(cv_tbl, ggplot2::aes(obs, pred)) +\n    ggplot2::geom_abline(slope=1, intercept=0, linetype=\"dashed\") +\n    ggplot2::geom_point(alpha=0.7) +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"LBO-CV (block = %dm) — Observed vs Predicted\", block_size), x = \"Observed\", y = \"Predicted\") +\n    ggplot2::facet_wrap(~ model)\n  \n  blocks_plot <- plot_blocks_grid(blocks_sf, stn_blk, title = sprintf(\"Blocks (%.0f m) & stations\", block_size))\n  list(cv = cv_tbl, metrics = metrics, diag_plot = diag_plot, blocks_plot = blocks_plot)\n}\n\n# -------------------------- „run_for_time“ Wrapper ---------------------\nrun_for_time <- function(stn_sf, truth_r, label,\n                         scen_local,\n                         block_m,\n                         models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\"),\n                         layout = c(\"horizontal\",\"vertical\")) {\n  layout <- match.arg(layout)\n  res   <- run_lbo_cv(stn_sf, scen_local$E, block_size = block_m, models = models)\n  maps  <- predict_maps(stn_sf, truth_r, which_time = label,\n                        scen = scen_local, models = models,\n                        lc_levels = scen_local$lc_levels)\n  list(res = res, maps = maps)\n}\n\n# -------------------------- Skalen & Tuning ----------------------------\nplot_variogram_with_scales <- function(vg, L50, L95, sill, title = \"Empirical variogram\") {\n  df <- as.data.frame(vg)\n  ggplot2::ggplot(df, ggplot2::aes(dist, gamma)) +\n    ggplot2::geom_point(size = 1.4) +\n    ggplot2::geom_line(alpha = 0.5) +\n    ggplot2::geom_hline(yintercept = sill, linetype = \"dotted\", linewidth = 0.4) +\n    ggplot2::geom_vline(xintercept = L50, colour = \"#2b8cbe\", linetype = \"dashed\") +\n    ggplot2::geom_vline(xintercept = L95, colour = \"#de2d26\", linetype = \"dashed\") +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = title, x = \"Distance (m)\", y = \"Semivariance\")\n}\n.mean_kernel_for_R <- function(r, R_m) {\n  px <- mean(terra::res(r))\n  half <- max(1L, ceiling(R_m / px))\n  k <- 2L * half + 1L\n  W <- matrix(1, nrow = k, ncol = k)\n  W / sum(W)\n}\nsmooth_mean_R <- function(r, R_m) {\n  W <- .mean_kernel_for_R(r, R_m)\n  terra::focal(r, w = W, fun = \"mean\", na.policy = \"omit\", pad = TRUE, normalize = FALSE)\n}\ngaussian_focal <- function(r, radius_m, sigma_m = NULL) {\n  resx <- terra::res(r)[1]\n  if (is.null(sigma_m)) sigma_m <- radius_m / 2\n  rad_px   <- max(1L, round(radius_m / resx))\n  sigma_px <- max(0.5, sigma_m / resx)\n  xs <- -rad_px:rad_px\n  k1 <- exp(-0.5 * (xs / sigma_px)^2); k1 <- k1 / sum(k1)\n  K  <- outer(k1, k1); K / sum(K)\n}\nsmooth_dem_and_derive <- function(E, alt, az, radius_m) {\n  resx <- terra::res(E)[1]\n  pad_cells <- ceiling(radius_m / resx) + 2L\n  \n  E_pad <- terra::extend(E, pad_cells)\n  \n  K <- gaussian_focal(E_pad, radius_m)\n  Es_pad  <- terra::focal(E_pad, w = K, fun = mean, na.policy = \"omit\", pad = TRUE)\n  \n  slp_pad <- terra::terrain(Es_pad, v = \"slope\",  unit = \"radians\")\n  asp_pad <- terra::terrain(Es_pad, v = \"aspect\", unit = \"radians\")\n  \n  ci_pad  <- cosi_fun(alt, az, slp_pad, asp_pad)\n  \n  list(\n    Es   = terra::crop(Es_pad,  E),\n    slp  = terra::crop(slp_pad, E),\n    cosi = terra::crop(ci_pad,  E)\n  )\n}\n\n .extract_to_pts <- function(r, pts_sf) {\n  out <- try(terra::extract(r, terra::vect(pts_sf), ID = FALSE)[,1], silent = TRUE)\n  if (inherits(out, \"try-error\") || length(out) == 0L) rep(NA_real_, nrow(pts_sf)) else out\n}\n cv_gam_with_R <- function(stn_sf, E, alt = NULL, az = NULL, R, block_size_m = NULL, verbose = TRUE,...) \n   {\n   t0 <- proc.time()\n   # robust check whether to compute cos(i)\n   use_cosi <- isTRUE(!is.null(alt) && !is.null(az) &&\n                        is.finite(alt) && is.finite(az)) \n   \n   # --- 0) Block size guard\n   bs <- suppressWarnings(as.numeric(block_size_m)[1])\n   if (!is.finite(bs) || bs <= 0) {\n     bs <- suppressWarnings(as.numeric(get0(\"block_size\", ifnotfound = NA_real_)))\n   }\n   if (!is.finite(bs) || bs <= 0)\n     stop(\"cv_gam_with_R(): no valid block size (block_size_m or global block_size).\")\n   \n   # --- 1) DEM smoothing + derived fields\n   zR   <- smooth_mean_R(E, R)\n   slpR <- terra::terrain(zR, v = \"slope\",  unit = \"radians\")\n   aspR <- terra::terrain(zR, v = \"aspect\", unit = \"radians\")\n   \n   # Only compute cos(i) if BOTH angles are clean, finite scalars\n   use_cosi <- isTRUE(is.numeric(alt) && is.numeric(az) &&\n                        length(alt) == 1L && length(az) == 1L &&\n                        is.finite(alt) && is.finite(az))\n   if (use_cosi) {\n     zen  <- (pi/2 - alt)\n     ci   <- cos(slpR)*cos(zen) + sin(slpR)*sin(zen)*cos(az - aspR)\n     cosiR <- terra::ifel(ci < 0, 0, ci)\n   } else {\n     cosiR <- NULL\n   }\n   \n   # --- 2) Extract to stations (fill missing with medians)\n   if (!all(c(\"x\",\"y\") %in% names(stn_sf))) {\n     xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2]\n   }\n   fill_med <- function(v) {\n     m <- stats::median(v[is.finite(v)], na.rm = TRUE)\n     v[!is.finite(v)] <- m\n     v\n   }\n   stn_sf$z_surf_R <- fill_med(.extract_to_pts(zR,   stn_sf))\n   stn_sf$slp_R    <- fill_med(.extract_to_pts(slpR, stn_sf))\n   if (use_cosi) {\n     stn_sf$cosi_R <- fill_med(.extract_to_pts(cosiR, stn_sf))\n   } else {\n     stn_sf$cosi_R <- NA_real_\n   }\n   \n   # --- 3) Build blocks\n   bb_poly <- sf::st_as_sfc(sf::st_bbox(stn_sf), crs = sf::st_crs(stn_sf))\n   blocks  <- sf::st_make_grid(bb_poly, cellsize = c(bs, bs), what = \"polygons\")\n   blocks  <- sf::st_sf(block_id = seq_along(blocks), geometry = blocks)\n   \n   stn_blk <- sf::st_join(stn_sf, blocks, join = sf::st_intersects, left = TRUE)\n   if (anyNA(stn_blk$block_id)) {\n     i <- is.na(stn_blk$block_id)\n     stn_blk$block_id[i] <- blocks$block_id[sf::st_nearest_feature(stn_blk[i,], blocks)]\n   }\n   if (!all(c(\"x\",\"y\") %in% names(stn_blk))) {\n     xy <- sf::st_coordinates(stn_blk); stn_blk$x <- xy[,1]; stn_blk$y <- xy[,2]\n   }\n   \n   # --- 4) LBO-CV\n   bids  <- sort(unique(stn_blk$block_id))\n   pm_say(\"[cv_gam_with_R] R=%.0f m | block=%.0f m | stations=%d | blocks=%d | cos(i)=%s\",\n          R, block_size_m, nrow(stn_sf), length(bids),\n          if (use_cosi) \"yes\" else \"no\", v = verbose)\n   preds <- vector(\"list\", length(bids)); j <- 0L\n   \n   for (b in bids) {\n     te <- stn_blk[stn_blk$block_id == b, ]\n     tr <- stn_blk[stn_blk$block_id != b, ]\n     pm_say(\"  - block %d: train=%d, test=%d\", b, nrow(tr), nrow(te), v = verbose)\n     \n     \n     dtr  <- sf::st_drop_geometry(tr)\n     # include cosi_R only if it’s present with finite values\n     need <- c(\"temp\",\"x\",\"y\",\"z_surf_R\",\"slp_R\")\n     inc_cosi <- (\"cosi_R\" %in% names(dtr)) && any(is.finite(dtr$cosi_R))\n     if (inc_cosi) need <- c(need, \"cosi_R\")\n     \n     dtr  <- dtr[stats::complete.cases(dtr[, need, drop = FALSE]), need, drop = FALSE]\n     if (nrow(dtr) < 10) next\n     \n     # dynamic k guards\n     n_xy <- dplyr::n_distinct(paste0(round(dtr$x,3), \"_\", round(dtr$y,3)))\n     k_xy <- .k_for_xy(nrow(dtr), n_xy)\n     k_z  <- .kcap_unique(dtr$z_surf_R, 20)\n     k_sl <- .kcap_unique(dtr$slp_R,    12)\n     if (inc_cosi) k_ci <- .kcap_unique(dtr$cosi_R, 12)\n     \n     # assemble formula with only informative terms\n     terms <- c()\n     terms <- c(terms, if (n_xy >= 4) sprintf(\"s(x,y,bs='tp',k=%d)\", k_xy) else \"x + y\")\n     terms <- c(terms, if (k_z  >= 4) sprintf(\"s(z_surf_R,bs='tp',k=%d)\", k_z)  else \"z_surf_R\")\n     if (length(unique(dtr$slp_R[is.finite(dtr$slp_R)])) > 1)\n       terms <- c(terms, if (k_sl >= 4) sprintf(\"s(slp_R,bs='tp',k=%d)\", k_sl) else \"slp_R\")\n     if (inc_cosi && any(is.finite(dtr$cosi_R)) &&\n         length(unique(dtr$cosi_R[is.finite(dtr$cosi_R)])) > 1)\n       terms <- c(terms, if (k_ci >= 4) sprintf(\"s(cosi_R,bs='tp',k=%d)\", k_ci) else \"cosi_R\")\n     \n     form <- stats::as.formula(paste(\"temp ~\", paste(terms, collapse = \" + \")))\n     gm <- mgcv::gam(form, data = dtr, method = \"REML\", select = TRUE)\n     \n     dte <- sf::st_drop_geometry(te)\n     # restrict to variables actually in the model\n     vars_needed <- setdiff(all.vars(form), \"temp\")\n     dte <- dte[, vars_needed, drop = FALSE]\n     ph  <- try(stats::predict(gm, newdata = dte, type = \"response\"), silent = TRUE)\n     if (inherits(ph, \"try-error\")) ph <- rep(NA_real_, nrow(dte))\n     \n     j <- j + 1L\n     preds[[j]] <- tibble::tibble(id = te$id, obs = te$temp, pred = as.numeric(ph), block_id = b)\n   }\n   \n   preds <- preds[seq_len(j)]\n   if (!length(preds)) {\n     return(list(cv = tibble::tibble(id = integer(), obs = numeric(), pred = numeric(), block_id = integer()),\n                 RMSE = NA_real_))\n   }\n   out  <- dplyr::bind_rows(preds)\n   rmse <- sqrt(mean((out$pred - out$obs)^2, na.rm = TRUE))\n   list(cv = out, RMSE = rmse)\n }\n \n \n \n\n tune_Rstar_ucurve <- function(stn_sf, E, alt = NULL, az = NULL,\n                               L50, L95, block_fallback = 120,\n                               n_grid = 6, extra = c(0.8, 1.2),\n                               scen = NULL, which_time = c(\"T14\",\"T05\")) {\n   \n   which_time <- match.arg(which_time)\n   \n   # fallback L50/L95 if broken\n   e <- terra::ext(E)\n   dom_diag <- sqrt((terra::xmax(e)-terra::xmin(e))^2 + (terra::ymax(e)-terra::ymin(e))^2)\n   if (!is.finite(L50) || !is.finite(L95) || L95 <= L50) {\n     L50 <- dom_diag/10; L95 <- dom_diag/4\n   }\n   block_m <- max(block_fallback, round(L50))\n   \n   # sun from scen if not given\n   if ((is.null(alt) || is.null(az)) && !is.null(scen)) {\n     s <- .get_sun(scen, which_time)\n     alt <- s$alt; az <- s$az\n   }\n   \n   R_min <- max(10, round(L50*extra[1])); R_max <- round(L95*extra[2])\n   R_grid <- unique(round(seq(R_min, R_max, length.out = n_grid)))\n   \n   rows <- lapply(R_grid, function(R) {\n     z <- cv_gam_with_R(stn_sf, E, alt = alt, az = az, R = R,\n                        block_size_m = block_m, scen = NULL, which_time = which_time)\n     data.frame(R = R, RMSE = z$RMSE)\n   })\n   df <- do.call(rbind, rows)\n   R_star <- df$R[which.min(df$RMSE)]\n   list(grid = df, R_star = as.numeric(R_star), block_m = block_m)\n }\n \n \n\nplot_ucurve <- function(df, R_star, title = \"U-curve: tune R\") {\n  ggplot2::ggplot(df, ggplot2::aes(R, RMSE)) +\n    ggplot2::geom_line() + ggplot2::geom_point() +\n    ggplot2::geom_vline(xintercept = R_star, linetype = \"dashed\", colour = \"#de2d26\") +\n    ggplot2::theme_minimal() + ggplot2::labs(title = title, x = \"Drift radius R (m)\", y = \"RMSE (block-CV)\")\n}\n\n# Drop-in replacement\nadd_drifts_at_R <- function(stn_sf, E, alt, az, R,\n                            lc = NULL, lc_levels = NULL,\n                            na_action = c(\"error\",\"fill\",\"drop\")) {\n  na_action <- match.arg(na_action)\n  \n  # 0) Align CRS (key cause of NA extractions)\n  crs_r <- sf::st_crs(E)\n  if (!isTRUE(sf::st_crs(stn_sf) == crs_r)) {\n    stn_sf <- sf::st_transform(stn_sf, crs_r)\n  }\n  \n  # 1) Build @R* features (Es, slope, cosi) — your existing function\n  fr <- smooth_dem_and_derive(E, alt, az, radius_m = R)\n  \n  # 2) Extract to points\n  v <- terra::vect(stn_sf)\n  stn_sf$E_R    <- as.numeric(terra::extract(fr$Es,   v, ID = FALSE)[, 1])\n  stn_sf$slp_R  <- as.numeric(terra::extract(fr$slp,  v, ID = FALSE)[, 1])\n  stn_sf$cosi_R <- as.numeric(terra::extract(fr$cosi, v, ID = FALSE)[, 1])\n  \n  # Optional LC (factor) — unchanged logic\n  if (!is.null(lc)) {\n    if (is.null(lc_levels)) lc_levels <- lc_levels_default\n    lc_idx <- as.integer(terra::extract(lc, v, ID = FALSE)[, 1])\n    lc_idx[!is.finite(lc_idx)] <- 1L\n    lc_idx <- pmax(1L, pmin(lc_idx, length(lc_levels)))\n    stn_sf$lc <- factor(lc_levels[lc_idx], levels = lc_levels)\n  }\n  \n  # 3) Handle NA per policy\n  d <- sf::st_drop_geometry(stn_sf)\n  miss <- !stats::complete.cases(d[, c(\"E_R\",\"slp_R\",\"cosi_R\"), drop = FALSE])\n  \n  if (any(miss)) {\n    if (na_action == \"error\") {\n      stop(\"Station features at R* contain NA. Increase padding in smooth_dem_and_derive(), \",\n           \"reduce R*, or call add_drifts_at_R(..., na_action='fill'/'drop').\")\n    }\n    if (na_action == \"fill\") {\n      fill_med <- function(x) { m <- stats::median(x[is.finite(x)], na.rm = TRUE); x[!is.finite(x)] <- m; x }\n      stn_sf$E_R    <- fill_med(stn_sf$E_R)\n      stn_sf$slp_R  <- fill_med(stn_sf$slp_R)\n      stn_sf$cosi_R <- fill_med(stn_sf$cosi_R)\n    }\n    if (na_action == \"drop\") {\n      stn_sf <- stn_sf[!miss, ]\n    }\n  }\n  \n  stn_sf\n}\n\ncompute_Ls_from_points <- function(stn_sf, value_col = \"temp\",\n                                   maxdist = NULL, nlag = 18, smooth_k = 3) {\n  stopifnot(inherits(stn_sf, \"sf\"), value_col %in% names(stn_sf))\n  pts <- stn_sf[is.finite(stn_sf[[value_col]]), ]\n  if (is.null(maxdist)) {\n    bb <- sf::st_bbox(pts)\n    dom_diag <- sqrt((bb[\"xmax\"]-bb[\"xmin\"])^2 + (bb[\"ymax\"]-bb[\"ymin\"])^2)\n    maxdist <- dom_diag / 2\n  }\n  form <- stats::as.formula(sprintf(\"%s ~ 1\", value_col))\n  vg  <- gstat::variogram(form, data = pts, cutoff = maxdist, width = maxdist/nlag)\n  if (nrow(vg) >= smooth_k) {\n    vg$gamma <- stats::filter(vg$gamma, rep(1/smooth_k, smooth_k), sides = 2)\n    vg$gamma[!is.finite(vg$gamma)] <- zoo::na.approx(vg$gamma, na.rm = FALSE)\n    vg$gamma <- zoo::na.locf(zoo::na.locf(vg$gamma, fromLast = TRUE))\n  }\n  sill <- max(vg$gamma, na.rm = TRUE)\n  if (!is.finite(sill) || sill <= 0) sill <- stats::median(vg$gamma, na.rm = TRUE)\n  L_at_q <- function(q) {\n    thr <- q * sill\n    i   <- which(vg$gamma >= thr)[1]\n    if (is.na(i)) return(NA_real_)\n    if (i == 1) return(vg$dist[1])\n    d0 <- vg$dist[i-1]; d1 <- vg$dist[i]\n    g0 <- vg$gamma[i-1]; g1 <- vg$gamma[i]\n    if (!is.finite(d0) || !is.finite(d1) || g1 == g0) return(d1)\n    d0 + (thr - g0) * (d1 - d0) / (g1 - g0)\n  }\n  list(vg = vg, sill = sill, L50 = L_at_q(0.5), L95 = L_at_q(0.95), cutoff = maxdist)\n}\n\n# -------------------------- Error-Budget --------------------------------\n\n# -------------------------- Error-Budget --------------------------------\nnugget_fraction_from_cv <- function(cv_sf_or_df, model, crs_ref, x_col=\"x\", y_col=\"y\",\n                                    cutoff = NULL, width = NULL) {\n  stopifnot(!missing(model))\n  df <- dplyr::filter(cv_sf_or_df, .data$model == !!model)\n  \n  # Ensure sf\n  sf <- if (inherits(df, \"sf\")) df else sf::st_as_sf(df, coords = c(x_col, y_col), crs = sf::st_crs(crs_ref))\n  sf <- sf::st_transform(sf, sf::st_crs(crs_ref))\n  sf$resid <- sf$obs - sf$pred\n  \n  xy  <- sf::st_coordinates(sf) %>% as.data.frame()\n  dat <- dplyr::bind_cols(sf::st_drop_geometry(sf), xy)\n  \n  if (is.null(cutoff)) cutoff <- max(dist(xy)) * 0.5\n  if (is.null(width))  width  <- cutoff / 12\n  \n  vg  <- gstat::variogram(resid ~ 1, data = dat, locations = ~ X + Y,\n                          cutoff = cutoff, width = width)\n  fit <- gstat::fit.variogram(vg, gstat::vgm(\"Mat\"))\n  nug <- fit$psill[fit$model == \"Nug\"]; sill <- sum(fit$psill)\n  if (length(nug) && is.finite(sill) && sill > 0) nug / sill else NA_real_\n}\n\nsimple_error_budget <- function(res_cv, sigma_inst = 0.5, alpha = 0.6) {\n  res <- res_cv$cv\n  res <- res[is.finite(res$obs) & is.finite(res$pred), , drop = FALSE]\n  RMSE <- sqrt(mean((res$pred - res$obs)^2))\n  Bias <- mean(res$pred - res$obs)\n  VarE <- stats::var(res$pred - res$obs, na.rm = TRUE)\n  meas <- sigma_inst^2\n  proc <- max(0, VarE - meas)\n  micro <- alpha * proc\n  meso  <- (1 - alpha) * proc\n  tibble::tibble(Component = c(\"RMSE\",\"Bias\",\"Total var\",\"Instrument var\",\"Microscale var\",\"Mesoscale var\"),\n                 Value     = c(RMSE, Bias, VarE, meas, micro, meso))\n}\n## ======================================================================\n## Ende der Bibliothek\n## ======================================================================\n\n## ---------- Mini-Beispiel (nicht Teil der Bibliothek) -----------------\n## domain  <- make_domain()\n## scen    <- build_scenario(domain, lake_mode=\"water\", hill_mode=\"bump\",\n##                           random_hills = 100, micro_seed = 1)\n## pts_sf  <- make_stations(domain, n_st = 60, station_mode = \"random\")\n## stns    <- stations_from_scenario(scen, pts_sf)\n## bs      <- compute_block_size(len_x = domain$xmax-domain$xmin,\n##                               len_y = domain$ymax-domain$ymin, n_st = nrow(pts_sf))\n## out14   <- run_for_time(stns$T14, scen$R14, \"T14\", scen, bs)\n## out05   <- run_for_time(stns$T05, scen$R05, \"T05\", scen, bs)\n## # Plot-Beispiele:\n## # print(plot_landcover_terrain(scen, stations = stns$T14))\n## # print(out14$res$blocks_plot); print(out14$res$diag_plot)\n```\n````\n:::\n\n\n\n    -   `fun_learn_predict_core.R`: learning/validation/prediction\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        routines (block CV, learners, map prediction, residual\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        diagnostics).\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\n#' Geostatistical Learners & Map Predictor (Core Only)\n#'\n#' @title Learners and Raster Predictor (no helpers inside)\n#' @description\n#' A compact set of **model-specific predictors** used in your teaching/\n#' pipeline code, plus a high-level `predict_maps()` convenience that\n#' evaluates multiple learners on a full grid.  \n#'\n#' This file intentionally contains **no helpers**. It assumes that common\n#' utilities and constants are sourced from your *helpers* module, including:\n#' - `%||%` — null-coalescing helper\n#' - `.default_vgm()` — conservative variogram fallback\n#' - `.align_factor_to_model()` — align factor levels at predict time\n#' - `safe_gam_formula()` — guarded GAM formula constructor\n#' - `lc_levels_default` — global land-cover levels\n#' - `temp_palette`, `stretch_q` — visualization defaults\n#'\n#' @details\n#' **Contract expected by all learners**:\n#' - `train_sf`, `test_sf` are `sf` objects with at least:\n#'   - `temp` (numeric): the response variable to be learned\n#'   - `x`, `y` (numeric): planar coordinates (will be derived from geometry\n#'     if absent)\n#'   - Drift/covariate columns depending on the learner (see each function)\n#' - Each learner returns a numeric vector of predictions aligned with\n#'   `nrow(test_sf)`.\n#'\n#' **Coordinate Reference System**: all learners assume that `x` and `y`\n#' are in a **projected CRS** with meter-like units (e.g., UTM).\n#'\n#' **Error handling**:\n#' - Learners are defensive; if inputs are insufficient (e.g., too few rows,\n#'   missing drift columns), they return `NA_real_` predictions of the correct\n#'   length instead of failing hard (except where a *hard requirement* is unmet\n#'   such as missing KED drifts in training).\n#'\n#' @section Dependencies:\n#' - **Packages**: `sf`, `gstat`, `mgcv`, `randomForest`, `terra`, `ggplot2`,\n#'   `tibble`, `dplyr`, `stats`, `scales`\n#' - **Helpers (sourced elsewhere)**: `%||%`, `.default_vgm`, `.align_factor_to_model`,\n#'   `safe_gam_formula`, `lc_levels_default`, `temp_palette`, `stretch_q`\n#'\n#' @seealso\n#' - Your helpers/utilities module for the functions noted above.\n#' - `gstat::krige`, `gstat::idw`, `gstat::variogram`, `gstat::fit.variogram`\n#' - `mgcv::gam`, `randomForest::randomForest`\n#'\n#' @keywords geostatistics interpolation kriging regression GAM randomForest\n#' @family learners\n\n\n#' Voronoi / Nearest-Station Predictor\n#'\n#' @description\n#' Assigns each prediction point the observed value from the **nearest**\n#' training station (a fast proxy for Voronoi interpolation).\n#'\n#' @param train_sf `sf` with at least `temp` and geometry.\n#' @param test_sf  `sf` with geometry to predict for.\n#'\n#' @return Numeric vector `length(nrow(test_sf))` with nearest-neighbor temps.\n#' @examples\n#' # y_hat <- pred_Voronoi(train_sf, grid_sf)\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf)\n  as.numeric(train_sf$temp)[idx]\n}\n\n\n#' Inverse Distance Weighting (IDW)\n#'\n#' @description\n#' Classic **IDW** using `gstat::idw`, predicting from training points to\n#' the test geometry.\n#'\n#' @param train_sf `sf` with `temp` and geometry.\n#' @param test_sf  `sf` with geometry.\n#' @param idp      Inverse distance power (default `2`).\n#'\n#' @return Numeric vector of predictions for `test_sf`.\n#' @examples\n#' # y_hat <- pred_IDW(train_sf, grid_sf, idp = 2)\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  pr <- suppressWarnings(gstat::idw(temp ~ 1, locations = train_sf, newdata = test_sf, idp = idp))\n  as.numeric(pr$var1.pred)\n}\n\n\n#' Ordinary Kriging (OK)\n#'\n#' @description\n#' Univariate **OK** with an automatically fitted **exponential** variogram.\n#' Falls back to `.default_vgm()` if fitting fails (e.g., too few points).\n#'\n#' @param train_sf `sf` with `temp` and geometry.\n#' @param test_sf  `sf` with geometry.\n#'\n#' @return Numeric vector of kriged predictions.\n#' @examples\n#' # y_hat <- pred_OK(train_sf, grid_sf)\npred_OK <- function(train_sf, test_sf) {\n  vg      <- suppressWarnings(gstat::variogram(temp ~ 1, data = train_sf))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- .default_vgm(train_sf$temp)\n  pr <- suppressWarnings(gstat::krige(temp ~ 1, locations = train_sf, newdata = test_sf, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n\n#' Kriging with External Drift (KED)\n#'\n#' @description\n#' **KED** with additive drift terms. Requires drifts in *training*, fills\n#' non-finite values in *test* by median of training. If `lc` is present in\n#' both sets, it is included as a categorical drift with aligned levels.\n#'\n#' @details\n#' **Required drift columns** in `train_sf`: `z_surf`, `slp`, `cosi`.  \n#' If any are missing in training, this function errors (by design).\n#'\n#' @param train_sf `sf`; must contain `temp`, `z_surf`, `slp`, `cosi`, geometry,\n#'   and optionally `lc`.\n#' @param test_sf  `sf` with geometry and preferably the same drift columns\n#'   (non-finite values are median-filled).\n#' @param ...      Unused (placeholder for compatibility).\n#'\n#' @return Numeric vector of KED predictions, `length(nrow(test_sf))`.\n#' @examples\n#' # y_hat <- pred_KED(train_sf, grid_sf)\npred_KED <- function(train_sf, test_sf, ...) {\n  need <- c(\"z_surf\",\"slp\",\"cosi\")\n  miss <- setdiff(need, names(train_sf))\n  if (length(miss)) stop(\"pred_KED(): missing drifts in training: \", paste(miss, collapse = \", \"))\n  use_lc <- \"lc\" %in% names(train_sf) && \"lc\" %in% names(test_sf)\n  tr <- train_sf; te <- test_sf\n  if (use_lc) {\n    tr$lc <- droplevels(factor(tr$lc))\n    te$lc <- factor(as.character(te$lc), levels = levels(tr$lc))\n    te$lc[is.na(te$lc)] <- levels(tr$lc)[1]\n  }\n  for (nm in need) {\n    m <- stats::median(tr[[nm]][is.finite(tr[[nm]])], na.rm = TRUE)\n    te[[nm]][!is.finite(te[[nm]])] <- m\n  }\n  keep_tr <- c(\"temp\", need, if (use_lc) \"lc\")\n  dtr <- sf::st_drop_geometry(tr)[, keep_tr, drop = FALSE]\n  ok  <- stats::complete.cases(dtr); tr <- tr[ok, ]\n  if (nrow(tr) < 5) return(rep(NA_real_, nrow(te)))\n  form <- stats::as.formula(paste(\"temp ~\", paste(c(need, if (use_lc) \"lc\"), collapse = \" + \")))\n  vg      <- suppressWarnings(gstat::variogram(form, data = tr))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) {\n    ps <- stats::var(sf::st_drop_geometry(tr)$temp, na.rm = TRUE)\n    vgm_fit <- gstat::vgm(psill = ps, model = \"Exp\", range = max(vg$dist, na.rm = TRUE)/3, nugget = 0.1*ps)\n  }\n  pr <- suppressWarnings(gstat::krige(form, locations = tr, newdata = te, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n\n#' Random Forest Regressor (RF)\n#'\n#' @description\n#' A **RandomForest** on spatial and drift features. If `lc` is absent, a\n#' harmless single-level factor is injected (levels provided by\n#' `lc_levels_default`). At prediction, factor levels are aligned using\n#' `.align_factor_to_model()`.\n#'\n#' @param train_sf `sf` with `temp`, `x`, `y`, `z_surf`, `slp`, `cosi`,\n#'   optionally `lc` (factor), and geometry.\n#' @param test_sf  `sf` with the same predictors (geometry required).\n#'\n#' @return Numeric vector of RF predictions.\n#' @examples\n#' # y_hat <- pred_RF(train_sf, grid_sf)\npred_RF <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf)\n  if (!(\"lc\" %in% names(dtr))) dtr$lc <- factor(lc_levels_default[1], levels = lc_levels_default)\n  dtr$lc <- droplevels(factor(as.character(dtr$lc), levels = lc_levels_default))\n  dtr <- stats::na.omit(dtr)\n  if (nrow(dtr) < 5) return(rep(NA_real_, nrow(test_sf)))\n  rf  <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi + lc, data = dtr, na.action = na.omit)\n  dte <- sf::st_drop_geometry(test_sf)\n  if (!(\"lc\" %in% names(dte))) dte$lc <- factor(lc_levels_default[1], levels = lc_levels_default)\n  lev <- levels(dtr$lc)\n  dte$lc <- .align_factor_to_model(dte$lc, lev)\n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\")])\n  out  <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(rf, dte[good, ])\n  out\n}\n\n\n#' Generalized Additive Model (GAM)\n#'\n#' @description\n#' A **GAM** (thin-plate splines) built with a protective formula from\n#' `safe_gam_formula()` that caps basis sizes and includes `lc` only if\n#' useful. Requires a minimal number of complete rows.\n#'\n#' @param train_sf `sf` with `temp`, `x`, `y`, `z_surf`, `slp`, `cosi`,\n#'   optionally `lc` (factor).\n#' @param test_sf  `sf` with matching predictors.\n#'\n#' @return Numeric vector of GAM predictions; `NA_real_` if the model could\n#'   not be trained.\n#' @examples\n#' # y_hat <- pred_GAM(train_sf, grid_sf)\npred_GAM <- function(train_sf, test_sf) {\n  dtr  <- sf::st_drop_geometry(train_sf)\n  keep <- intersect(c(\"temp\",\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\"), names(dtr))\n  dtr  <- dtr[stats::complete.cases(dtr[, keep, drop = FALSE]), keep, drop = FALSE]\n  if (!nrow(dtr)) return(rep(NA_real_, nrow(test_sf)))\n  if (\"lc\" %in% names(dtr)) dtr$lc <- droplevels(factor(dtr$lc))\n  inc_lc <- \"lc\" %in% names(dtr) && nlevels(dtr$lc) >= 2\n  if (nrow(dtr) < 10) return(rep(NA_real_, nrow(test_sf)))\n  gm <- mgcv::gam(formula = safe_gam_formula(dtr, include_lc = inc_lc), data = dtr, method = \"REML\", select = TRUE)\n  dte <- sf::st_drop_geometry(test_sf)\n  vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (inc_lc) \"lc\"); vars <- intersect(vars, names(dte))\n  if (inc_lc) {\n    lev <- levels(model.frame(gm)$lc)\n    if (!(\"lc\" %in% names(dte))) dte$lc <- lev[1]\n    dte$lc <- .align_factor_to_model(dte$lc, lev)\n  }\n  good <- stats::complete.cases(dte[, vars, drop = FALSE])\n  out  <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(gm, dte[good, vars, drop = FALSE], type = \"response\")\n  out\n}\n\n\n#' Predict on a Raster Grid with Multiple Learners + Pretty Plots\n#'\n#' @description\n#' High-level utility that:\n#' 1. Ensures station covariates exist (E, slope, cos(i), optional LC).\n#' 2. Builds a **full-grid** data frame of covariates from rasters.\n#' 3. Runs selected learners (`Voronoi`, `IDW`, `OK`, `KED`, `RF`, `GAM`).\n#' 4. Returns both **prediction rasters** and **ggplot** panels.\n#'\n#' @param stn_sf `sf` training stations; must have `temp` and (if missing)\n#'   this function will derive `x`, `y` and extract missing covariates from\n#'   rasters.\n#' @param truth_raster `SpatRaster` (single-layer) used only for common\n#'   color scaling in plots (and optional “truth” visualization).\n#' @param which_time Character; `\"T14\"` or `\"T05\"` (plot titles only).\n#' @param scen A scenario list containing at least: `E`, `slp`, and either\n#'   `I14` or `I05` (for cos(i)) and optionally `lc` + `lc_levels`.\n#' @param models Character vector of learners to run.\n#' @param lc_levels Optional character vector of LC levels (defaults to\n#'   `scen$lc_levels`).\n#' @param feature_rasters Optional list with named rasters `E`, `slp`, `cosi`\n#'   to **override** the scenario’s baseline (e.g., when using tuned R*).\n#'\n#' @return A list with:\n#' \\describe{\n#'   \\item{pred_df}{Tidy `tibble` of predictions for all models & grid cells}\n#'   \\item{pred_rasters}{`list` of `SpatRaster` predictions, one per model}\n#'   \\item{p_pred}{`ggplot` facet showing all model maps}\n#'   \\item{p_truth}{`ggplot` of the truth raster (for reference)}\n#' }\n#'\n#' @note\n#' Requires helpers/constants: `%||%`, `temp_palette`, `stretch_q`, plus\n#' land-cover level alignment utilities.\n#'\n#' @examples\n#' # out <- predict_maps(stn_sf, scen$R14, which_time = \"T14\", scen = scen)\n#' # print(out$p_truth); print(out$p_pred)\npredict_maps <- function(stn_sf, truth_raster,\n                         which_time = c(\"T14\",\"T05\"),\n                         scen, models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\"),\n                         lc_levels = NULL,\n                         feature_rasters = NULL) {\n  which_time <- match.arg(which_time)\n  lc_levels  <- lc_levels %||% scen$lc_levels\n  E      <- feature_rasters$E   %||% scen$E\n  slp_r  <- feature_rasters$slp %||% scen$slp\n  cosi_r <- feature_rasters$cosi %||% if (which_time == \"T14\") scen$I14 else scen$I05\n  has_lc <- (\"lc\" %in% names(scen)) && !is.null(scen$lc)\n  lc_r   <- if (has_lc) scen$lc else NULL\n  \n  train_sf <- stn_sf\n  if (!all(c(\"x\",\"y\") %in% names(train_sf))) {\n    xy <- sf::st_coordinates(train_sf); train_sf$x <- xy[,1]; train_sf$y <- xy[,2]\n  }\n  if (!(\"z_surf\" %in% names(train_sf)))\n    train_sf$z_surf <- as.numeric(terra::extract(E,      sf::st_coordinates(train_sf))[,1])\n  if (!(\"slp\" %in% names(train_sf)))\n    train_sf$slp    <- as.numeric(terra::extract(slp_r,  sf::st_coordinates(train_sf))[,1])\n  if (!(\"cosi\" %in% names(train_sf)))\n    train_sf$cosi   <- as.numeric(terra::extract(cosi_r, sf::st_coordinates(train_sf))[,1])\n  if (has_lc && !(\"lc\" %in% names(train_sf))) {\n    lc_codes <- as.integer(terra::extract(lc_r, sf::st_coordinates(train_sf))[,1])\n    lc_codes[is.na(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    train_sf$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n  \n  xy <- as.data.frame(terra::xyFromCell(E, 1:terra::ncell(E))); names(xy) <- c(\"x\",\"y\")\n  grid_df <- xy\n  grid_df$z_surf <- as.numeric(terra::values(E))\n  grid_df$slp    <- as.numeric(terra::values(slp_r))\n  grid_df$cosi   <- as.numeric(terra::values(cosi_r))\n  if (has_lc) {\n    lc_codes <- as.integer(terra::values(lc_r))\n    lc_codes[!is.finite(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    grid_df$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\",\"y\"),\n                          crs = sf::st_crs(train_sf), remove = FALSE)\n  \n  use_lc <- has_lc && (\"lc\" %in% names(train_sf)) && (\"lc\" %in% names(grid_sf))\n  if (use_lc) {\n    lev <- levels(droplevels(factor(train_sf$lc)))\n    train_sf$lc <- factor(as.character(train_sf$lc), levels = lev)\n    grid_sf$lc  <- factor(as.character(grid_sf$lc),  levels = lev)\n    if (anyNA(train_sf$lc) || anyNA(grid_sf$lc)) {\n      use_lc <- FALSE; train_sf$lc <- NULL; grid_sf$lc <- NULL\n    }\n  }\n  \n  pred_list <- list()\n  if (\"Voronoi\" %in% models) pred_list$Voronoi <- pred_Voronoi(train_sf, grid_sf)\n  if (\"IDW\"     %in% models) pred_list$IDW     <- pred_IDW    (train_sf, grid_sf, idp = 2)\n  if (\"OK\"      %in% models) pred_list$OK      <- pred_OK     (train_sf, grid_sf)\n  if (\"KED\"     %in% models) pred_list$KED     <- pred_KED    (train_sf, grid_sf)\n  if (\"RF\"      %in% models) {\n    dtr <- sf::st_drop_geometry(train_sf)\n    rf_vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (use_lc) \"lc\")\n    dtr <- stats::na.omit(dtr[, c(\"temp\", rf_vars), drop = FALSE])\n    pred_list$RF <- if (nrow(dtr) >= 5) {\n      rf <- randomForest::randomForest(stats::as.formula(paste(\"temp ~\", paste(rf_vars, collapse = \" + \"))),\n                                       data = dtr, na.action = na.omit)\n      as.numeric(stats::predict(rf, sf::st_drop_geometry(grid_sf)[, rf_vars, drop = FALSE]))\n    } else rep(NA_real_, nrow(grid_sf))\n  }\n  if (\"GAM\"     %in% models) pred_list$GAM     <- pred_GAM    (train_sf, grid_sf)\n  \n  pred_df <- dplyr::bind_rows(lapply(names(pred_list), function(nm) {\n    tibble::tibble(model = nm, x = grid_df$x, y = grid_df$y, pred = pred_list[[nm]])\n  }))\n  \n  make_r <- function(vals, template = E) { r <- terra::rast(template); terra::values(r) <- as.numeric(vals); r }\n  pred_rasters <- lapply(pred_list, make_r)\n  \n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE)\n  names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  lims <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n  \n  p_pred <- ggplot2::ggplot(pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette(256), limits = lims,\n                                  oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time),\n                  x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3)\n  \n  p_truth <- ggplot2::ggplot(truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette(256), limits = lims,\n                                  oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time),\n                  x = \"Easting\", y = \"Northing\")\n  \n  list(pred_df = pred_df, pred_rasters = pred_rasters, p_pred = p_pred, p_truth = p_truth)\n}\n```\n````\n:::\n\n\n\n3.  **Scenarios (data & geometry):** `scenarios/` + `registry.R`. Each\n    scenario provides a `make()` factory returning a standard **object\n    contract** (see below). `registry.R` maps a name to its builder;\n    `source_scenario(name)` returns the `make()` function. Scenarios\n    control domain rasters, station sets, and recommended block size.\n    \n    \n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\n# =====================================================================\n# block4_5/scenarios/lake_bump_dense.R\n# Benötigt: source(\"block4_5/src/pipemodel_functions.R\") davor\n# Definiert: SCEN_NAME, SCEN_DESC, make(...)\n# =====================================================================\n\nSCEN_NAME <- \"lake_bump_dense\"\nSCEN_DESC <- \"Valley with lake (right), bump hill (left) + dense micro-hills; random stations.\"\n\n# Defaults so wie bisher genutzt (nur Settings/Parameter)\n.defaults <- list(\n  # Domain\n  center_E = 600000, center_N = 5725000,\n  len_x = 600, len_y = 400, res = 10, crs = \"EPSG:32632\",\n  \n  # Topographie-Features\n  lake_mode = \"water\",   # \"none\" | \"water\" | \"hollow\"\n  hill_mode = \"bump\",    # \"none\" | \"bump\"\n  lake_diam_m  = 100, lake_depth_m = 500, smooth_edges = FALSE,\n  hill_diam_m  = 100, hill_height_m = 500, hill_smooth  = FALSE,\n  \n  # micro-relief\n  random_hills        = 50,\n  micro_hill_diam_m   = 30,\n  micro_hill_height_m = 50,\n  micro_hill_smooth   = FALSE,\n  micro_seed          = NULL,\n  \n\n  # Sonne/Geo\n  lat = 51.8, lon = 10.6, sun_date = as.Date(\"2024-06-21\"),\n  \n  # Stationen\n  station_mode = \"random\",  # \"random\" | \"ns_transect\" | \"ew_transect\"\n  n_st = 60,\n  transect_margin_m = 10,\n  ns_offset_m = 0,\n  ew_offset_m = 0,\n  \n  # Modelle + Block-CV\n  models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\"),\n  block_size = NA_real_    # wenn NA -> automatisch berechnet\n)\n\n# einfaches Mergen (ohne Seiteneffekte)\n.merge <- function(a, b) { a[names(b)] <- b; a }\n\n# ---------------------------------------------------------------------\n# make(overrides = list(), do_cv = FALSE)\n# baut Domain -> Szenario -> Stationen -> (optional) CV\n# nutzt ausschließlich Funktionen aus pipemodel_functions.R\n# ---------------------------------------------------------------------\nmake <- function(overrides = list(), do_cv = FALSE) {\n  p <- .merge(.defaults, overrides)\n  \n  # 1) Domain\n  domain <- make_domain(\n    center_E = p$center_E, center_N = p$center_N,\n    len_x = p$len_x, len_y = p$len_y, res = p$res, crs = p$crs\n  )\n  \n  # 2) Szenario (Topographie/Physikfelder)\n  scen <- build_scenario(\n    domain       = domain,\n    lake_mode    = p$lake_mode,\n    hill_mode    = p$hill_mode,\n    \n    # <<< diese Zeilen fehlten bisher\n    lake_diam_m  = p$lake_diam_m,\n    lake_depth_m = p$lake_depth_m,\n    smooth_edges = p$smooth_edges,\n    hill_diam_m  = p$hill_diam_m,\n    hill_height_m= p$hill_height_m,\n    hill_smooth  = p$hill_smooth,\n    # >>>\n    \n    # micro-relief\n    random_hills        = p$random_hills,\n    micro_hill_diam_m   = p$micro_hill_diam_m,\n    micro_hill_height_m = p$micro_hill_height_m,\n    micro_hill_smooth   = p$micro_hill_smooth,\n    micro_seed          = p$micro_seed,\n    \n    # Sonne/Geo\n    lat = p$lat, lon = p$lon, sun_date = p$sun_date\n  )\n  \n  # 3) Stationen\n  pts_sf <- make_stations(\n    domain,\n    n_st = p$n_st,\n    station_mode = p$station_mode,\n    transect_margin_m = p$transect_margin_m,\n    ns_offset_m = p$ns_offset_m,\n    ew_offset_m = p$ew_offset_m\n  )\n  \n  # 4) Station-Features/Targets extrahieren\n  stns <- stations_from_scenario(scen, pts_sf)\n  stn_sf_14 <- stns$T14\n  stn_sf_05 <- stns$T05\n  \n  # 5) Blockgröße\n  block_size <- if (is.finite(p$block_size)) {\n    as.numeric(p$block_size)\n  } else {\n    compute_block_size(\n      len_x = domain$xmax - domain$xmin,\n      len_y = domain$ymax - domain$ymin,\n      n_st  = p$n_st\n    )\n  }\n  \n  out <- list(\n    name       = SCEN_NAME,\n    desc       = SCEN_DESC,\n    params     = p,\n    domain     = domain,\n    scen       = scen,\n    pts_sf     = pts_sf,\n    stn_sf_14  = stn_sf_14,\n    stn_sf_05  = stn_sf_05,\n    block_size = block_size\n  )\n  \n  # 6) Optional: Block-CV (nur wenn gewünscht)\n  if (isTRUE(do_cv)) {\n    out$cv <- list(\n      T14 = run_for_time(stn_sf_14, scen$R14, \"T14\",\n                         scen_local = scen, block_m = block_size, models = p$models),\n      T05 = run_for_time(stn_sf_05, scen$R05, \"T05\",\n                         scen_local = scen, block_m = block_size, models = p$models)\n    )\n  }\n  \n  out\n}\n# =====================================================================\n```\n````\n:::\n\n\n\n## Pipeline stages \n\n### Setup model\n\n1.  **Setup** Source `packages.R`; disable `s2` for robust planar ops in\n    projected UTM domains; set seeds. Source core helpers and the\n    scenario registry.\n\n2.  **Scenario selection & build** Select `scen_name` via\n    `Sys.getenv(\"SCEN\", \"<default>\")`.\n    `make_fun <- source_scenario(scen_name)` → `obj <- make_fun()`.\n\n3.  **Sanity checks** Assert `E`, `R14`, `R05` exist;\n    `sun$T14`/`sun$T05` include numeric `alt`,`az`.\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n\n4.  **Live preview (no side effects)** Quick plots to catch wiring/CRS\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n    issues early: land-cover + terrain overview, 2×2 domain panel, a\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n    scenario preview.\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n\n::: {.callout-note title=\"Overview Setup\" icon=\"false\" collapse=\"true\"}\n\n\n\n| Step | Function/Call                                                 | Purpose                        | Key args (examples)         | Output                                                   |\n| ---- | ------------------------------------------------------------- | ------------------------------ | --------------------------- | -------------------------------------------------------- |\n| S1   | `source(here::here(\"block4_5/src/packages.R\"))`               | Load packages & global options | –                           | Packages loaded                                          |\n| S2   | `sf::sf_use_s2(FALSE)`                                        | Robust planar ops in UTM       | –                           | s2 disabled                                              |\n| S3   | `source(here::here(\"block4_5/src/fun_pipemodel.R\"))`          | Plot/feature/scale utilities   | –                           | Helper funcs                                             |\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n| S4   | `source(here::here(\"block4_5/src/fun_learn_predict_core.R\"))` | Learn/validate/predict core    | –                           | Core funcs                                               |\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n| S5   | `source(here::here(\"block4_5/scenarios/registry.R\"))`         | Scenario registry              | –                           | `source_scenario()`                                      |\n| S6   | `make_fun <- source_scenario(scen_name)`                      | Select scenario                | `scen_name`                 | `make()` factory                                         |\n| S7   | `obj <- make_fun()`                                           | Build scenario object          | `overrides`, `do_cv` (opt.) | `scen`, `stn_sf_14`, `stn_sf_05`, `block_size`, `params` |\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n**Scenario object** `obj` (returned by `make()`):\n\n-   `scen`: named list of rasters and metadata\n\n    -   `E`: DEM (reference geometry)\n    -   `R14`, `R05`: truth rasters for \\~14 UTC and \\~05 UTC\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    -   `lc`: land-cover raster (optional; with `scen$lc_levels`)\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n    -   `sun`: list with `T14` and `T05`, each having numeric `alt` and\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n        `az` (mandatory for R\\* tuning)\n    -   optional helpers (illumination, indices) as needed by\n        features/plots\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n\n-   `stn_sf_14`, `stn_sf_05`: `sf` point layers with at least `temp` and\n    covariate fields\n\n-   `block_size`: integer (meters) used for leave-block-out CV\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n-   `params$models`: character vector of learner names to run\n\n**Tuned feature rasters \\@ R\\*** (produced later):\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n\n-   `Es` (smoothed DEM), `slp` (slope from Es), `cosi` (cosine of\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n    incidence given sun `alt`,`az`)\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n\n:::\n\n### Learning and Predicting\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n1.  **Baseline learning & maps** For each time slice (`T14`, `T05`):\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n    -   `run_for_time(st, R, \"Txx\", scen_local=scen, block_m=block_size, models=mods)`\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    -   Produces: CV **metrics** (MAE/RMSE/R²), **blocks plot** (spatial\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        CV folds), **diag plot** (pred vs obs), **truth & prediction**\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        maps.\n\n2.  **Scale inference & tuning**\n\n    -   **Variogram → L50/L95:**\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n        `compute_Ls_from_points(st, value_col=\"temp\")` returns empirical\n        variogram and correlation scales; plotting highlights L50/L95.\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n    -   **U-curve → R\\*:**\n<!-- FIGURE: UCurve_T14 — p_uc14: CV error vs radius; mark R*. -->\n<!-- FIGURE: UCurve_T05 — p_uc05: CV error vs radius; mark R*. -->\n::: {.callout-tip}\n**What `n_grid` controls**\n- Number of candidate radii scanned between L50 and L95; higher = finer search, more compute.\n:::\n        `tune_Rstar_ucurve(st, E, alt, az, L50, L95, block_fallback, n_grid)`\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n        scans smoothing radii around \\[L50, L95\\] to find the\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n        RMSE-minimizer **R\\*** via spatial CV.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    -   **Features \\@ R\\*:**\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n        `smooth_dem_and_derive(E, alt, az, radius_m=R*)` → `Es`, `slp`,\n<!-- FIGURE: UCurve_T14 — p_uc14: CV error vs radius; mark R*. -->\n<!-- FIGURE: UCurve_T05 — p_uc05: CV error vs radius; mark R*. -->\n::: {.callout-tip}\n**What `n_grid` controls**\n- Number of candidate radii scanned between L50 and L95; higher = finer search, more compute.\n:::\n        `cosi`.\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n    -   **Re-extract station features \\@ R\\*:**\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n        `add_drifts_at_R(st, E, alt, az, R*, lc=..., lc_levels=...)`\n<!-- FIGURE: UCurve_T14 — p_uc14: CV error vs radius; mark R*. -->\n<!-- FIGURE: UCurve_T05 — p_uc05: CV error vs radius; mark R*. -->\n::: {.callout-tip}\n**What `n_grid` controls**\n- Number of candidate radii scanned between L50 and L95; higher = finer search, more compute.\n:::\n        aligns training features with tuned rasters.\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n    -   **Tuned CV:**\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        `run_lbo_cv(st_R, E=scen$E, block_size=block_size, models=mods)`\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        → updated metrics and CV table.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    -   **Tuned maps:**\n<!-- TABLE: Metrics_T14_Tuned — bench14$metrics. -->\n<!-- TABLE: Metrics_T05_Tuned — bench05$metrics. -->\n<!-- MAP: Panel_T14_Tuned — first page of panel_T14 (truth | preds | residuals). -->\n<!-- MAP: Panel_T05_Tuned — first page of panel_T05. -->\n        `predict_maps(st_R, truth_raster=Rxx, which_time=\"Txx\", scen, models, lc_levels, feature_rasters=list(E=Es, slp=slp, cosi=cosi))`.\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n    -   **Panels & diagnostics:**\n<!-- TABLE: Metrics_T14_Tuned — bench14$metrics. -->\n<!-- TABLE: Metrics_T05_Tuned — bench05$metrics. -->\n<!-- MAP: Panel_T14_Tuned — first page of panel_T14 (truth | preds | residuals). -->\n<!-- MAP: Panel_T05_Tuned — first page of panel_T05. -->\n        `build_panels_truth_preds_errors_paged(...)` shows truth \\|\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n        predictions \\| residual diagnostics.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    -   **Error budgets (optional):** `simple_error_budget(...)`\n<!-- TABLE: ErrorBudget_T14_T05 — eb_all (instrument/micro/meso in °C²; add Value_SD). -->\n<!-- FIGURE: ErrorBudget_Stacked — p_eb stacked bars by Time × Mode. -->\n::: {.callout-important}\n**How to read the budget**\n- **Instrument**: fixed sensor noise (σ_inst²).\n- **Microscale**: α × (Total − Instrument).\n- **Mesoscale**: (1−α) × (Total − Instrument).\n- Prefer **α** from residual variogram nugget fraction (CV residuals).\n:::\n        aggregates instrument/micro/meso components;\n        `plot_error_budget()` stacks them for base vs tuned.\n<!-- TABLE: Metrics_T14_Tuned — bench14$metrics. -->\n<!-- TABLE: Metrics_T05_Tuned — bench05$metrics. -->\n<!-- MAP: Panel_T14_Tuned — first page of panel_T14 (truth | preds | residuals). -->\n<!-- MAP: Panel_T05_Tuned — first page of panel_T05. -->\n   \n::: {.callout-note title=\"Modeling, Prediction & Tuning\" icon=\"false\" collapse=\"true\"}\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n\n| Step | Function/Call                                                                                                                                                                                    | Purpose                          | Key args (examples)                    | Output                                                            |                 |                  |\n| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------- | -------------------------------------- | ----------------------------------------------------------------- | --------------- | ---------------- |\n| P1   | `plot_landcover_terrain(scen, stations = st14, layout=\"vertical\")`                                                                                                                               | Quick domain sanity check        | `scen`, `stations`                     | `ggplot`                                                          |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P2   | `plot_block_overview_2x2_en(scen, pts_sf = st14)`                                                                                                                                                | 2×2 overview                     | `scen`, `pts_sf`                       | `ggplot`                                                          |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P3   | `preview_scenario(obj)`                                                                                                                                                                          | Scenario preview                 | `obj`                                  | Panels/plots                                                      |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P4   | `run_for_time(st14, scen$R14, \"T14\", scen_local = scen, block_m = bs, models = mods)`                                                                                                            | **Baseline** LBO-CV + maps (T14) | stations, truth raster, blocks, models | `res={metrics, blocks_plot, diag_plot}`, `maps={p_truth, p_pred}` |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P5   | `run_for_time(st05, scen$R05, \"T05\", …)`                                                                                                                                                         | **Baseline** (T05)               | as above                               | as above                                                          |                 |                  |\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n| P6   | `Ls14 <- compute_Ls_from_points(st14, value_col=\"temp\")`                                                                                                                                         | Variogram & scales (T14)         | stations, value col                    | `{vg, L50, L95, sill}`                                            |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P7   | `plot_variogram_with_scales(Ls14$vg, Ls14$L50, Ls14$L95, Ls14$sill, \"…\")`                                                                                                                        | Variogram plot                   | variogram + scales                     | `ggplot`                                                          |                 |                  |\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n| P8   | `tune_Rstar_ucurve(st14, scen$E, alt=scen$sun$T14$alt, az=scen$sun$T14$az, L50=Ls14$L50, L95=Ls14$L95, block_fallback=bs, n_grid=6)`                                                             | U-curve → **R\\*** (T14)          | stations, DEM, sun, L50/L95            | `{grid, R_star, block_m}`                                         |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P9   | `fr14 <- smooth_dem_and_derive(scen$E, scen$sun$T14$alt, scen$sun$T14$az, radius_m=tune14$R_star)`                                                                                               | Features @ **R\\***               | DEM, sun, R\\*                          | `{Es, slp, cosi}`                                                 |                 |                  |\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n| P10  | `st14_R <- add_drifts_at_R(st14, scen$E, scen$sun$T14$alt, scen$sun$T14$az, tune14$R_star, lc=scen$lc, lc_levels=scen$lc_levels)`                                                                | Station features @ **R\\***       | stations, DEM, sun, R\\*, LC            | `sf` with drifts                                                  |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P11  | `bench14 <- run_lbo_cv(st14_R, E=scen$E, block_size=bs, models=mods)`                                                                                                                            | **Tuned** LBO-CV (T14)           | tuned stations, DEM, blocks, models    | `{metrics, cv, …}`                                                |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P12  | `maps14_tuned <- predict_maps(st14_R, truth_raster=scen$R14, which_time=\"T14\", scen=scen, models=mods, lc_levels=scen$lc_levels, feature_rasters=list(E=fr14$Es, slp=fr14$slp, cosi=fr14$cosi))` | Maps @ **R\\*** (T14)             | tuned stations + features              | Pred rasters/plots                                                |                 |                  |\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n| P13  | `panel_T14 <- build_panels_truth_preds_errors_paged(maps14_tuned, scen$R14, bench14$cv, \"T14\", models_per_page=7, scatter_next_to_truth=TRUE)`                                                   | Truth                            | preds                                  | residuals panel                                                   | maps, truth, CV | list of `ggplot` |\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n| P14  | `simple_error_budget(run14$res, sigma_inst=0.5, alpha=0.6)`                                                                                                                                      | Error budget (baseline/tuned)    | CV results, params                     | tidy table                                                        |                 |                  |\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n> Mirror P6–P14 for **T05** with `st05`, `R05`, `sun$T05`.        \n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n:::\n\n\n### Saving  Results\n\n3.  **Exports (optional, end-only side effects)** Controlled by\n    `export <- TRUE/FALSE`. When `TRUE`:\n\n    -   Create `results_<scen-name>/{fig,tab,ras}`.\n    -   Save baseline and tuned plots (previews, CV blocks/diag,\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n        truth/pred, variograms, U-curves, panels).\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n    -   Save tables (metrics, U-curve grid, scales L50/L95/R\\*, error\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n        budgets).\n    -   Save rasters (`E`, `R14`, `R05`, `lc` if present).\n    -   Write `sessionInfo()`.\n    \n::: {.callout-note title=\"Documentation & Export\" icon=\"false\" collapse=\"true\"}\n\n| Step | Function/Call                                                                          | Purpose                   | Key args (examples) | Output            |\n| ---- | -------------------------------------------------------------------------------------- | ------------------------- | ------------------- | ----------------- |\n| D1   | `fn_fig(\"name\")`, `fn_ras(\"name\")`                                                     | Build output paths        | stems, ext          | file paths        |\n| D2   | `save_plot_min(p, fn_fig(\"plot_name\"))`                                                | Save plot safely          | `ggplot`, size, dpi | PNG               |\n| D3   | `safe_save_plot(p, fn_fig(\"plot_name\"))`                                               | Try-save without aborting | plot, path          | PNG (best-effort) |\n| D4   | `save_table_readable(df, file_stem, title=..., digits=3)`                              | Save tables               | data.frame, stem    | CSV/HTML/XLSX     |\n| D5   | `save_raster_min(r, fn_ras(\"raster_name\"))`                                            | Save raster (GeoTIFF)     | SpatRaster, path    | TIF               |\n| D6   | `terra::writeRaster(r, fn_ras(\"name\"), overwrite=TRUE)`                                | Low-level raster write    | raster, path        | TIF               |\n| D7   | `saveRDS(sessionInfo(), file.path(out_dir, sprintf(\"%s_sessionInfo.rds\", scen_name)))` | Session record            | scen name           | RDS               |\n\n:::\n\n# Learners and how proximity/process enter\n\n-   **Mean vs Residual:** Process drivers enter the **mean** via\n    features (e.g., `Es`, `slp`, `cosi`, `lc`); remaining spatial\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n    dependence is handled via model structure and block CV.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n-   **Supported learners (by `params$models`):** typical set includes\n    *Nearest Neighbor, IDW, OK, KED, TPS, TIN, GAM, RF*. **KED/GAM/RF:** covariate means use R\\*-tuned features to\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n        match process scale.\n\n\n-   **Validation:** **Leave-block-out CV** with block size from scenario\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n    (or linked to R\\*) avoids optimistic scores; folds respect the\n::: {.callout-tip}\n**Model reading guide**\n- **RF**: nonlinear mean; consider **residual kriging** if spatial correlation persists.\n- **KED**: drivers in the mean + variogram on residuals.\n- **OK**: pure spatial autocorrelation + uncertainty.\n- **GAM**: smooth mean; check residuals for remaining structure.\n:::\n    working spatial resolution.\n\n# Assumptions & knobs you control\n\n-   **Scale grid:** `n_grid` in U-curve (e.g., 5–9) around \\[L50, L95\\].\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n-   **Block size:** from scenario (`block_size`) or derived from R\\*.\n-   **Models:** `obj$params$models` controls learners to run.\n-   **Error budget:** `sigma_inst`, `alpha` determine instrument vs\n<!-- TABLE: ErrorBudget_T14_T05 — eb_all (instrument/micro/meso in °C²; add Value_SD). -->\n<!-- FIGURE: ErrorBudget_Stacked — p_eb stacked bars by Time × Mode. -->\n::: {.callout-important}\n**How to read the budget**\n- **Instrument**: fixed sensor noise (σ_inst²).\n- **Microscale**: α × (Total − Instrument).\n- **Mesoscale**: (1−α) × (Total − Instrument).\n- Prefer **α** from residual variogram nugget fraction (CV residuals).\n:::\n    microscale vs mesoscale split.\n-   **Exports:** controlled globally with `export <- TRUE/FALSE`.\n\n\n### Error budget — idea, concept, and purpose\n<!-- TABLE: ErrorBudget_T14_T05 — eb_all (instrument/micro/meso in °C²; add Value_SD). -->\n<!-- FIGURE: ErrorBudget_Stacked — p_eb stacked bars by Time × Mode. -->\n::: {.callout-important}\n**How to read the budget**\n- **Instrument**: fixed sensor noise (σ_inst²).\n- **Microscale**: α × (Total − Instrument).\n- **Mesoscale**: (1−α) × (Total − Instrument).\n- Prefer **α** from residual variogram nugget fraction (CV residuals).\n:::\n\n**Idea.**\nTurn the overall CV error ($\\sigma_{\\text{cv}}^2 \\approx \\text{RMSE}^2$) into a *story* of where it comes from:\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n\n1. **Instrument** (sensor noise you assume),\n2. **Microscale** (sub-grid, representativeness),\n3. **Mesoscale** (larger-scale, unmodelled structure).\n\n**Concept.**\n\n* First peel off a **fixed** instrument part using your sensor SD (`sigma_inst`).\n<!-- TABLE: ErrorBudget_T14_T05 — eb_all (instrument/micro/meso in °C²; add Value_SD). -->\n<!-- FIGURE: ErrorBudget_Stacked — p_eb stacked bars by Time × Mode. -->\n::: {.callout-important}\n**How to read the budget**\n- **Instrument**: fixed sensor noise (σ_inst²).\n- **Microscale**: α × (Total − Instrument).\n- **Mesoscale**: (1−α) × (Total − Instrument).\n- Prefer **α** from residual variogram nugget fraction (CV residuals).\n:::\n* Split the **leftover** between **micro** and **meso** with **α**.\n<!-- FIGURE: UCurve_T14 — p_uc14: CV error vs radius; mark R*. -->\n<!-- FIGURE: UCurve_T05 — p_uc05: CV error vs radius; mark R*. -->\n::: {.callout-tip}\n**What `n_grid` controls**\n- Number of candidate radii scanned between L50 and L95; higher = finer search, more compute.\n:::\n\n  * Prefer **α from the residual variogram’s nugget fraction** (on **CV residuals**): nugget ≈ micro.\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n  * Otherwise use a **site heuristic** (open 0.2–0.4; mixed 0.4–0.6; complex 0.6–0.8).\n\n**What for.**\n\n* **Diagnose limits:** Is error dominated by **instrument**, **micro** (representativeness), or **meso** (missing process/scale)?\n* **Guide action:**\n\n  * Big **instrument** → sensor QA, shielding, calibration.\n  * Big **micro** → finer scale (**R\\***), denser stations, better canopy/roughness features.\n<!-- MAP: Landcover_Terrain_Preview — Output from plot_landcover_terrain(scen, stations=st14). -->\n<!-- FIGURE: Block_Overview_2x2 — Output from plot_block_overview_2x2_en(scen, pts_sf=st14). Shows blocks and CRS sanity. -->\n  * Big **meso** → add process covariates (drift), anisotropy/cost metrics, rethink neighborhood/blocks.\n* **Compare models/scenarios:** Same RMSE can hide very different error structures.\n* **Communicate uncertainty:** Bars in **°C²** (optionally show SD by √).\n\n**Why `σ_inst` and α.**\n\n* `σ_inst` externalizes **known** noise (you choose it from specs/co-location).\n* **α** makes the remaining variance **interpretable** by scale: micro (< \\~R\\*/2) vs meso (≳ \\~R\\*).\n\n**Practical workflow.**\n\n1. Compute CV errors → overall variance.\n<!-- TABLE: Metrics_T14_Base — run14$res$metrics (RMSE/MAE/R2 per model). -->\n<!-- TABLE: Metrics_T05_Base — run05$res$metrics. -->\n<!-- FIGURE: BlocksPlot_T14_Base — run14$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T14_Base — run14$res$diag_plot (pred vs obs). -->\n<!-- MAP: Truth_T14_Base — run14$maps$p_truth. -->\n<!-- MAP: Pred_T14_Base — run14$maps$p_pred (choose key model). -->\n<!-- FIGURE: BlocksPlot_T05_Base — run05$res$blocks_plot. -->\n<!-- FIGURE: Scatter_T05_Base — run05$res$diag_plot. -->\n<!-- MAP: Truth_T05_Base — run05$maps$p_truth. -->\n<!-- MAP: Pred_T05_Base — run05$maps$p_pred. -->\n2. Set `σ_inst`.\n3. Get **α** from **residual variogram nugget fraction** (per time/model), fallback to heuristic.\n<!-- FIGURE: Variogram_T14 — p_vg14: empirical variogram with L50/L95 markers. -->\n<!-- FIGURE: Variogram_T05 — p_vg05: empirical variogram with L50/L95 markers. -->\n::: {.callout-tip}\n**Reading L50/L95**\n- **L50** = typical correlation length; **L95** = upper bound for useful correlation.\n- Use L50–L95 as the **U-curve search window**.\n:::\n4. Report **instrument / micro / meso** components; act on the largest slice.\n\n\nHere’s the plain-English read of your results.\n\n### T14 (daytime)\n\n* **Total variance:** 0.206 °C² (RMSE ≈ 0.452 °C).\n* **Instrument:** 0.116 °C² → **\\~56%** of total (SD ≈ 0.34 °C).\n* **Microscale:** 0.0496 °C² → **\\~24%** (SD ≈ 0.22 °C).\n* **Mesoscale:** 0.0401 °C² → **\\~20%** (SD ≈ 0.20 °C).\n\n**Interpretation:** Most error is explained by sensor noise. The remaining \\~44% splits fairly evenly between **sub-grid/representativeness** (micro) and **larger-scale unmodeled structure** (meso). Both small-scale heterogeneity and some broader process signal are still in play.\n\n### T05 (pre-dawn)\n\n* **Total variance:** 0.362 °C² (RMSE ≈ 0.600 °C).\n* **Instrument:** 0.185 °C² → **\\~51%** of total (SD ≈ 0.43 °C).\n* **Microscale:** **≈ 0**.\n* **Mesoscale:** 0.177 °C² → **\\~49%** (SD ≈ 0.42 °C).\n\n**Interpretation:** About half the error is sensor noise. **Nearly all** of the leftover is **mesoscale**, i.e., smoother, broader structure that the mean/residual model hasn’t captured (e.g., nocturnal drainage patterns, advection, or missing covariates). A near-zero micro slice is plausible at night when fields are smoother at the station spacing.\n\n### Net takeaway\n\n* **T14:** Sensor noise dominates; the rest is a balanced mix of micro and meso → both better micro-scale features (or finer R\\*) and some added process covariates could help.\n<!-- MAP: Feature_Es_T14 — Smoothed DEM at R* (Es) for T14. -->\n<!-- MAP: Feature_cosi_T14 — Cosine of incidence at R* using sun T14 (alt/az). -->\n<!-- MAP: Feature_slope_T14 — Slope from Es at R*. -->\n<!-- MAP: Feature_Es_T05 — Smoothed DEM at R* (Es) for T05. -->\n<!-- MAP: Feature_cosi_T05 — Cosine of incidence at R* using sun T05 (alt/az). -->\n<!-- MAP: Feature_slope_T05 — Slope from Es at R*. -->\n::: {.callout-note}\n**Why sun geometry matters**\nFeatures like **cosi** depend on `alt/az` and must match the time slice (T14/T05).\n:::\n* **T05:** Sensor \\~half; remainder is **meso-dominated** → focus on **process/scale** (e.g., flow-aligned/anisotropic metrics, cost distance, additional nocturnal drivers).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}