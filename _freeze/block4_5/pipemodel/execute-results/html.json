{
  "hash": "d04539595212d5974c78aae66a9f556e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel: A simple valley microclimate sandbox (6-scenario edition)\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    code-fold: show\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\n\n# Why the **pipemodel**?\n\nThe **pipemodel** is a deliberately idealized yet physically plausible valley scenario. It distills terrain to the essentials (parabolic “half-pipe” cross-valley shape with a well-defined axis) and lets you toggle a **left-side hill** and a **right-side pond/hollow**. This keeps the **dominant microclimate drivers** separable and visible, making it a **teaching and test bench** for sensor network design, modeling, and interpolation.\n\n![](pipe.png){fig-align=\"center\" width=\"503\"}\n\n## Realistic physics despite idealized geometry\n\n-   **Radiation & sun exposure:** Slope/aspect drive a cosine-of-incidence (*cos i*) term to mimic direct shortwave variations.\n-   **Albedo & surface type:** A water patch differs from grass—typically **cooler at midday** (less net heating) and **warmer before sunrise** (heat release).\n-   **Elevation:** A daytime **negative lapse rate** and a nighttime **weak inversion** reproduce common valley conditions.\n-   **Cold-air processes:** A Gaussian cold-air pool along the axis represents radiative cooling, drainage, and pooling near the floor. Over the **hill**, pooling effectiveness can be reduced (scale/flow interaction).\n\n## Why this shape with a left hill and right pond?\n\nThe half-pipe geometry **maximizes contrast** between north/south slopes, floor, and rims. Offsetting the **hill (left third)** and **pond/hollow (right third)** adds **scale and interaction**: exposure vs pooling vs surface type. This makes **spatially distributed controls**—radiation, height, slope, distance to axis, land–water—**visible and quantifiable** without many confounders.\n\n## What can we study with it?\n\n-   **Effects of single drivers:** Sensitivities of temperature to elevation, aspect/exposure, pool width/amplitude, land–water differences, and hill–pool interactions.\n-   **Scale questions:** From 5 m pixels to transects/stations to the full valley, and across times of day (05 vs 14 UTC).\n-   **Sensor network design:** Movable N–S / E–W transects show how placement governs captured variability and interpolation skill.\n-   **Robust evaluation:** We have a known **“truth” field**. Extract station values and fit **interpolators/predictors** (IDW/OK/TPS/GAM/RF/Kriging variants) and verify against truth (RMSE/MAE/bias, profiles, residual maps).\n\n## Value for transfer to real sites\n\nBecause relationships are **simple and interpretable**, the pipemodel shows **which covariates** (elevation, exposure, distance to axis, surface type, hill effects) matter **where** and **when**. That underpins taking a small set of station measurements, **learning the spatial relationships**, and **interpolating reliably** in real landscapes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chunk defaults (nice figures)\nknitr::opts_chunk$set(fig.width = 8, fig.height = 5, dpi = 150)\n```\n:::\n\n\n\n# 0) Global setup\n\nThis document synthesizes a **half-pipe valley** (UTM 32N, Harz), adds a **left-side hill** and a **right-side pond/hollow**, computes **midday** and **pre-dawn** temperature fields, places stations along **movable transects**, and visualizes: faceted maps for **all 6 scenarios**, a **dumbbell plot** and **temperature vs elevation** for **all scenarios**, plus a **station table** and optional **rayshader** for one chosen scenario.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages\nset.seed(42)\npkgs <- c(\"terra\",\"sf\",\"ggplot2\",\"scales\",\"suncalc\",\"dplyr\",\"tibble\",\"tidyr\")\nmissing <- setdiff(pkgs, rownames(installed.packages()))\nif (length(missing)) install.packages(missing, dependencies = TRUE)\ninvisible(lapply(pkgs, require, character.only = TRUE))\n\n# ---------- Global knobs (easy to tweak) ----------\n# Plot/scale\ncontour_size <- 0.10\ncontour_bins <- 6\nstretch_q    <- c(0.02, 0.98)   # quantile stretch for fair viz\n\n# Temperature palette: BLUE (cold) -> RED (warm), no white/green\ntemp_palette <- colorRampPalette(c(\"#0000FF\", \"#FF0000\"))(256)\n\n# Pond / hollow (RIGHT third)\nlake_diam_m   <- 80\nlake_depth_m  <- 10\nsmooth_edges  <- FALSE  # TRUE = smooth parabola rim; FALSE = sharp disk\n\n# Hill (LEFT third)\nhill_diam_m    <- 80\nhill_height_m  <- 50\nhill_smooth    <- FALSE  # TRUE = Gaussian bump; FALSE = flat dome\n\n# Night pooling weakening over hill (0 = none, 1 = cancel where hill stands)\npool_block_gain <- 0.4\n\n# Station placement — ONLY transects (or random)\n# \"random\" | \"ns_transect\" | \"ew_transect\"\nstation_mode      <- \"ns_transect\"\nn_st              <- 20\ntransect_margin_m <- 10\n# Offsets for shifting transects away from valley center:\nns_offset_m <-  0   # for N–S transect: + east / - west  (x-direction)\new_offset_m <-  0   # for E–W transect: + north / - south (y-direction)\n\n# Rayshader output (single scenario, chosen below)\nrayshader_mode      <- \"off\"          # \"viewer\" | \"window\" | \"snapshot\" | \"off\"\nrayshader_scenario  <- \"T14\"          # \"T14\" or \"T05\"\nrayshader_snapshot  <- \"halfpipe_rayshader.png\"\n\n# Which scenario to use for the station table & rayshader:\npick_hill <- \"bump\"                   # \"none\" or \"bump\"\npick_lake <- \"water\"                  # \"none\" | \"water\" | \"hollow\"\n```\n:::\n\n\n\n# 1) Coordinate system & scenario frame\n\n**Why:** A simple parabola in the **cross-valley** direction captures a bowl where **cold air pools** and **solar exposure** varies with slope. Working in **meters (UTM)** keeps lapse rates and length scales physical.\n\n**Model:** $z(x,y)=z_\\text{base} + a\\,(y-y_0)^2$ with $a$ chosen so rims are \\~100 m above the axis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Domain (UTM32N)\ncrs_utm <- \"EPSG:32632\"\nE0 <- 600000; N0 <- 5725000\nlen_x <- 500; len_y <- 300; res <- 5\n\next <- terra::ext(E0 - len_x/2, E0 + len_x/2, N0 - len_y/2, N0 + len_y/2)\nR   <- terra::rast(ext, resolution = res, crs = crs_utm)\n\nxmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\nymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\nx0   <- (xmin + xmax)/2;  y0   <- (ymin + ymax)/2\n\n# Hill & pond centers (left/right thirds)\nx_hill_center <- xmin + len_x/3      # left third\ny_hill_center <- y0\nx_lake_center <- xmin + 2*len_x/3    # right third\ny_lake_center <- y0\n```\n:::\n\n\n\n# 2) Sun geometry & helpers\n\n**Why:** The **cosine of the solar incidence** approximates direct shortwave input. Larger $\\cos i$ ⇒ more heating.\n\n**Model:** $\\cos i = \\cos s\\,\\cos Z + \\sin s\\,\\sin Z\\,\\cos(\\alpha_\\odot - \\text{asp})$, clamped to $[0,1]$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlat <- 51.8; lon <- 10.6\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  az_from_north <- (sp$azimuth + pi) %% (2*pi)   # 0=N, π/2=E, π=S, 3π/2=W\n  list(alt = sp$altitude, az = az_from_north)\n}\nsun14 <- sun_pos_utc(2024, 6, 21, 14, lat, lon)\nsun05 <- sun_pos_utc(2024, 6, 21,  5, lat, lon)\n\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci) # shadow clamp\n}\n```\n:::\n\n\n\n# 3) Shared noise & station network\n\nStations are **shared across all scenarios** so differences come only from physics/geometry changes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Re-usable noise fields\nset.seed(1001); noise14_base <- terra::setValues(terra::rast(R), rnorm(terra::ncell(R), 0, 0.3))\nset.seed(1002); noise05_base <- terra::setValues(terra::rast(R), rnorm(terra::ncell(R), 0, 0.3))\n\n# Stations (transects or random)\nif (station_mode == \"random\") {\n  pts <- tibble(\n    id = 1:n_st,\n    x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n    y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n  )\n} else if (station_mode == \"ns_transect\") {\n  x_const <- x0 + ns_offset_m\n  x_const <- min(max(x_const, xmin + transect_margin_m), xmax - transect_margin_m)\n  y_seq <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n  pts <- tibble(id = 1:n_st, x = rep(x_const, n_st), y = y_seq)\n} else if (station_mode == \"ew_transect\") {\n  y_const <- y0 + ew_offset_m\n  y_const <- min(max(y_const, ymin + transect_margin_m), ymax - transect_margin_m)\n  x_seq <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n  pts <- tibble(id = 1:n_st, x = x_seq, y = rep(y_const, n_st))\n} else {\n  stop(\"Unknown station_mode: \", station_mode)\n}\npts_sf <- sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs_utm)\nvpts   <- terra::vect(pts_sf)\n```\n:::\n\n\n\n# 4) Scenario builder (hill left, pond/hollow right)\n\nSix scenarios: **Hill ∈ {none, bump} × Lake ∈ {none, water, hollow}**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscenario_fields <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                            hill_mode = c(\"none\",\"bump\")) {\n  lake_mode <- match.arg(lake_mode)\n  hill_mode <- match.arg(hill_mode)\n  \n  # Base half-pipe elevation (parabolic across N–S)\n  XY <- as.data.frame(terra::xyFromCell(R, 1:terra::ncell(R))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / ((len_y/2)^2)          # ~100 m to rims\n  elev <- 500 + a * dy^2\n  \n  # Pond/hollow footprint at RIGHT third\n  rl   <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2)\n  lr   <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (isTRUE(smooth_edges)) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else {\n    w_l <- 0\n  }\n  \n  # Hill footprint at LEFT third\n  if (hill_mode == \"bump\") {\n    rh   <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2)\n    hr   <- max(1e-6, hill_diam_m/2)\n    w_h  <- if (isTRUE(hill_smooth)) exp(- (rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else {\n    w_h <- 0\n  }\n  \n  # Rasters\n  E     <- R; values(E)     <- elev; names(E)     <- \"elev\"\n  lakeR <- R; values(lakeR) <- if (lake_mode == \"water\") as.numeric(w_l > 0) else 0; names(lakeR) <- \"lake\"\n  pitW  <- R; values(pitW)  <- if (lake_mode %in% c(\"water\",\"hollow\")) w_l else 0; names(pitW) <- \"depW\"\n  hillW <- R; values(hillW) <- if (hill_mode == \"bump\") w_h else 0; names(hillW) <- \"hillW\"\n  \n  # Topo & sun\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n  \n  # Physics\n  E_mean    <- terra::global(E, \"mean\", na.rm=TRUE)[1,1]\n  alpha_map <- (5.0) * (1 - lakeR) + (1.5) * lakeR\n  \n  # Cold-air pooling across axis (weaken over hill footprint)\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - y0); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool      <- pool_base * (1 - pool_block_gain * hillW)\n  \n  # Temperatures (reuse noise for comparability)\n  R14 <- 26.0 + (-0.0065) * (E - E_mean) + alpha_map * I14 + noise14_base; names(R14) <- \"T14\"\n  R05 <-  8.5 + ( 0.0030) * (E - E_mean) + 0.6 * slp0 - pool + (if (lake_mode==\"water\") 1.5 else 0)*lakeR + noise05_base; names(R05) <- \"T05\"\n  \n  # Grid for facets\n  grid <- as.data.frame(c(E, pitW, hillW, R14, R05), xy=TRUE, na.rm=FALSE)\n  names(grid) <- c(\"x\",\"y\",\"elev\",\"depW\",\"hillW\",\"T14\",\"T05\")\n  \n  list(grid=grid, E=E, R14=R14, R05=R05)\n}\n```\n:::\n\n\n\n# 5) Build all 6 scenarios & shared color limits\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscenarios <- expand.grid(hill = c(\"none\",\"bump\"),\n                         lake = c(\"none\",\"water\",\"hollow\"),\n                         stringsAsFactors = FALSE)\n\ngrid_list   <- vector(\"list\", nrow(scenarios))\nrasters_map <- vector(\"list\", nrow(scenarios))\nfor (i in seq_len(nrow(scenarios))) {\n  out <- scenario_fields(lake_mode = scenarios$lake[i], hill_mode = scenarios$hill[i])\n  out$grid$Scenario <- sprintf(\"Hill: %s | Lake: %s\", scenarios$hill[i], scenarios$lake[i])\n  grid_list[[i]]    <- out$grid\n  rasters_map[[i]]  <- list(key = scenarios[i,], E = out$E, R14 = out$R14, R05 = out$R05)\n}\ngrid_all <- dplyr::bind_rows(grid_list)\n\n# Shared color limits per time across ALL scenarios\nqT14_all <- quantile(grid_all$T14, probs = stretch_q, na.rm = TRUE)\nqT05_all <- quantile(grid_all$T05, probs = stretch_q, na.rm = TRUE)\n```\n:::\n\n\n\n# 6) Temperature maps (ALL 6 scenarios)\n\n**Interpretation:** **14:00** — Negative lapse cools rims; sun-facing slopes warm via $\\alpha \\cdot \\cos i$. Water warms **less**. **05:00** — **Cold-air pool** along the axis (cool band), weak inversion (higher = a bit warmer), water **warmer** than grass. Over the **hill**, pooling is partly **suppressed**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np14_all <- ggplot() +\n  geom_raster(data = grid_all, aes(x, y, fill = T14), alpha = 0.90) +\n  geom_contour(data = grid_all, aes(x, y, z = T14),\n               bins = contour_bins, size = contour_size, colour = \"white\", alpha = 0.85, na.rm = TRUE) +\n  geom_contour(data = grid_all, aes(x, y, z = depW),  breaks = 0.5,\n               colour = \"black\", size = 0.30, alpha = 0.75, na.rm = TRUE) +   # pond/hollow rim\n  geom_contour(data = grid_all, aes(x, y, z = hillW), breaks = 0.5,\n               colour = \"black\", linetype = \"22\", size = 0.25, alpha = 0.75, na.rm = TRUE) +  # hill rim (dashed)\n  geom_point(data = pts, aes(x, y), colour = \"white\", size = 0.8) +\n  geom_text(data = pts, aes(x, y, label = id), nudge_y = 12, nudge_x = 12, size = 3, colour = \"white\") +\n  scale_fill_gradientn(name = \"Temp [°C]\", colours = temp_palette,\n                       limits = qT14_all, oob = scales::squish) +\n  coord_equal() + theme_minimal(base_size = 11) +\n  labs(title = \"Temperature — 21 Jun 14:00 UTC (ALL scenarios)\",\n       subtitle = \"Solid: pond/hollow rim · Dashed: hill footprint\") +\n  facet_wrap(~Scenario, ncol = 3)\n\np05_all <- ggplot() +\n  geom_raster(data = grid_all, aes(x, y, fill = T05), alpha = 0.90) +\n  geom_contour(data = grid_all, aes(x, y, z = T05),\n               bins = contour_bins, size = contour_size, colour = \"white\", alpha = 0.85, na.rm = TRUE) +\n  geom_contour(data = grid_all, aes(x, y, z = depW),  breaks = 0.5,\n               colour = \"black\", size = 0.30, alpha = 0.75, na.rm = TRUE) +\n  geom_contour(data = grid_all, aes(x, y, z = hillW), breaks = 0.5,\n               colour = \"black\", linetype = \"22\", size = 0.25, alpha = 0.75, na.rm = TRUE) +\n  geom_point(data = pts, aes(x, y), colour = \"white\", size = 0.8) +\n  geom_text(data = pts, aes(x, y, label = id), nudge_y = 12, nudge_x = 12, size = 3, colour = \"white\") +\n  scale_fill_gradientn(name = \"Temp [°C]\", colours = temp_palette,\n                       limits = qT05_all, oob = scales::squish) +\n  coord_equal() + theme_minimal(base_size = 11) +\n  labs(title = \"Temperature — 21 Jun 05:00 UTC (ALL scenarios)\",\n       subtitle = \"Solid: pond/hollow rim · Dashed: hill footprint\") +\n  facet_wrap(~Scenario, ncol = 3)\n\np14_all; p05_all\n```\n\n::: {.cell-output-display}\n![](pipemodel_files/figure-html/unnamed-chunk-8-1.png){width=1200}\n:::\n\n::: {.cell-output-display}\n![](pipemodel_files/figure-html/unnamed-chunk-8-2.png){width=1200}\n:::\n:::\n\n\n\n# 7) Station table (chosen scenario)\n\nWe extract station values **for one scenario** (configurable via `pick_hill`, `pick_lake`) to inspect numbers and sanity-check.\n\n![](halfpipe_rayshader.png){fig-align=\"center\" width=\"518\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_scenario_rasters <- function(hill, lake) {\n  for (i in seq_along(rasters_map)) {\n    key <- rasters_map[[i]]$key\n    if (identical(as.character(key$hill), hill) && identical(as.character(key$lake), lake)) {\n      return(list(E = rasters_map[[i]]$E, R14 = rasters_map[[i]]$R14, R05 = rasters_map[[i]]$R05))\n    }\n  }\n  stop(\"Scenario not found: hill=\", hill, \", lake=\", lake)\n}\nras_pick <- get_scenario_rasters(pick_hill, pick_lake)\n\npts_pick <- pts\npts_pick$z_surf <- terra::extract(ras_pick$E,   vpts, ID = FALSE)[,1]\npts_pick$T14    <- terra::extract(ras_pick$R14, vpts, ID = FALSE)[,1]\npts_pick$T05    <- terra::extract(ras_pick$R05, vpts, ID = FALSE)[,1]\n\nstation_table <- pts_pick |>\n  mutate(\n    easting  = round(sf::st_coordinates(pts_sf)[,1]),\n    northing = round(sf::st_coordinates(pts_sf)[,2]),\n    z_surf   = round(z_surf, 1),\n    T14_C    = round(T14, 1),\n    T05_C    = round(T05, 1)\n  ) |>\n  select(id, easting, northing, z_surf, T14_C, T05_C)\n\nstation_table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 6\n      id easting northing z_surf T14_C T05_C\n   <int>   <dbl>    <dbl>  <dbl> <dbl> <dbl>\n 1     1  600000  5724860   590.  26.8   9.3\n 2     2  600000  5724875   572.  26.7   8.5\n 3     3  600000  5724889   556.  27.2   9.2\n 4     4  600000  5724904   542.  27.8   8.2\n 5     5  600000  5724919   530.  28.3   7.8\n 6     6  600000  5724934   520.  28.5   7.9\n 7     7  600000  5724948   512.  29.3   6.5\n 8     8  600000  5724963   506.  29.7   5.1\n 9     9  600000  5724978   502.  29.7   4.8\n10    10  600000  5724993   500.  30.2   4.3\n11    11  600000  5725007   500.  30.4   5.2\n12    12  600000  5725022   502.  30     5  \n13    13  600000  5725037   506.  30.6   6  \n14    14  600000  5725052   512.  30.2   6.7\n15    15  600000  5725066   520.  30     7.3\n16    16  600000  5725081   530.  30.1   8.1\n17    17  600000  5725096   542.  29.9   7.8\n18    18  600000  5725111   556.  29.4   8.9\n19    19  600000  5725125   572.  29     9.3\n20    20  600000  5725140   584   29.4   9.2\n```\n\n\n:::\n:::\n\n\n\n**Read me:** Expect **lower 14:00** temperatures at higher elevations, and **higher 05:00** temperatures away from the axis (weaker pooling). Water pixels at 05:00 tend to be **warmer**.\n\n# 8) Dumbbell plots (ALL scenarios)\n\nSegment length is **diurnal amplitude**; larger on sun-exposed slopes, smaller over water or in persistently cool spots. Faceting makes **scenario differences** obvious.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract station values for ALL scenarios\nextract_for_all <- function() {\n  res <- vector(\"list\", length(rasters_map))\n  for (i in seq_along(rasters_map)) {\n    key <- rasters_map[[i]]$key\n    scen_label <- sprintf(\"Hill: %s | Lake: %s\", as.character(key$hill), as.character(key$lake))\n    E_i   <- rasters_map[[i]]$E\n    R14_i <- rasters_map[[i]]$R14\n    R05_i <- rasters_map[[i]]$R05\n    z_i   <- terra::extract(E_i,   vpts, ID = FALSE)[,1]\n    t14_i <- terra::extract(R14_i, vpts, ID = FALSE)[,1]\n    t05_i <- terra::extract(R05_i, vpts, ID = FALSE)[,1]\n    res[[i]] <- tibble(Scenario = scen_label, id = pts$id, x = pts$x, y = pts$y,\n                       z_surf = z_i, T14 = t14_i, T05 = t05_i)\n  }\n  dplyr::bind_rows(res)\n}\nstations_all <- extract_for_all()\n\n# Dumbbells\np_station_all <- ggplot(stations_all, aes(x = factor(id))) +\n  geom_segment(aes(xend = factor(id), y = T05, yend = T14), colour = \"grey60\") +\n  geom_point(aes(y = T05), colour = \"#0000FF\", size = 2.2) +\n  geom_point(aes(y = T14), colour = \"#FF0000\", size = 2.2) +\n  theme_minimal(base_size = 11) +\n  labs(title = \"Stations — Dumbbell (ALL scenarios): 05:00 (blue) vs 14:00 (red)\",\n       x = \"Station ID\", y = \"Temperature [°C]\") +\n  facet_wrap(~Scenario, ncol = 3)\n\np_station_all\n```\n\n::: {.cell-output-display}\n![](pipemodel_files/figure-html/unnamed-chunk-10-1.png){width=1200}\n:::\n:::\n\n\n\n# 9) Temperature vs Elevation (ALL scenarios)\n\n**Interpretation:** **14:00** shows a **negative** slope (lapse) with scatter from radiation. **05:00** is often **weaker** or **positive** (inversion), with scatter from pooling and slope terms; pooling is **reduced** on the hill.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstations_all_long <- stations_all |>\n  transmute(Scenario, id, Elevation = z_surf, `05:00` = T05, `14:00` = T14) |>\n  tidyr::pivot_longer(cols = c(`05:00`,`14:00`), names_to = \"Time\", values_to = \"Temperature\")\n\np_T_vs_Z_all <- ggplot(stations_all_long, aes(Elevation, Temperature, color = Time)) +\n  geom_point(size = 2.0, alpha = 0.9) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.7) +\n  scale_color_manual(values = c(`05:00` = \"#0000FF\", `14:00` = \"#FF0000\")) +\n  theme_minimal(base_size = 11) +\n  labs(title = \"Temperature vs Elevation (ALL scenarios)\",\n       x = \"Elevation [m]\", y = \"Temperature [°C]\", color = \"Time\") +\n  facet_wrap(~Scenario, ncol = 3)\n\np_T_vs_Z_all\n```\n\n::: {.cell-output-display}\n![](pipemodel_files/figure-html/unnamed-chunk-11-1.png){width=1200}\n:::\n:::\n\n\n\n# 10) Optional 2.5D view (rayshader, chosen scenario)\n\nThe 2.5D view helps connect **topography** and **temperature patterns** spatially. Colors/limits match the 2D maps.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (rayshader_mode != \"off\") {\n  if (!requireNamespace(\"rayshader\", quietly = TRUE)) install.packages(\"rayshader\")\n  if (!requireNamespace(\"rgl\",       quietly = TRUE)) install.packages(\"rgl\")\n  if (!requireNamespace(\"raster\",    quietly = TRUE)) install.packages(\"raster\")\n  library(rayshader); library(rgl); library(raster)\n  \n  elmat  <- rayshader::raster_to_matrix(raster::raster(ras_pick$E))\n  tmat14 <- rayshader::raster_to_matrix(raster::raster(ras_pick$R14))\n  tmat05 <- rayshader::raster_to_matrix(raster::raster(ras_pick$R05))\n  \n  # Map with exact facet limits and our blue->red palette\n  map_cols_fixed <- function(M, minmax, palette = temp_palette) {\n    S <- (M - minmax[1]) / diff(minmax)\n    S[S < 0] <- 0; S[S > 1] <- 1\n    matrix(palette[pmax(1, pmin(256, as.integer(S*255) + 1))],\n           nrow = nrow(M), ncol = ncol(M))\n  }\n  overlay <- if (identical(rayshader_scenario, \"T05\")) map_cols_fixed(tmat05, qT05_all)\n             else                                      map_cols_fixed(tmat14, qT14_all)\n  \n  # Device mode\n  if (rayshader_mode == \"viewer\")  options(rgl.useNULL = TRUE)\n  if (rayshader_mode == \"window\")  options(rgl.useNULL = FALSE)\n  if (rayshader_mode == \"snapshot\")options(rgl.useNULL = TRUE)\n  if (!isTRUE(getOption(\"rgl.useNULL\")) && length(rgl::rgl.dev.list()) == 0) rgl::open3d()\n  rgl::clear3d()\n  \n  # Neutral grey hillshade and fully opaque overlay (no green cast)\n  gray_tex <- grDevices::colorRampPalette(c(\"#444444\",\"#BBBBBB\",\"#FFFFFF\"))(256)\n  zscale <- 5\n  plot_3d(elmat, zscale = zscale, hillshade = height_shade(elmat, texture = gray_tex),\n          fov = 0, theta = 30, phi = 45, zoom = 0.9,\n          baseshape = \"rectangle\", windowsize = c(1000, 800))\n  add_overlay(overlay, alphalayer = 1.0, rescale_original = FALSE)\n  \n  # Stations (+2 m above surface)\n  render_points(extent = c(xmin, xmax, ymin, ymax),\n                lat = sf::st_coordinates(pts_sf)[,2],\n                long = sf::st_coordinates(pts_sf)[,1],\n                altitude = pts_pick$z_surf + 2,\n                zscale = zscale, size = 6, color = \"red\")\n  \n  if (rayshader_mode == \"viewer\")  { options(rgl.printRglwidget = TRUE); rgl::rglwidget() }\n  if (rayshader_mode == \"snapshot\"){ rayshader::render_snapshot(rayshader_snapshot, clear = FALSE) }\n}\n```\n:::\n\n\n\n# 11) What we’re deliberately simplifying\n\nNo **sky-view factors**, **horizon shading**, **advection**, or **canopy**; $\\cos i$ ignores diffuse/reflected components. Parameters are uniform except for **surface type** (water vs grass) and a simple **hill-induced reduction** of cold pooling. This keeps the sandbox fast and interpretable while capturing first-order valley effects.\n",
    "supporting": [
      "pipemodel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}