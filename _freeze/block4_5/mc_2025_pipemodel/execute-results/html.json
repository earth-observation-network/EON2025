{
  "hash": "d001f4112627a219f9465cd7f22194a8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PipeModel Idealized valley microclimate sandbox \"\nsubtitle: \"with robust modeling, spatial CV, and land-cover physics\"\nauthor: \"gisma\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    code-fold: true\n    number-sections: true\n    embed-resources: true\nexecute:\n  echo: true\n  warning: false\n  message: false\n  results: hide\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n# Why the PipeModel?\n\nThe **PipeModel** is a deliberately idealized yet physically plausible\nvalley scenario. It distills terrain to the essentials (parabolic\ncross-valley profile) and optional features (left-side hill, right-side\npond or hollow), so that dominant **microclimate drivers** become\nvisible and testable:\n\n-   **Radiation** via terrain exposure `cos(i)` from slope & aspect\n-   **Elevation**: daytime negative lapse; pre-dawn weak inversion\n-   **Cold-air pooling** along the valley axis (Gaussian trough)\n-   **Surface type / land-cover** (grass / forest / water / bare soil /\n    maize) alters heating, shading, roughness and nocturnal behaviour\n\nYou can sample synthetic stations, train interpolators (IDW, Kriging\nvariants, RF, GAM), and assess them with **spatial LBO-CV**.\n\n> 🔧 This document keeps the previous behaviour but extends the physics\n> with a modular **land-cover layer** that feeds into both daytime and\n> night fields.\n\n![](images/pipe.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crisp figures\n# EN: Crisp figures\nknitr::opts_chunk$set(fig.width = 9, fig.height = 6, dpi = 150)\n# Alle Chunk-Meldungen global weg\n# EN: Silence messages/warnings in all chunks\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n# Hilfsfunktion: gstat & Co. ruhigstellen\n# EN: Helper: silence gstat & friends\nquiet <- function(expr) suppressWarnings(suppressMessages(force(expr)))\n```\n:::\n\n\n\n## Helper function cheat-sheet\n\n| Function | Role |\n|---------------------|---------------------------------------------------|\n| `build_topography()` | Creates elevation (E), optional hill & pond footprints (+ slope/aspect). |\n| `build_landcover()` | Builds categorical land-cover raster (grass/forest/water/bare/maize). |\n| `build_physics_fields()` | Computes T14 & T05 from topo + land-cover + sun + noise. |\n| `build_scenario()` | One-stop wrapper returning all rasters (E, R14, R05, lc, etc.). |\n| `make_blocks_and_assign()` | Builds grid blocks and assigns station points for LBO-CV. |\n| `pred_*()` | Point-wise predictors: Voronoi, IDW, OK, KED, RF, GAM. |\n| `run_lbo_cv()` | Leave-Block-Out cross-validation driver (per-block holdout). |\n| `predict_maps()` | Grid predictions for each model; returns df + ready-made maps. |\n| `build_panels_with_errors()` | Truth \\| predictions / error panels with CV residuals overlay. |\n| `make_obs_pred_scatter()` | Observed vs predicted scatter per model. |\n| `block_metrics_long()` | Per-block RMSE/MAE long table for box/scatter plots. |\n| `make_block_metric_box()` | Boxplots of block-wise RMSE/MAE per model. |\n| `make_abs_error_box()` | Boxplots of per-station absolute error per model. |\n| `make_residual_density()` | Residual density (per model) quick diagnostic. |\n| `run_for_time()` | Small wrapper to run CV + maps + panel for one time slot. |\n\n------------------------------------------------------------------------\n\n# A. Setup & global knobs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages ---------------------------------------------------------------\nreq_pkgs <- c(\n  \"terra\",\"sf\",\"ggplot2\",\"dplyr\",\"tibble\",\"tidyr\",\n  \"suncalc\",\"gstat\",\"randomForest\",\"mgcv\",\"scales\",\"patchwork\",\n  \"knitr\",\"kableExtra\",\"RColorBrewer\", \"zoo\"\n)\ninst <- rownames(installed.packages())\nif (any(!req_pkgs %in% inst)) install.packages(setdiff(req_pkgs, inst), dependencies = TRUE)\ninvisible(lapply(req_pkgs, require, character.only = TRUE))\nsf::sf_use_s2(FALSE)  # robust joins in small projected domains\nset.seed(42)\n\n`%||%` <- function(a, b) if (!is.null(a)) a else b\n\n# Domain & grid ---------------------------------------------------------\ncrs_utm <- \"EPSG:32632\"\nE0 <- 600000; N0 <- 5725000\nlen_x <- 1200; len_y <- 800; res <- 2\next <- terra::ext(E0 - len_x/2, E0 + len_x/2, N0 - len_y/2, N0 + len_y/2)\nRtemplate <- terra::rast(ext, resolution = res, crs = crs_utm)\n\nxmin <- terra::xmin(ext); xmax <- terra::xmax(ext)\nymin <- terra::ymin(ext); ymax <- terra::ymax(ext)\nx0 <- (xmin+xmax)/2;      y0 <- (ymin+ymax)/2\n\n# Feature anchors (left/right thirds) ----------------------------------\nx_hill_center <- xmin + len_x/3;   y_hill_center <- y0\nx_lake_center <- xmin + 2*len_x/3; y_lake_center <- y0\n\n# Scenario toggles ------------------------------------------------------\nlake_choice <- \"water\"   # \"none\" | \"water\" | \"hollow\"\nhill_choice <- \"bump\"    # \"none\" | \"bump\"\n\n# Feature geometry\nlake_diam_m  <- 80; lake_depth_m <- 10; smooth_edges <- FALSE\nhill_diam_m  <- 80; hill_height_m <- 50; hill_smooth  <- FALSE\n\n# Night pooling reduction over hill (0..1)\npool_block_gain <- 0.4\n\nno_random_hill = 9\n\n# Stations --------------------------------------------------------------\nstation_mode      <- \"random\"     # \"random\" | \"ns_transect\" | \"ew_transect\"\nn_st              <- 60\ntransect_margin_m <- 10\nns_offset_m <- 0   # + east / - west\new_offset_m <- 0   # + north / - south\n\n# CV & models -----------------------------------------------------------\n# --- Global einheitlich ---\ncompute_block_size <- function(len_x, len_y, n_st,\n                               target_st_per_block = 3,\n                               min_blocks_axis = 3,\n                               round_to = 50) {\n  area <- len_x * len_y\n  B_target <- max(min_blocks_axis^2, round(n_st / target_st_per_block))\n  bs <- sqrt(area / B_target)                         # idealisierte Blockkante\n  bs <- min(bs, len_x / min_blocks_axis, len_y / min_blocks_axis)  # mind. 3 pro Achse\n  bs <- max(round_to, round(bs / round_to) * round_to)             # \"schön\" runden\n  as.integer(bs)\n}\n\n# anwenden\nblock_size  <- compute_block_size(len_x, len_y, n_st)\n\n\n.get_block_size <- function() {\n  bs <- get0(\"block_size\", ifnotfound = 100)\n  if (!is.numeric(bs) || !is.finite(bs) || bs <= 0) 100 else as.numeric(bs)\n}\nmodels_use <- c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\")\n\n# Viz palettes ----------------------------------------------------------\ntemp_palette <- grDevices::colorRampPalette(c(\"#0000FF\",\"#FF0000\"))(256)  # blue->red\nstretch_q    <- c(0.02, 0.98)\n```\n:::\n\n\n\n# B. LAndscape Modeler\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Domain diagonal (used for variogram fallbacks)\ndom_diag <- sqrt((xmax - xmin)^2 + (ymax - ymin)^2)\n\nlat <- 51.8; lon <- 10.6\nsun_pos_utc <- function(y, m, d, h, lat, lon) {\n  t  <- as.POSIXct(sprintf(\"%04d-%02d-%02d %02d:00:00\", y, m, d, h), tz = \"UTC\")\n  sp <- suncalc::getSunlightPosition(date = t, lat = lat, lon = lon)\n  az_from_north <- (sp$azimuth + pi) %% (2*pi)\n  list(alt = sp$altitude, az = az_from_north)\n}\nsun14 <- sun_pos_utc(2024, 6, 21, 14, lat, lon)\nsun05 <- sun_pos_utc(2024, 6, 21,  5, lat, lon)\n\n# Cosine of incidence (sun on slope/aspect)\ncosi_fun <- function(alt, az, slp_r, asp_r) {\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp_r)*cos(zen) + sin(slp_r)*sin(zen)*cos(az - asp_r)\n  terra::ifel(ci < 0, 0, ci)\n}\n```\n:::\n\n\n\n# C. Model builder (modular) — topo + land-cover + physics\n\nWe separate builder logic into three parts:\n\n1.  **Topography** (`build_topography`) → elevation, lake/hill masks,\n    slope/aspect\n2.  **Land-cover** (`build_landcover`) → integer classes + legend\n3.  **Physics** (`build_physics_fields`) → T14/T05 using class-specific\n    coefficients\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) Topography ---------------------------------------------------------\n# 1) Topography ---------------------------------------------------------\nbuild_topography <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                             hill_mode = c(\"none\",\"bump\")) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0\n  a  <- 100 / ((len_y/2)^2)              # ~100 m rim height\n  elev <- 500 + a * dy^2\n\n  # Pond/hollow (right third)\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Hill (left third)\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h <- if (hill_smooth) exp(- (rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h\n  } else w_h <- 0\n\n  E <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW <- Rtemplate; terra::values(hillW) <- if (hill_mode==\"bump\") w_h else 0; names(hillW) <- \"hillW\"\n\n  # Derivatives & sun\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  list(E = E, lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05)\n}\n\n\n# 2) Land-cover ---------------------------------------------------------\n# --- Land-Cover: zentrale Definition (1 forest, 2 water, 3 bare soil, 4 maize)\nlc_levels_default <- c(\"forest\",\"water\",\"bare soil\",\"maize\")\nlc_levels <- getOption(\"pipemodel.lc_levels\", lc_levels_default)\nlc_colors <- c(\"forest\"=\"#2E8B57\",\"water\"=\"#5DADE2\",\"bare soil\"=\"#C49A6C\",\"maize\"=\"#F4D03F\")\nlc_colors_default <- c(\n  \"forest\"          = \"#2E8B57\",\n  \"water\"        = \"#5DADE2\",\n  \"bare soil\"  = \"#C49A6C\",\n  \"maize\"          = \"#F4D03F\"\n)\n\n# 2) Land-cover ---------------------------------------------------------\n# --- Land-Cover: zentrale Definition (1 forest, 2 water, 3 bare soil, 4 maize)\nlc_levels_default <- c(\"forest\",\"water\",\"bare soil\",\"maize\")\nlc_levels <- getOption(\"pipemodel.lc_levels\", lc_levels_default)\nlc_colors <- c(\"forest\"=\"#2E8B57\",\"water\"=\"#5DADE2\",\"bare soil\"=\"#C49A6C\",\"maize\"=\"#F4D03F\")\nlc_colors_default <- c(\n  \"forest\"          = \"#2E8B57\",\n  \"water\"        = \"#5DADE2\",\n  \"bare soil\"  = \"#C49A6C\",\n  \"maize\"          = \"#F4D03F\"\n)\n# 3) Physics: T14/T05 from topo + land-cover ----------------------------\n# Day: solar sensitivity (alpha_I) and canopy shading factor for cos(i)\nalpha_I_by_lc <- c(\"forest\"=3.5, \"water\"=1.5, \"bare soil\"=6.0, \"maize\"=4.5)\nshade_fac_by_lc <- c(\"forest\"=0.6, \"water\"=1.0, \"bare soil\"=1.0, \"maize\"=0.9)\n# Dawn: additive warm/cool biases (°C) + pooling modifiers (multiplier)\ndawn_bias_by_lc <- c(\"forest\"=0.3, \"water\"=1.2, \"bare soil\"=-0.5, \"maize\"=0.1)\npool_fac_by_lc  <- c(\"forest\"=0.7, \"water\"=0.8, \"bare soil\"=1.1, \"maize\"=1.0)\n\n# Koeffizienten (benannte Vektoren in Deutsch; nur falls nicht schon definiert)\nif (!exists(\"alpha_I_by_lc\")) {\n  alpha_I_by_lc <- c(\"forest\"=3.5,\"water\"=1.5,\"bare soil\"=6.0,\"maize\"=4.5)\n}\nif (!exists(\"shade_fac_by_lc\")) {\n  shade_fac_by_lc <- c(\"forest\"=0.6,\"water\"=1.0,\"bare soil\"=1.0,\"maize\"=0.9)\n}\nif (!exists(\"dawn_bias_by_lc\")) {\n  dawn_bias_by_lc <- c(\"forest\"=0.3,\"water\"=1.2,\"bare soil\"=-0.5,\"maize\"=0.1)\n}\nif (!exists(\"pool_fac_by_lc\")) {\n  pool_fac_by_lc  <- c(\"forest\"=0.7,\"water\"=0.8,\"bare soil\"=1.1,\"maize\"=1.0)\n}\n\n# ------------------------------------------------------------------------------\n# build_physics_fields(topography, landcover, noise14, noise05)\n# Purpose:\n#   Create the synthetic temperature \"truth\" fields for day (T14) and pre-dawn (T05)\n#   using topography, land-cover-dependent coefficients, solar geometry, and small noise.\n# Inputs:\n#   - topography: list containing E, slp, I14, I05, hillW (from build_topography or scenario).\n#   - landcover:  SpatRaster (or list with lc) of integer LC codes (1..4) per cell.\n#   - noise14/noise05: SpatRasters with Gaussian noise to add small texture.\n# Model (kept exactly as in code):\n#   T14 = T0_14 + lapse_14*(E - mean(E)) + alpha_I(LC) * (I14 * shade_fac(LC)) + noise\n#   T05 = T0_05 + inv_05 *(E - mean(E)) + eta_slope * slope\n#                  - pool_base*(1 - pool_block_gain*hillW)*pool_fac(LC)\n#                  + dawn_bias(LC) + noise\n# Returns:\n#   list(R14 = T14 raster, R05 = T05 raster), names preserved exactly.\n# ------------------------------------------------------------------------------\nbuild_physics_fields <- function(topography, landcover, noise14, noise05) {\n  E    <- topography$E\n  slp0 <- topography$slp\n  I14  <- topography$I14\n  I05  <- topography$I05\n  hillW<- topography$hillW\n\n  # accept either a list(list(lc=...)) or a SpatRaster directly\n  lc <- if (inherits(landcover, \"SpatRaster\")) landcover else landcover$lc\n  stopifnot(inherits(lc, \"SpatRaster\"))\n\n  # lc (numerisch 1..4) -> Zeichenklassen gemäß lc_levels\n  v  <- as.integer(terra::values(lc))\n  v[!is.finite(v)] <- 1L\n  v <- pmax(1L, pmin(v, length(lc_levels)))\n  lc_char <- factor(lc_levels[v], levels = lc_levels)\n\n  # Karten aus benannten Vektoren ableiten\n  to_r <- function(x) terra::setValues(terra::rast(E), x)\n  alpha_I <- to_r(as.numeric(alpha_I_by_lc[lc_char]))\n  shade_f <- to_r(as.numeric(shade_fac_by_lc[lc_char]))\n  dawn_b  <- to_r(as.numeric(dawn_bias_by_lc[lc_char]))\n  pool_f  <- to_r(as.numeric(pool_fac_by_lc[lc_char]))\n\n  # Effektive Strahlung (forest beschattet)\n  I14_eff <- I14 * shade_f\n  I05_eff <- I05 * shade_f  # der Vollständigkeit halber\n\n  # Baselines\n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - (terra::ymax(E)+terra::ymin(E))/2); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool_mod  <- pool_base * (1 - pool_block_gain * hillW) * pool_f\n\n  # Tag (14 UTC)\n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_I * I14_eff + noise14; names(R14) <- \"T14\"\n\n  # Nacht/Früh (05 UTC)\n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool_mod + dawn_b + noise05; names(R05) <- \"T05\"\n\n  list(R14 = R14, R05 = R05)\n}\n\n\n# Noise rasters (generated once) --------------------------------------\nset.seed(1001)\nnoise14_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\nset.seed(1002)\nnoise05_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\n\n# ------------------------------------------------------------------------------\n# build_physics_fields(topography, landcover, noise14, noise05)\n# Purpose:\n#   Create the synthetic temperature \"truth\" fields for day (T14) and pre-dawn (T05)\n#   using topography, land-cover-dependent coefficients, solar geometry, and small noise.\n# Inputs:\n#   - topography: list containing E, slp, I14, I05, hillW (from build_topography or scenario).\n#   - landcover:  SpatRaster (or list with lc) of integer LC codes (1..4) per cell.\n#   - noise14/noise05: SpatRasters with Gaussian noise to add small texture.\n# Model (kept exactly as in code):\n#   T14 = T0_14 + lapse_14*(E - mean(E)) + alpha_I(LC) * (I14 * shade_fac(LC)) + noise\n#   T05 = T0_05 + inv_05 *(E - mean(E)) + eta_slope * slope\n#                  - pool_base*(1 - pool_block_gain*hillW)*pool_fac(LC)\n#                  + dawn_bias(LC) + noise\n# Returns:\n#   list(R14 = T14 raster, R05 = T05 raster), names preserved exactly.\n# ------------------------------------------------------------------------------\nbuild_physics_fields <- function(topography, landcover, noise14, noise05) {\n  E    <- topography$E\n  slp0 <- topography$slp\n  I14  <- topography$I14\n  I05  <- topography$I05\n  hillW<- topography$hillW\n\n  # accept either a list(list(lc=...)) or a SpatRaster directly\n  lc <- if (inherits(landcover, \"SpatRaster\")) landcover else landcover$lc\n  stopifnot(inherits(lc, \"SpatRaster\"))\n\n  # lc (numerisch 1..4) -> Zeichenklassen gemäß lc_levels\n  v  <- as.integer(terra::values(lc))\n  v[!is.finite(v)] <- 1L\n  v <- pmax(1L, pmin(v, length(lc_levels)))\n  lc_char <- factor(lc_levels[v], levels = lc_levels)\n\n  # Karten aus benannten Vektoren ableiten\n  to_r <- function(x) terra::setValues(terra::rast(E), x)\n  alpha_I <- to_r(as.numeric(alpha_I_by_lc[lc_char]))\n  shade_f <- to_r(as.numeric(shade_fac_by_lc[lc_char]))\n  dawn_b  <- to_r(as.numeric(dawn_bias_by_lc[lc_char]))\n  pool_f  <- to_r(as.numeric(pool_fac_by_lc[lc_char]))\n\n  # Effektive Strahlung (forest beschattet)\n  I14_eff <- I14 * shade_f\n  I05_eff <- I05 * shade_f  # der Vollständigkeit halber\n\n  # Baselines\n  E_mean <- terra::global(E, \"mean\", na.rm = TRUE)[1,1]\n  Y <- terra::init(E, \"y\"); dist2ax <- abs(Y - (terra::ymax(E)+terra::ymin(E))/2); w_pool <- 70\n  pool_base <- 4.0 * exp(- (dist2ax / w_pool)^2)\n  pool_mod  <- pool_base * (1 - pool_block_gain * hillW) * pool_f\n\n  # Tag (14 UTC)\n  T0_14 <- 26.0; lapse_14 <- -0.0065\n  R14 <- T0_14 + lapse_14 * (E - E_mean) + alpha_I * I14_eff + noise14; names(R14) <- \"T14\"\n\n  # Nacht/Früh (05 UTC)\n  T0_05 <- 8.5; inv_05 <- 0.003; eta_slope <- 0.6\n  R05 <- T0_05 + inv_05 * (E - E_mean) + eta_slope * slp0 - pool_mod + dawn_b + noise05; names(R05) <- \"T05\"\n\n  list(R14 = R14, R05 = R05)\n}\n\n# Noise rasters (generated once) --------------------------------------\nset.seed(1001)\nnoise14_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\nset.seed(1002)\nnoise05_r <- terra::setValues(terra::rast(Rtemplate), rnorm(terra::ncell(Rtemplate), 0, 0.3))\n\n# One-stop scenario (mit optionalen Mikro-Hügeln) -----------------------\n# ------------------------------------------------------------------------------\n# build_scenario(...)\n# Purpose:\n#   One-stop constructor for a complete synthetic scenario including:\n#   - elevation (E), lake mask, hill weight\n#   - slope/aspect and solar incidence rasters (I14, I05)\n#   - land cover (lc) with fixed integer classes (do NOT rename class labels)\n#   - physics-based temperatures (R14, R05)\n#   This function can optionally add micro-hills for additional relief texture.\n# Inputs:\n#   - lake_mode, hill_mode: same semantics as build_topography.\n#   - noise14, noise05: noise rasters injected into temperatures (unchanged here).\n#   - random_hills, hills_xy, micro_*: optional micro-relief controls.\n# Returns:\n#   Named list with rasters and color/level metadata: (E, R14, R05, lake, hillW,\n#   slp, asp, I14, I05, lc, lc_levels, lc_colors).\n# Notes:\n#   - Class labels like \"forest\", \"water\", \"bare soil\", \"maize\" remain unchanged\n#     because other parts of the code rely on them as factor labels.\n# ------------------------------------------------------------------------------\nbuild_scenario <- function(lake_mode = c(\"none\",\"water\",\"hollow\"),\n                           hill_mode = c(\"none\",\"bump\"),\n                           noise14 = noise14_r,\n                           noise05 = noise05_r,\n                           random_hills = no_random_hill,\n                           hills_xy = NULL,\n                           micro_hill_diam_m = 60,\n                           micro_hill_height_m = 25,\n                           micro_hill_smooth = TRUE,\n                           micro_seed = NULL) {\n  lake_mode <- match.arg(lake_mode); hill_mode <- match.arg(hill_mode)\n\n  # Basis-Talform\n  XY <- as.data.frame(terra::xyFromCell(Rtemplate, 1:terra::ncell(Rtemplate))); names(XY) <- c(\"x\",\"y\")\n  dy <- XY$y - y0; a <- 100 / ((len_y/2)^2); elev <- 500 + a * dy^2\n\n  # See/Grube\n  rl <- sqrt((XY$x - x_lake_center)^2 + (XY$y - y_lake_center)^2); lr <- lake_diam_m/2\n  if (lake_mode %in% c(\"water\",\"hollow\")) {\n    w_l <- if (smooth_edges) pmax(0, 1 - (rl/lr)^2) else as.numeric(rl <= lr)\n    elev <- elev - lake_depth_m * w_l\n  } else w_l <- 0\n\n  # Haupt-Hügel\n  if (hill_mode == \"bump\") {\n    rh <- sqrt((XY$x - x_hill_center)^2 + (XY$y - y_hill_center)^2); hr <- max(1e-6, hill_diam_m/2)\n    w_h_main <- if (hill_smooth) exp(-(rh/hr)^2) else as.numeric(rh <= hr)\n    elev <- elev + hill_height_m * w_h_main\n  } else w_h_main <- 0\n\n  # Mikro-Hügel (zufällig + manuell)\n  centers <- NULL\n  if (!is.null(hills_xy)) centers <- as.matrix(hills_xy[,1:2, drop = FALSE])\n  if (random_hills > 0) {\n    if (!is.null(micro_seed)) set.seed(micro_seed)\n    margin <- micro_hill_diam_m/2 + 5\n    cx <- runif(random_hills, xmin + margin, xmax - margin)\n    cy <- runif(random_hills, ymin + margin, ymax - margin)\n    centers <- rbind(centers, cbind(cx, cy))\n  }\n  w_h_micro <- rep(0, nrow(XY))\n  if (!is.null(centers) && nrow(centers) > 0) {\n    hr_m <- max(1e-6, micro_hill_diam_m/2)\n    for (i in seq_len(nrow(centers))) {\n      r  <- sqrt((XY$x - centers[i,1])^2 + (XY$y - centers[i,2])^2)\n      wi <- if (micro_hill_smooth) exp(-(r/hr_m)^2) else as.numeric(r <= hr_m)\n      w_h_micro <- w_h_micro + wi\n    }\n    w_h_micro <- pmin(1, w_h_micro)\n    elev <- elev + micro_hill_height_m * w_h_micro\n  }\n\n  # Raster\n  E     <- Rtemplate; terra::values(E) <- elev; names(E) <- \"elev\"\n  lakeR <- Rtemplate; terra::values(lakeR) <- if (lake_mode==\"water\") as.numeric(w_l>0) else 0; names(lakeR) <- \"lake\"\n  hillW_main  <- Rtemplate; terra::values(hillW_main)  <- w_h_main;  names(hillW_main)  <- \"hillW\"\n  hillW_micro <- Rtemplate; terra::values(hillW_micro) <- w_h_micro; names(hillW_micro) <- \"hillW\"\n  hillW <- terra::clamp(hillW_main + hillW_micro, lower = 0, upper = 1); names(hillW) <- \"hillW\"\n\n  # Gelände & Sonne\n  slp  <- terra::terrain(E, v=\"slope\",  unit=\"radians\")\n  asp  <- terra::terrain(E, v=\"aspect\", unit=\"radians\")\n  slp0 <- terra::ifel(is.na(slp), 0, slp); asp0 <- terra::ifel(is.na(asp), 0, asp)\n  I14  <- cosi_fun(sun14$alt, sun14$az, slp0, asp0)\n  I05  <- cosi_fun(sun05$alt, sun05$az, slp0, asp0)\n\n  # Landnutzung (1 forest, 2 water, 3 bare soil, 4 maize)\n  lc <- Rtemplate; terra::values(lc) <- 4L\n  lc <- terra::ifel(lakeR > 0, 2L, lc)\n  forest_mask <- (hillW > 0.2) | (slp0 > 0.15 & (terra::init(Rtemplate,\"y\") > y0))\n  lc <- terra::ifel((forest_mask) & (lakeR <= 0), 1L, lc)\n  v_slp   <- terra::values(slp0); thr_slp <- stats::quantile(v_slp[is.finite(v_slp)], 0.90, na.rm = TRUE)\n  bare_mask <- (slp0 >= thr_slp) & (lakeR <= 0) & (!forest_mask)\n  lc <- terra::ifel(bare_mask, 3L, lc); lc <- terra::clamp(lc, lower = 1, upper = 4); names(lc) <- \"lc\"\n\n  # Physikfelder\n  phys <- build_physics_fields(list(E=E, slp=slp0, I14=I14, I05=I05, hillW=hillW), lc, noise14, noise05)\n\n  # NAs robust ersetzen (für metrische Raster)\n  fix_nonfinite <- function(r) { v <- terra::values(r); m <- stats::median(v[is.finite(v)], na.rm = TRUE)\n    v[!is.finite(v)] <- m; terra::values(r) <- v; r }\n\n  # >>> FIX: Levels & Farben an Szenario anhängen (für Stationen & Plots)\n  lc_levels <- lc_levels_default\n  lc_colors <- lc_colors_default\n\n  list(E = fix_nonfinite(E), R14 = fix_nonfinite(phys$R14), R05 = fix_nonfinite(phys$R05),\n       lake = lakeR, hillW = hillW, slp = slp0, asp = asp0, I14 = I14, I05 = I05,\n       lc = lc,\n       lc_levels = lc_levels, lc_colors = lc_colors)\n}\n\n# Build the scenario ----------------------------------------------------\nscen <- build_scenario(lake_choice, hill_choice, random_hills = 9)\n```\n:::\n\n\n\n### Quick peek: land-cover map\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ========== Landnutzungs- & Gelände-Visualizer ==========\n# ------------------------------------------------------------------------------\n# plot_landcover_terrain(scen, stations = NULL, show_contours = TRUE)\n# Purpose:\n#   Visualize land cover, elevation, and slope rasters side-by-side. Optionally\n#   overlay station points and draw hill/lake contours for orientation.\n# Inputs:\n#   - scen: list returned by build_scenario(), must contain E, slp, lc, lake, hillW.\n#   - stations: optional sf point layer to overlay.\n#   - show_contours: toggle for drawing 0.5 level contours around lake/hill masks.\n# Returns:\n#   A patchwork-composed ggplot object (no side effects).\n# ------------------------------------------------------------------------------\nplot_landcover_terrain <- function(scen, stations = NULL, show_contours = TRUE,\n                                   layout = c(\"grid\",\"vertical\")) {\n  layout <- match.arg(layout)\n  stopifnot(all(c(\"E\",\"slp\") %in% names(scen)))\n\n  # Wenn LC fehlt (sollte jetzt nicht passieren), Fall  back bauen\n  if (!(\"lc\" %in% names(scen))) {\n    E    <- scen$E; slp <- scen$slp\n    lake <- if (\"lake\"  %in% names(scen)) scen$lake  else terra::rast(E)*0\n    hill <- if (\"hillW\" %in% names(scen)) scen$hillW else terra::rast(E)*0\n    y0loc <- (terra::ymax(E)+terra::ymin(E))/2\n    slp_vals <- terra::values(slp)\n    thr_slp  <- stats::quantile(slp_vals[is.finite(slp_vals)], 0.90, na.rm = TRUE)\n    lc_fallback <- terra::rast(E); terra::values(lc_fallback) <- 4L  # maize\n    lc_fallback <- terra::ifel(lake > 0, 2L, lc_fallback)            # water\n    forest_mask <- (hill > 0.2) | (slp > 0.15 & (terra::init(E,\"y\") > y0loc))\n    lc_fallback <- terra::ifel((forest_mask) & (lake <= 0), 1L, lc_fallback)  # forest\n    bare_mask <- (slp >= thr_slp) & (lake <= 0) & (!forest_mask)\n    lc_fallback <- terra::ifel(bare_mask, 3L, lc_fallback)           # bare soil\n    names(lc_fallback) <- \"lc\"\n    scen$lc <- lc_fallback\n    lc_levels <- lc_levels_default\n    scen$lc_colors <- lc_colors_default\n  }\n\n  lc_df  <- as.data.frame(scen$lc,  xy = TRUE); names(lc_df)  <- c(\"x\",\"y\",\"lc\")\n  E_df   <- as.data.frame(scen$E,   xy = TRUE); names(E_df)   <- c(\"x\",\"y\",\"elev\")\n  slp_df <- as.data.frame(scen$slp, xy = TRUE); names(slp_df) <- c(\"x\",\"y\",\"slp\")\n\n  lc_df$lc <- factor(lc_df$lc, levels = seq_along(lc_levels), labels = lc_levels)\n  cols_lc  <- scen$lc_colors\n\n  p_lc <- ggplot() +\n    geom_raster(data = lc_df, aes(x, y, fill = lc)) +\n    scale_fill_manual(values = cols_lc, na.value = \"grey90\", name = \"Landuse\") +\n    coord_equal() + theme_minimal() +\n    labs(title = \"Landuse\", x = \"Easting\", y = \"Northing\")\n\n  p_elev <- ggplot() +\n    geom_raster(data = E_df, aes(x, y, fill = elev)) +\n    scale_fill_viridis_c(name = \"Altitude [m]\") +\n    coord_equal() + theme_minimal() +\n    labs(title = \"Altitude\", x = \"Easting\", y = \"Northing\")\n\n  p_slp <- ggplot() +\n    geom_raster(data = slp_df, aes(x, y, fill = slp)) +\n    scale_fill_viridis_c(name = \"Slope [rad]\") +\n    coord_equal() + theme_minimal() +\n    labs(title = \"Slope\", x = \"Easting\", y = \"Northing\")\n\n  if (isTRUE(show_contours)) {\n    lake_df <- as.data.frame(scen$lake, xy = TRUE); names(lake_df) <- c(\"x\",\"y\",\"lake\")\n    hill_df <- as.data.frame(scen$hillW, xy = TRUE); names(hill_df) <- c(\"x\",\"y\",\"hillW\")\n    p_elev <- p_elev + geom_contour(data = E_df, aes(x, y, z = elev),\n                                    bins = 10, colour = \"black\", alpha = 0.25,\n                                    linewidth = 0.2, inherit.aes = FALSE)\n    p_lc  <- p_lc  + geom_contour(data = lake_df, aes(x, y, z = lake),\n                                  breaks = 0.5, colour = \"black\", linewidth = 0.35,\n                                  inherit.aes = FALSE) +\n                    geom_contour(data = hill_df, aes(x, y, z = hillW),\n                                  breaks = 0.5, colour = \"black\", linetype = \"22\",\n                                  linewidth = 0.3, inherit.aes = FALSE)\n    p_slp <- p_slp + geom_contour(data = lake_df, aes(x, y, z = lake),\n                                  breaks = 0.5, colour = \"black\", linewidth = 0.35,\n                                  inherit.aes = FALSE) +\n                    geom_contour(data = hill_df, aes(x, y, z = hillW),\n                                  breaks = 0.5, colour = \"black\", linetype = \"22\",\n                                  linewidth = 0.3, inherit.aes = FALSE)\n  }\n\n  if (!is.null(stations)) {\n    add_st <- list(geom_sf(data = stations, colour = \"black\", fill = \"white\",\n                           shape = 21, size = 1.6, stroke = 0.25, inherit.aes = FALSE))\n    p_lc   <- p_lc   + add_st\n    p_elev <- p_elev + add_st\n    p_slp  <- p_slp  + add_st\n  }\n  if (layout == \"vertical\") {\n    # stapeln, Legenden behalten\n    return(\n      (p_lc   + ggplot2::theme(plot.margin = ggplot2::margin(4,4,4,4, unit = \"pt\"))) /\n        (p_elev + ggplot2::theme(plot.margin = ggplot2::margin(4,4,4,4, unit = \"pt\"))) /\n        (p_slp  + ggplot2::theme(plot.margin = ggplot2::margin(4,4,4,4, unit = \"pt\"))) +\n        patchwork::plot_layout(guides = \"keep\", heights = c(1,1,1))\n    )\n  } else {\n    return((p_lc | (p_elev | p_slp)) + patchwork::plot_layout(guides = \"keep\"))\n  }\n}\n# ---- Aufruf (direkt nach build_scenario):\nplot_landcover_terrain(scen = scen,layout = \"vertical\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/unnamed-chunk-5-1.png){width=1350}\n:::\n\n```{.r .cell-code}\n# ---- 2x2 overview panel in English -----------------------------------------\nplot_block_overview_2x2_en <- function(scen, pts_sf = NULL) {\n  stopifnot(all(c(\"E\",\"slp\",\"I14\",\"I05\") %in% names(scen)))\n  \n  # Stack continuous rasters -> data.frame\n  Rstack <- c(scen$E, scen$slp, scen$I14, scen$I05)\n  df <- terra::as.data.frame(Rstack, xy = TRUE, na.rm = FALSE)\n  names(df) <- c(\"x\",\"y\",\"elev\",\"slope\",\"I14\",\"I05\")\n  \n  # Base theme & palettes (no extra packages)\n  theme_base <- ggplot2::theme_minimal(base_size = 11)\n  pal_terrain <- grDevices::hcl.colors(256, \"Terrain\")\n  pal_slope   <- grDevices::hcl.colors(256, \"Viridis\")\n  pal_hot     <- grDevices::hcl.colors(256, \"YlOrRd\")\n  pal_cool    <- grDevices::hcl.colors(256, \"PuBuGn\")\n  \n  p_elev <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = elev)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_terrain, name = \"m\") +\n    ggplot2::labs(title = \"Terrain (Elevation)\") + theme_base\n  \n  p_slope <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = slope)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_slope, name = \"rad\") +\n    ggplot2::labs(title = \"Slope (radians)\") + theme_base\n  \n  p_I14 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I14)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_hot, name = \"\") +\n    ggplot2::labs(title = \"Insolation 14 UTC (cos i)\") + theme_base\n  \n  p_I05 <- ggplot2::ggplot(df, ggplot2::aes(x, y, fill = I05)) +\n    ggplot2::geom_raster() + ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = pal_cool, name = \"\") +\n    ggplot2::labs(title = \"Insolation 05 UTC (cos i)\") + theme_base\n  \n  # Land cover (if available); falls back to slope otherwise\n  p_lc <- NULL\n  if (\"lc\" %in% names(scen)) {\n    lc_df <- terra::as.data.frame(scen$lc, xy = TRUE, na.rm = FALSE)\n    names(lc_df) <- c(\"x\",\"y\",\"lc\")\n    lc_levels <- scen$lc_levels %||% scen$lc_lev\n    if (!is.null(lc_levels)) {\n      lc_df$lc <- factor(lc_df$lc, levels = seq_along(lc_levels), labels = lc_levels)\n    }\n    lc_cols <- scen$lc_colors %||% c(\"Forest\"=\"#2E8B57\",\"Water\"=\"#5DADE2\",\n                                     \"Bare soil\"=\"#C49A6C\",\"Maize\"=\"#F4D03F\")\n    p_lc <- ggplot2::ggplot(lc_df, ggplot2::aes(x, y, fill = lc)) +\n      ggplot2::geom_raster() + ggplot2::coord_equal() +\n      ggplot2::scale_fill_manual(values = lc_cols, drop = FALSE, name = \"Land cover\") +\n      ggplot2::labs(title = \"Land cover\") + theme_base\n  }\n  \n  # Optional station overlay\n  if (!is.null(pts_sf)) {\n    pts_df <- sf::st_drop_geometry(pts_sf)\n    add_pts <- function(p)\n      p + ggplot2::geom_point(data = pts_df, ggplot2::aes(x = x, y = y),\n                              inherit.aes = FALSE, size = 0.7, alpha = 0.7,\n                              colour = \"black\")\n    p_elev  <- add_pts(p_elev)\n    p_slope <- add_pts(p_slope)\n    p_I14   <- add_pts(p_I14)\n    p_I05   <- add_pts(p_I05)\n    if (!is.null(p_lc)) p_lc <- add_pts(p_lc)\n  }\n  \n  # Choose 4th panel: land cover if present, otherwise slope\n  p2 <- if (!is.null(p_lc)) p_lc else p_slope\n  \n  # 2x2 layout\n  # 2x2 layout + rotate x-axis labels 45°\n  (p_elev | p2) / (p_I14 | p_I05) +\n    patchwork::plot_layout(guides = \"collect\") &\n    ggplot2::theme(\n      plot.margin = ggplot2::margin(5,5,5,5),\n      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1)\n    )\n  \n}\n\n\n\n\n# (Optionale zweite Darstellung – Tippfehler korrigiert)\nlc_df <- as.data.frame(scen$lc, xy = TRUE)\nnames(lc_df) <- c(\"x\",\"y\",\"lc\")\nlc_df$lc <- factor(lc_df$lc, levels = 1:length(lc_levels), labels = lc_levels)\n\nggplot(lc_df, aes(x, y, fill = lc)) +\n  geom_raster() +\n  scale_fill_manual(values = scen$lc_colors, drop = FALSE) +\n  coord_equal() + theme_minimal() +\n  labs(title = \"Land-cover (classes)\", x = \"Easting\", y = \"Northing\", fill = \"LC\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/unnamed-chunk-5-2.png){width=1350}\n:::\n:::\n\n\n\n# D. Physics & Scenario Builder — Cheat Sheet (enhanced LC model)\n\n## D.1 Generated rasters & derived fields\n\n| Name | Unit | What it is | How it’s built |\n|------------|-----------:|--------------|----------------------------------|\n| `E` (`elev`) | m | Ground elevation | Parabolic “half-pipe” across **y**; + optional hill; − optional pond/hollow |\n| `slp`, `asp` | rad | Slope, aspect | `terra::terrain(E, \"slope\"/\"aspect\", \"radians\")` |\n| `I14`, `I05` | – | Cosine solar incidence at 14/05 UTC | `cosi_fun(alt, az, slp, asp)`, clamped to `[0,1]` |\n| `lc` | cat | Land-cover class | {Forest, Water, Bare Soil, Maize}; rules from hill/slope/water masks |\n| `hillW` | 0–1 | Hill weight (1 inside footprint) | Disk/Gaussian on left third; combines main + optional micro-hills |\n| `lake` | 0/1 | Water mask | 1 only when `lake_choice == \"water\"` (disk on right third) |\n| `I14_eff` | – | **Shaded** incidence (day) | `I14 * shade_fac_by_lc[lc]` |\n| `αI(lc)` | – | Daytime solar sensitivity by LC | Look-up from `alpha_I_by_lc` |\n| `dawn_bias(lc)` | °C | Additive pre-dawn bias by LC | Look-up from `dawn_bias_by_lc` |\n| `pool_fac(lc)` | – | Pooling multiplier by LC | Look-up from `pool_fac_by_lc` |\n| `R14` (`T14`) | °C | Daytime “truth” temperature field | Eq. (below) |\n| `R05` (`T05`) | °C | Pre-dawn “truth” temperature field | Eq. (below) |\n\n## D.2 Governing equations\n\nLet \\$\\overline{E}\\$ be the domain-mean elevation. Define the\ncross-valley cold-pool kernel\n\n$$\n\\texttt{pool\\_base} \\;=\\; A \\exp\\!\\left[-(d_y/w)^2\\right],\\quad d_y=|y-y_0|,\n$$\n\nblocked over the hill by `(1 − pool_block_gain * hillW)`.\n\n**Day (14 UTC)**\n\n$$\nT_{14} \\;=\\; T0_{14} \\;+\\; \\texttt{lapse\\_14}\\,(E-\\overline{E})\n\\;+\\; \\alpha_I(\\texttt{lc})\\, I_{14}^{\\text{eff}}\n\\;+\\; \\varepsilon_{14},\n\\quad\nI_{14}^{\\text{eff}} = I_{14}\\cdot \\texttt{shade\\_fac}(\\texttt{lc}).\n$$\n\n**Pre-dawn (05 UTC)**\n\n$$\nT_{05} \\;=\\; T0_{05} \\;+\\; \\texttt{inv\\_05}\\,(E-\\overline{E})\n\\;+\\; \\eta_{\\text{slope}}\\;\\texttt{slp}\n\\;-\\; \\texttt{pool\\_base}\\cdot(1-\\texttt{pool\\_block\\_gain}\\cdot\\texttt{hillW})\\cdot \\texttt{pool\\_fac}(\\texttt{lc})\n\\;+\\; \\texttt{dawn\\_bias}(\\texttt{lc})\n\\;+\\; \\varepsilon_{05}.\n$$\n\nNoise \\$\\varepsilon\\_{14},\\varepsilon\\_{05}\n\\sim \\mathcal{N}(0,,0.3\\^2)\\$ i.i.d.\n\n> **Note vs. predecessor:** the former `warm_bias_water_dawn * lake`\n> term is now folded into `dawn_bias(lc)` (class “Water”); daytime\n> `α_map` became `αI(lc) * I14_eff` with explicit canopy shading.\n\n## D.3 Dials (what you can tweak)\n\n### Global scalars\n\n| Parameter | Default | Sensible range | Affects | Visual signature (+) |\n|-------------|------------:|------------:|-------------|--------------------|\n| `T0_14` | 26.0 °C | 20–35 | T14 baseline | Uniform warming |\n| `lapse_14` | −0.0065 °C/m | −0.01…−0.002 | T14 vs elevation | Cooler rims, warmer floor |\n| `T0_05` | 8.5 °C | 3–15 | T05 baseline | Uniform warming |\n| `inv_05` | +0.003 °C/m | 0–0.008 | T05 vs elevation | Rims warmer vs floor |\n| `η_slope` | 0.6 | 0–1.5 | T05 slope flow proxy | Steeper slopes a bit warmer at dawn |\n| `pool_base` amplitude | 4.0 K | 1–8 | T05 pooling depth | Stronger blue band on valley axis |\n| `w_pool` | 70 m | 40–150 | T05 pooling width | Narrower/broader cold band |\n| `pool_block_gain` | 0.4 | 0–1 | Hill blocking | Warm “tongue” over hill at dawn |\n| `noise σ` | 0.3 K | 0–1 | Both | Fine speckle/random texture |\n\n### Land-cover coefficients (by class)\n\nDefaults used in the code:\n\n| LC class | `alpha_I_by_lc` | `shade_fac_by_lc` | `dawn_bias_by_lc` (°C) | `pool_fac_by_lc` |\n|--------------|-------------:|-------------:|---------------:|-------------:|\n| Forest | 3.5 | 0.6 | +0.3 | 0.7 |\n| Water | 1.5 | 1.0 | +1.2 | 0.8 |\n| Bare Soil | 6.0 | 1.0 | −0.5 | 1.1 |\n| Maize | 4.5 | 0.9 | +0.1 | 1.0 |\n\n**Interpretation:** *Bare Soil* heats most by day and **enhances\npooling** (factor \\> 1) and cool bias at dawn; *Forest* damps radiation\nby day (shading) and **reduces pooling** (factor \\< 1); *Water* heats\nlittle by day, gets a **positive dawn bias** and reduced pooling;\n*Maize* sits between grass and forest.\n\n### Geometry/toggles\n\n| Parameter | Default | Options / range | Effect |\n|--------------|--------------|--------------|--------------------------------|\n| `lake_choice` | `\"water\"` | `\"none\"`, `\"water\"`, `\"hollow\"` | Controls depression; only `\"water\"` sets LC=Water (thermal effects). |\n| `hill_choice` | `\"bump\"` | `\"none\"`, `\"bump\"` | Adds blocking & relief. |\n| `lake_diam_m` | 80 | 40–150 | Size of pond/hollow. |\n| `lake_depth_m` | 10 | 5–30 | Depression depth. |\n| `hill_diam_m` | 80 | 40–150 | Hill footprint. |\n| `hill_height_m` | 50 | 10–120 | Hill relief. |\n| `smooth_edges` | `FALSE` | bool | Soft pond rim if `TRUE`. |\n| `hill_smooth` | `FALSE` | bool | Gaussian hill if `TRUE`. |\n| *(optional)* micro-hills | off | `random_hills`, `micro_*` | Adds sub-footprint relief; included in `hillW`. |\n\n## D.4 Quick “recipes”\n\n-   **Cloud/haze day** → ↓ `alpha_I_by_lc` (all classes, esp.\n    Bare/Maize) → daytime LC contrasts fade; models lean on\n    elevation/smoothness.\n-   **Hotter afternoon** → ↑ `T0_14` (+1…+3 K) → uniform bias shift;\n    rankings unchanged.\n-   **Stronger pooling** → ↑ `pool_base` and/or ↓ `w_pool` → sharper,\n    deeper trough; drift-aware models gain.\n-   **Water vs hollow** → `\"water\"` sets LC=Water → ↓ daytime heating, ↑\n    dawn warm bias, ↓ pooling; `\"hollow\"` keeps only geometry (no water\n    thermals).\n-   **Hill blocking** → ↑ `pool_block_gain` → warm dawn tongue over\n    hill; harder CV across blocks.\n-   **Cover swaps** (what if): set a patch to *Bare Soil* → warmer day,\n    **colder dawn & stronger pooling**; to *Forest* → cooler day,\n    **weaker pooling & slight dawn warm-up**.\n\n## D.5 Geometry at a glance\n\n-   **Valley:** \\$E \\propto (y-y_0)\\^2\\$ — U-shape across **y**, uniform\n    along **x**.\n-   **Hill (left third):** disk/Gaussian of `hill_height_m`, diameter\n    `hill_diam_m`; contributes to `hillW`.\n-   **Pond/Hollow (right third):** disk depression of `lake_depth_m`; LC\n    becomes **Water** only if `lake_choice == \"water\"`.\n\n## D.6 What each term *looks like* on maps\n\n| Term | Map signature |\n|-----------------------------|------------------------------------------|\n| `lapse_14 * (E-Ȇ)` | Subtle cool rims / warm floor (day) |\n| `αI(lc) * I14_eff` | Warm sun-facing slopes; **damped under forest/water** |\n| `inv_05 * (E-Ȇ)` | Rims warmer vs pooled floor (dawn inversion) |\n| `η_slope * slp` | Slight dawn warm bias on steeper slopes |\n| `− pool_base * (1−gain*hillW) * pool_fac(lc)` | Blue band on axis; **weaker over forest/water**, **stronger bare** |\n| `+ dawn_bias(lc)` | Local dawn warm spots (water/forest), cool bias (bare) |\n\n## D.8 Settings of the current example\n\n> `alpha_I_by_lc = c(Forest=3.5, Water=1.5, Bare=6.0, Maize=4.5)`,\n> `shade_fac_by_lc = c(0.6,1.0,1.0,0.9)`,\n> `dawn_bias_by_lc = c(+0.3,+1.2,−0.5,+0.1)`,\n> `pool_fac_by_lc = c(0.7,0.8,1.1,1.0)`.\n\n# E. Stations: sampling & extraction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Station coordinates ---------------------------------------------------\nif (station_mode == \"random\") {\n  pts <- tibble::tibble(\n    id = 1:n_st,\n    x  = runif(n_st, xmin + transect_margin_m, xmax - transect_margin_m),\n    y  = runif(n_st, ymin + transect_margin_m, ymax - transect_margin_m)\n  )\n} else if (station_mode == \"ns_transect\") {\n  x_const <- min(max(x0 + ns_offset_m, xmin + transect_margin_m), xmax - transect_margin_m)\n  y_seq   <- seq(ymin + transect_margin_m, ymax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_const, y = y_seq)\n} else if (station_mode == \"ew_transect\") {\n  y_const <- min(max(y0 + ew_offset_m, ymin + transect_margin_m), ymax - transect_margin_m)\n  x_seq   <- seq(xmin + transect_margin_m, xmax - transect_margin_m, length.out = n_st)\n  pts <- tibble::tibble(id = 1:n_st, x = x_seq, y = y_const)\n} else stop(\"Unknown station_mode\")\n\npts_sf <- sf::st_as_sf(pts, coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\nvpts   <- terra::vect(pts_sf)\n\n# Extract covariates & targets -----------------------------------------\npts$z_surf <- as.numeric(terra::extract(scen$E,   vpts, ID = FALSE)[,1])\npts$slp    <- as.numeric(terra::extract(scen$slp, vpts, ID = FALSE)[,1])\npts$I14    <- as.numeric(terra::extract(scen$I14, vpts, ID = FALSE)[,1])\npts$I05    <- as.numeric(terra::extract(scen$I05, vpts, ID = FALSE)[,1])\npts$lc     <- as.integer(terra::extract(scen$lc,  vpts, ID = FALSE)[,1])\npts$T14    <- as.numeric(terra::extract(scen$R14, vpts, ID = FALSE)[,1])\npts$T05    <- as.numeric(terra::extract(scen$R05, vpts, ID = FALSE)[,1])\n\n# Keep complete rows per time slot -------------------------------------\npts14 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I14\",\"lc\",\"T14\")]), ]\npts05 <- pts[stats::complete.cases(pts[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"I05\",\"lc\",\"T05\")]), ]\n\n# Unify response name to 'temp' and carry LC as factor -----------------\n# Unify response 'temp' and carry LC as factor with global levels ---------------\nstn_sf_14 <- pts14 |>\n  dplyr::transmute(\n    id, x, y,\n    z_surf = as.numeric(z_surf),\n    slp    = as.numeric(slp),\n    cosi   = as.numeric(I14),\n    lc     = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n    temp   = as.numeric(T14)\n  ) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\nstn_sf_05 <- pts05 |>\n  dplyr::transmute(\n    id, x, y,\n    z_surf = as.numeric(z_surf),\n    slp    = as.numeric(slp),\n    cosi   = as.numeric(I05),\n    lc     = factor(lc_levels[pmax(1, pmin(lc, length(lc_levels)))], levels = lc_levels),\n    temp   = as.numeric(T05)\n  ) |>\n  sf::st_as_sf(coords = c(\"x\",\"y\"), crs = crs_utm, remove = FALSE)\n\n# With station overlay (e.g., T14)\nplot_block_overview_2x2_en(scen, pts_sf = stn_sf_14)\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/unnamed-chunk-6-1.png){width=1350}\n:::\n:::\n\n\n\n# E. Modeling helpers (blocks, learners, CV)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: lbo-helpers\n#| echo: false\n#| message: false\n#| warning: false\n#| results: 'asis'\n\n# — Compute metrics from a CV table (fallback) —\nlbo_compute_metrics <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  dplyr::group_by(cv_tbl, model) |>\n    dplyr::summarise(\n      n    = dplyr::n(),\n      n_ok = sum(is.finite(obs) & is.finite(pred)),\n      MAE  = mean(abs(pred - obs), na.rm = TRUE),\n      RMSE = sqrt(mean((pred - obs)^2, na.rm = TRUE)),\n      Bias = mean(pred - obs, na.rm = TRUE),\n      R2   = {\n        m <- mean(obs, na.rm=TRUE)\n        1 - sum((pred-obs)^2, na.rm=TRUE) / sum((obs-m)^2, na.rm=TRUE)\n      },\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n}\n\n# — Show metrics from df or file —\nlbo_show_metrics <- function(metrics_df = NULL, csv = NULL, html = NULL, caption = \"LBO-CV metrics — baseline\") {\n  if (!is.null(metrics_df)) {\n    return(knitr::kable(metrics_df, format=\"html\", digits=3, caption = caption))\n  }\n  if (!is.null(html) && file.exists(html)) {\n    return(htmltools::includeHTML(html))\n  }\n  if (!is.null(csv) && file.exists(csv)) {\n    df <- read.csv(csv, check.names = FALSE)\n    return(knitr::kable(df, format=\"html\", digits=3, caption = caption))\n  }\n  cat(\"<em>metrics not found</em>\")\n}\n\n# — Print a “panel” object robustly (patchwork or list-of-pages) —\nlbo_print_panel <- function(panel_obj = NULL, page = 1, panel_png = NULL) {\n  if (!is.null(panel_obj)) {\n    # panel kann patchwork sein ODER Liste von Seiten (z.B. $pages)\n    if (is.list(panel_obj) && !is.null(panel_obj$pages)) {\n      print(panel_obj$pages[[page]])\n      return(invisible(TRUE))\n    }\n    if (is.list(panel_obj) && all(vapply(panel_obj, inherits, logical(1), what=\"gg\"))) {\n      print(panel_obj[[page]])\n      return(invisible(TRUE))\n    }\n    print(panel_obj)\n    return(invisible(TRUE))\n  }\n  if (!is.null(panel_png) && file.exists(panel_png)) {\n    cat(sprintf(\"![](%s){width=100%%}\\n\", panel_png))\n    return(invisible(TRUE))\n  }\n  cat(\"<em>panel not available</em>\\n\")\n  invisible(FALSE)\n}\n\n\n\n# ===================== SF-ONLY GEOSTATS PATCH =====================\n\n# ---- Helpers ------------------------------------------------------\n.align_factor_pair <- function(train_x, grid_x, fallback = NULL) {\n  tl <- unique(na.omit(as.character(train_x)))\n  if (!length(tl)) return(list(use = FALSE, train = NULL, grid = NULL, levels = character()))\n  lev <- if (is.null(fallback)) tl else unique(c(tl, fallback))\n  trc <- factor(as.character(train_x), levels = lev)\n  gdc <- factor(as.character(grid_x),  levels = lev)\n  list(use = TRUE, train = trc, grid = gdc, levels = lev)\n}\n.align_factor_to_model <- function(x, lev_model) {\n  y <- factor(as.character(x), levels = lev_model)\n  if (anyNA(y)) y[is.na(y)] <- lev_model[1]\n  y\n}\n.fill_num_na_vec <- function(x, ref) {\n  m <- stats::median(ref[is.finite(ref)], na.rm = TRUE)\n  x[!is.finite(x)] <- m\n  x\n}\n.default_vgm <- function(values, model = \"Exp\", range = 100) {\n  psill <- stats::var(values, na.rm = TRUE); nug <- 0.1 * psill\n  gstat::vgm(psill = psill, model = model, range = range, nugget = nug)\n}\n\n# ---- SF Learner: Voronoi / Next Neighbour -------------------------\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf)\n  as.numeric(train_sf$temp)[idx]\n}\n\n# ---- SF Learner: IDW ----------------------------------------------\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  # train_sf: sf POINTS mit Spalte 'temp'\n  # test_sf : sf POINTS, beliebige Zusatzspalten\n  pr <- suppressWarnings(gstat::idw(temp ~ 1, locations = train_sf, newdata = test_sf, idp = idp))\n  as.numeric(pr$var1.pred)\n}\n\n# ---- SF Learner: Ordinary Kriging ---------------------------------\npred_OK <- function(train_sf, test_sf) {\n  vg      <- suppressWarnings(gstat::variogram(temp ~ 1, data = train_sf))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- .default_vgm(train_sf$temp)\n  pr <- suppressWarnings(gstat::krige(temp ~ 1, locations = train_sf, newdata = test_sf, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n# ---- SF Learner: KED (UK mit externen Drifts) ---------------------\n# --- sf-only KED (schluckt extra Args wie E=E) ----------------------\npred_KED <- function(train_sf, test_sf, ...) {\n  stopifnot(inherits(train_sf, \"sf\"), inherits(test_sf, \"sf\"))\n  need <- c(\"z_surf\",\"slp\",\"cosi\")\n  miss <- setdiff(need, names(train_sf))\n  if (length(miss)) stop(\"pred_KED(): fehlende Drift-Spalten im Training: \",\n                         paste(miss, collapse = \", \"))\n  \n  # Optional LC als Faktor angleichen\n  use_lc <- \"lc\" %in% names(train_sf) && \"lc\" %in% names(test_sf)\n  tr <- train_sf\n  te <- test_sf\n  if (use_lc) {\n    tr$lc <- droplevels(factor(tr$lc))\n    te$lc <- factor(as.character(te$lc), levels = levels(tr$lc))\n    te$lc[is.na(te$lc)] <- levels(tr$lc)[1]\n  }\n  \n  # fehlende numerische Drifts im TEST mit Trainingsmedian auffüllen\n  for (nm in need) {\n    m <- stats::median(tr[[nm]][is.finite(tr[[nm]])], na.rm = TRUE)\n    te[[nm]][!is.finite(te[[nm]])] <- m\n  }\n  \n  # nur vollständige Trainingszeilen\n  keep_tr <- c(\"temp\", need, if (use_lc) \"lc\")\n  dtr <- sf::st_drop_geometry(tr)[, keep_tr, drop = FALSE]\n  ok  <- stats::complete.cases(dtr)\n  tr  <- tr[ok, ]\n  if (nrow(tr) < 5) return(rep(NA_real_, nrow(te)))\n  \n  # Formel: lineare Drifts + optional LC\n  form <- stats::as.formula(paste(\"temp ~\", paste(c(need, if (use_lc) \"lc\"), collapse = \" + \")))\n  \n  # Variogramm + robuster Fit\n  vg      <- suppressWarnings(gstat::variogram(form, data = tr))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) {\n    ps <- stats::var(sf::st_drop_geometry(tr)$temp, na.rm = TRUE)\n    vgm_fit <- gstat::vgm(psill = ps, model = \"Exp\", range = max(vg$dist, na.rm = TRUE)/3, nugget = 0.1*ps)\n  }\n  \n  # Kriging mit externen Drifts (UK/KED)\n  pr <- suppressWarnings(gstat::krige(form, locations = tr, newdata = te, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n\npred_RF <- function(train_sf, test_sf) {\n  dtr <- sf::st_drop_geometry(train_sf)\n  if (!(\"lc\" %in% names(dtr))) dtr$lc <- factor(\"Wald\", levels = lc_levels)\n  dtr$lc <- droplevels(factor(as.character(dtr$lc), levels = lc_levels))\n  dtr <- stats::na.omit(dtr)\n  if (nrow(dtr) < 5) return(rep(NA_real_, nrow(test_sf)))\n  rf  <- randomForest::randomForest(temp ~ x + y + z_surf + slp + cosi + lc, data = dtr, na.action = na.omit)\n  \n  dte <- sf::st_drop_geometry(test_sf)\n  if (!(\"lc\" %in% names(dte))) dte$lc <- factor(\"Wald\", levels = lc_levels)\n  lev <- levels(dtr$lc)\n  dte$lc <- .align_factor_to_model(dte$lc, lev)\n  \n  good <- stats::complete.cases(dte[, c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\")])\n  out  <- rep(NA_real_, nrow(dte)); if (any(good)) out[good] <- stats::predict(rf, dte[good, ])\n  out\n}\n\n# GAM-Fitter (nutzt safe_gam_formula)\nfit_gam_safe <- function(stn_sf) {\n  d <- stn_sf |> sf::st_drop_geometry()\n  d <- d[stats::complete.cases(d[, c(\"x\",\"y\",\"temp\",\"z_surf\",\"slp\",\"cosi\")]), , drop = FALSE]\n  if (nrow(d) < 10) stop(\"Too few stations for GAM: n=\", nrow(d))\n  mgcv::gam(formula = safe_gam_formula(d), data = d, method = \"REML\", select = TRUE)\n}\n\npred_GAM <- function(train_sf, test_sf) {\n  # training data (keep only columns we’ll use, drop NAs)\n  dtr  <- sf::st_drop_geometry(train_sf)\n  keep <- intersect(c(\"temp\",\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\",\"lc\"), names(dtr))\n  dtr  <- dtr[stats::complete.cases(dtr[, keep, drop = FALSE]), keep, drop = FALSE]\n  if (!nrow(dtr)) return(rep(NA_real_, nrow(test_sf)))\n  \n  # land cover: optionally include as factor main effect\n  if (\"lc\" %in% names(dtr)) dtr$lc <- droplevels(factor(dtr$lc))\n  inc_lc <- \"lc\" %in% names(dtr) && nlevels(dtr$lc) >= 2\n  \n  # fit GAM with guarded formula (dynamic k, optional terms)\n  if (nrow(dtr) < 10) return(rep(NA_real_, nrow(test_sf)))\n  gm <- mgcv::gam(\n    formula = safe_gam_formula(dtr, include_lc = inc_lc),\n    data    = dtr,\n    method  = \"REML\",\n    select  = TRUE\n  )\n  \n  # prediction data (+ align LC levels to model, if used)\n  dte <- sf::st_drop_geometry(test_sf)\n  vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (inc_lc) \"lc\")\n  vars <- intersect(vars, names(dte))\n  \n  if (inc_lc) {\n    # align factor levels; assumes you have .align_factor_to_model()\n    lev <- levels(model.frame(gm)$lc)\n    if (!(\"lc\" %in% names(dte))) dte$lc <- lev[1]\n    dte$lc <- .align_factor_to_model(dte$lc, lev)\n  }\n  \n  good <- stats::complete.cases(dte[, vars, drop = FALSE])\n  out  <- rep(NA_real_, nrow(dte))\n  if (any(good)) {\n    out[good] <- stats::predict(gm, dte[good, vars, drop = FALSE], type = \"response\")\n  }\n  out\n}\n\n\n\n# ---- SF-only predict_maps (kein sp, kein grid_sp) -------------------\n# ---------- SF-only predict_maps ----------\npredict_maps <- function(stn_sf, truth_raster,\n                         which_time = c(\"T14\",\"T05\"),\n                         scen, models = c(\"Voronoi\",\"IDW\",\"OK\",\"KED\",\"RF\",\"GAM\"),\n                         lc_levels = NULL,\n                         feature_rasters = NULL) {\n  which_time <- match.arg(which_time)\n  lc_levels  <- lc_levels %||% scen$lc_levels\n  \n  # Basis-/Feature-Raster setzen\n  E      <- scen$E\n  slp_r  <- scen$slp\n  cosi_r <- if (which_time == \"T14\") scen$I14 else scen$I05\n  if (!is.null(feature_rasters)) {\n    if (!is.null(feature_rasters$E))     E     <- feature_rasters$E\n    if (!is.null(feature_rasters$slp))   slp_r <- feature_rasters$slp\n    if (!is.null(feature_rasters$cosi))  cosi_r<- feature_rasters$cosi\n  }\n  has_lc <- (\"lc\" %in% names(scen)) && !is.null(scen$lc)\n  lc_r   <- if (has_lc) scen$lc else NULL\n  \n  # Trainingsdaten vervollständigen\n  train_sf <- stn_sf\n  if (!all(c(\"x\",\"y\") %in% names(train_sf))) {\n    xy <- sf::st_coordinates(train_sf); train_sf$x <- xy[,1]; train_sf$y <- xy[,2]\n  }\n  if (!(\"z_surf\" %in% names(train_sf)))\n    train_sf$z_surf <- as.numeric(terra::extract(E,      sf::st_coordinates(train_sf))[,1])\n  if (!(\"slp\" %in% names(train_sf)))\n    train_sf$slp    <- as.numeric(terra::extract(slp_r,  sf::st_coordinates(train_sf))[,1])\n  if (!(\"cosi\" %in% names(train_sf)))\n    train_sf$cosi   <- as.numeric(terra::extract(cosi_r, sf::st_coordinates(train_sf))[,1])\n  if (has_lc && !(\"lc\" %in% names(train_sf))) {\n    lc_codes <- as.integer(terra::extract(lc_r, sf::st_coordinates(train_sf))[,1])\n    lc_codes[is.na(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    train_sf$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n  \n  # Vorhersage-Grid 1:1 zu Rasterzellen (nie filtern)\n  xy <- as.data.frame(terra::xyFromCell(E, 1:terra::ncell(E))); names(xy) <- c(\"x\",\"y\")\n  grid_df <- xy\n  grid_df$z_surf <- as.numeric(terra::values(E))\n  grid_df$slp    <- as.numeric(terra::values(slp_r))\n  grid_df$cosi   <- as.numeric(terra::values(cosi_r))\n  if (has_lc) {\n    lc_codes <- as.integer(terra::values(lc_r))\n    lc_codes[!is.finite(lc_codes)] <- 1L\n    lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n    grid_df$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n  }\n  grid_sf <- sf::st_as_sf(grid_df, coords = c(\"x\",\"y\"),\n                          crs = sf::st_crs(train_sf), remove = FALSE)\n  \n  # LC-Levels train/grid angleichen (hart, ohne __OTHER__)\n  use_lc <- has_lc && (\"lc\" %in% names(train_sf)) && (\"lc\" %in% names(grid_sf))\n  if (use_lc) {\n    lev <- levels(droplevels(factor(train_sf$lc)))\n    train_sf$lc <- factor(as.character(train_sf$lc), levels = lev)\n    grid_sf$lc  <- factor(as.character(grid_sf$lc),  levels = lev)\n    if (anyNA(train_sf$lc) || anyNA(grid_sf$lc)) {\n      use_lc <- FALSE; train_sf$lc <- NULL; grid_sf$lc <- NULL\n    }\n  }\n  \n  # Modelle laufen lassen\n  pred_list <- list()\n  if (\"Voronoi\" %in% models) pred_list$Voronoi <- pred_Voronoi(train_sf, grid_sf)\n  if (\"IDW\"     %in% models) pred_list$IDW     <- pred_IDW    (train_sf, grid_sf, idp = 2)\n  if (\"OK\"      %in% models) pred_list$OK      <- pred_OK     (train_sf, grid_sf)\n  if (\"KED\"     %in% models) pred_list$KED     <- pred_KED    (train_sf, grid_sf)\n  \n  if (\"RF\" %in% models) {\n    dtr <- sf::st_drop_geometry(train_sf)\n    rf_vars <- c(\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (use_lc) \"lc\")\n    dtr <- stats::na.omit(dtr[, c(\"temp\", rf_vars), drop = FALSE])\n    pred_list$RF <- if (nrow(dtr) >= 5) {\n      rf <- randomForest::randomForest(\n        stats::as.formula(paste(\"temp ~\", paste(rf_vars, collapse = \" + \"))),\n        data = dtr, na.action = na.omit\n      )\n      as.numeric(stats::predict(rf, sf::st_drop_geometry(grid_sf)[, rf_vars, drop = FALSE]))\n    } else rep(NA_real_, nrow(grid_sf))\n  }\n  \n  if (\"GAM\" %in% models) {\n    dtr <- sf::st_drop_geometry(train_sf)\n    keep <- c(\"temp\",\"x\",\"y\",\"z_surf\",\"slp\",\"cosi\", if (use_lc) \"lc\")\n    dtr  <- dtr[stats::complete.cases(dtr[, keep, drop = FALSE]), keep, drop = FALSE]\n    if (nrow(dtr) >= 10) {\n      form <- safe_gam_formula(dtr, include_lc = use_lc)\n      gm   <- mgcv::gam(form, data = dtr, method = \"REML\", select = TRUE)\n      vars_needed <- setdiff(all.vars(formula(gm)), \"temp\")\n      nd <- sf::st_drop_geometry(grid_sf)[, vars_needed, drop = FALSE]\n      mf <- try(model.frame(gm), silent = TRUE)\n      if (!inherits(mf, \"try-error\")) {\n        for (vn in vars_needed) if (is.factor(mf[[vn]])) {\n          nd[[vn]] <- factor(as.character(nd[[vn]]), levels = levels(mf[[vn]]))\n          na_idx <- is.na(nd[[vn]]); if (any(na_idx)) nd[[vn]][na_idx] <- levels(mf[[vn]])[1L]\n        }\n      }\n      good <- stats::complete.cases(nd)\n      tmp  <- rep(NA_real_, nrow(grid_sf))\n      if (any(good)) tmp[good] <- stats::predict(gm, nd[good, , drop = FALSE], type = \"response\")\n      pred_list$GAM <- tmp\n    } else pred_list$GAM <- rep(NA_real_, nrow(grid_sf))\n  }\n  \n  # Ausgaben\n  pred_df <- dplyr::bind_rows(lapply(names(pred_list), function(nm) {\n    tibble::tibble(model = nm, x = grid_df$x, y = grid_df$y, pred = pred_list[[nm]])\n  }))\n  \n  make_r <- function(vals, template = E) {\n    stopifnot(length(vals) == terra::ncell(template))\n    r <- terra::rast(template); terra::values(r) <- as.numeric(vals); r\n  }\n  pred_rasters <- lapply(pred_list, make_r)\n  \n  truth_df <- as.data.frame(truth_raster, xy = TRUE, na.rm = FALSE)\n  names(truth_df) <- c(\"x\",\"y\",\"truth\")\n  lims <- stats::quantile(truth_df$truth, probs = stretch_q, na.rm = TRUE)\n  \n  p_pred <- ggplot2::ggplot(pred_df, ggplot2::aes(x, y, fill = pred)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims,\n                                  oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time),\n                  x = \"Easting\", y = \"Northing\") +\n    ggplot2::facet_wrap(~ model, ncol = 3)\n  \n  p_truth <- ggplot2::ggplot(truth_df, ggplot2::aes(x, y, fill = truth)) +\n    ggplot2::geom_raster() +\n    ggplot2::scale_fill_gradientn(colors = temp_palette, limits = lims,\n                                  oob = scales::squish, name = \"Temp\") +\n    ggplot2::coord_equal() + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Truth raster\", which_time),\n                  x = \"Easting\", y = \"Northing\")\n  \n  list(\n    pred_df      = pred_df,\n    pred_rasters = pred_rasters,\n    p_pred       = p_pred,\n    p_truth      = p_truth\n  )\n}\n\n\n# ===================== Ende SF-Patch =====================\n\n\n\n# Quick station table ---------------------------------------------------\npts |> dplyr::transmute(\n  id, easting = round(x), northing = round(y),\n  z_surf = round(z_surf,1), LC = lc_levels[lc],\n  T14_C = round(T14,1), T05_C = round(T05,1)\n) |> knitr::kable(caption = \"Station sample (sanity check)\", digits = 1)\n```\n\n::: {.cell-output-display}\n\n\nTable: Station sample (sanity check)\n\n| id| easting| northing| z_surf|LC        | T14_C| T05_C|\n|--:|-------:|--------:|------:|:---------|-----:|-----:|\n|  1|  600158|  5725053|  501.8|maize     |  28.9|   6.7|\n|  2|  600124|  5725339|  571.8|forest    |  27.3|   9.4|\n|  3|  600223|  5725049|  501.5|maize     |  29.6|   5.9|\n|  4|  599714|  5725236|  535.1|forest    |  27.9|   8.5|\n|  5|  599499|  5725173|  518.7|forest    |  28.1|   8.9|\n|  6|  599801|  5724894|  507.2|maize     |  28.7|   8.2|\n|  7|  600055|  5724671|  567.7|maize     |  27.8|   9.0|\n|  8|  599936|  5725286|  550.8|forest    |  27.8|   9.0|\n|  9|  599803|  5725081|  504.1|maize     |  29.3|   7.5|\n| 10|  600364|  5724720|  549.4|maize     |  28.9|   9.1|\n| 11|  600245|  5724641|  580.6|maize     |  27.5|   9.2|\n| 12|  600175|  5725123|  509.5|forest    |  27.6|   8.3|\n| 13|  600064|  5724895|  506.9|maize     |  28.8|   8.0|\n| 14|  599511|  5725163|  516.6|forest    |  27.6|   8.5|\n| 15|  599949|  5724667|  569.3|maize     |  28.6|   9.1|\n| 16|  599990|  5724791|  527.3|maize     |  28.7|   8.6|\n| 17|  600385|  5724707|  553.7|maize     |  28.1|   9.1|\n| 18|  600472|  5724673|  566.8|maize     |  27.8|   8.7|\n| 19|  600387|  5724788|  528.3|maize     |  28.0|   8.6|\n| 20|  599546|  5724799|  525.3|maize     |  28.6|   8.6|\n| 21|  600398|  5725042|  501.2|maize     |  29.7|   5.8|\n| 22|  599515|  5724976|  500.3|maize     |  29.4|   4.7|\n| 23|  600084|  5724805|  523.8|maize     |  28.9|   8.9|\n| 24|  599613|  5725333|  569.3|forest    |  27.5|   9.5|\n| 25|  600144|  5724844|  515.4|maize     |  29.2|   8.5|\n| 26|  600465|  5725124|  509.8|forest    |  27.7|   8.4|\n| 27|  600069|  5724627|  587.0|bare soil |  29.1|   8.4|\n| 28|  599895|  5724709|  552.9|maize     |  28.5|   8.9|\n| 29|  600566|  5724843|  515.4|maize     |  28.6|   8.8|\n| 30|  600288|  5725183|  521.0|forest    |  28.2|   8.6|\n| 31|  599902|  5725014|  500.1|maize     |  29.1|   4.8|\n| 32|  599899|  5724735|  543.9|maize     |  28.4|   8.7|\n| 33|  600485|  5725096|  505.9|maize     |  29.5|   8.3|\n| 34|  600232|  5724741|  541.9|maize     |  28.2|   8.9|\n| 35|  599628|  5724767|  533.9|maize     |  28.3|   9.2|\n| 36|  599930|  5725266|  544.6|forest    |  27.8|   9.2|\n| 37|  600428|  5724616|  591.7|bare soil |  28.7|   7.9|\n| 38|  599953|  5724846|  515.0|maize     |  28.8|   8.7|\n| 39|  600586|  5724854|  513.5|maize     |  28.4|   8.6|\n| 40|  599859|  5724681|  563.6|maize     |  28.5|   9.1|\n| 41|  599724|  5724924|  503.5|maize     |  29.7|   7.4|\n| 42|  600331|  5725024|  500.3|maize     |  29.1|   5.1|\n| 43|  599854|  5725258|  542.0|forest    |  27.5|   8.9|\n| 44|  600584|  5724733|  544.6|maize     |  28.6|   8.9|\n| 45|  599536|  5724718|  549.4|maize     |  28.3|   8.9|\n| 46|  600214|  5724949|  501.6|maize     |  28.8|   5.8|\n| 47|  599950|  5725114|  508.0|maize     |  29.3|   8.5|\n| 48|  599621|  5724666|  570.1|maize     |  28.4|   9.0|\n| 49|  599666|  5724679|  574.8|forest    |  26.2|   9.2|\n| 50|  599740|  5725066|  502.8|maize     |  28.8|   7.2|\n| 51|  600268|  5725131|  510.7|forest    |  27.9|   9.0|\n| 52|  599589|  5724750|  539.4|maize     |  28.4|   9.0|\n| 53|  600530|  5724749|  539.4|maize     |  28.4|   8.8|\n| 54|  599723|  5724752|  560.2|forest    |  27.2|   8.5|\n| 55|  599884|  5724978|  500.3|maize     |  28.9|   5.1|\n| 56|  600339|  5724883|  509.0|maize     |  28.8|   8.9|\n| 57|  599800|  5724810|  522.3|maize     |  29.4|   9.1|\n| 58|  600277|  5725281|  549.4|forest    |  27.5|   9.0|\n| 59|  599684|  5724901|  506.1|maize     |  29.4|   7.7|\n| 60|  600214|  5724936|  502.5|maize     |  29.6|   6.7|\n\n\n:::\n\n```{.r .cell-code}\nassemble_simple_panel <- function(maps, cv_tbl, which_time = c(\"T14\",\"T05\")) {\n  which_time <- match.arg(which_time)\n  \n  # Modelle in EINER Reihe\n  p_models_row <- maps$p_pred +\n    ggplot2::facet_wrap(~model, nrow = 1) +\n    #ggplot2::labs(title = sprintf(\"%s — Predictions by model\", which_time))\n  \n  # Eine Truth-Karte\n  p_truth <- maps$p_truth + ggplot2::labs(title = sprintf(\"%s — truth\", which_time))\n  # \n  # Fehler-Panels\n  p_block <- make_block_metric_box(cv_tbl, which_time)\n  p_abs   <- make_abs_error_box(cv_tbl, which_time)\n  p_dens  <- make_residual_density(cv_tbl, which_time)\n  \n  # Layout\n  (      p_truth /\n      p_models_row /\n       p_block/\n        p_abs /\n      p_dens\n  ) + patchwork::plot_layout(heights = c(1.1, 0.9, 1, 0.8))\n}\n#----------\n\n\n# sorgt dafür, dass X_tr und X_te exakt die gleichen Spaltennamen/Anzahl haben\n.reconcile_mm_cols <- function(X_tr, X_te) {\n  miss_te <- setdiff(colnames(X_tr), colnames(X_te))\n  if (length(miss_te)) {\n    X_te <- cbind(\n      X_te,\n      matrix(0, nrow = nrow(X_te), ncol = length(miss_te),\n             dimnames = list(NULL, miss_te))\n    )\n  }\n  miss_tr <- setdiff(colnames(X_te), colnames(X_tr))\n  if (length(miss_tr)) {\n    X_tr <- cbind(\n      X_tr,\n      matrix(0, nrow = nrow(X_tr), ncol = length(miss_tr),\n             dimnames = list(NULL, miss_tr))\n    )\n  }\n  # identische Spaltenreihenfolge\n  X_te <- X_te[, colnames(X_tr), drop = FALSE]\n  list(X_tr = X_tr, X_te = X_te)\n}\n\nsafe_r2 <- function(obs, pred) {\n  idx <- is.finite(obs) & is.finite(pred)\n  if (sum(idx) < 2) return(NA_real_)\n  x <- obs[idx]; y <- pred[idx]\n  sx <- stats::sd(x); sy <- stats::sd(y)\n  if (!is.finite(sx) || !is.finite(sy) || sx == 0 || sy == 0) return(NA_real_)\n  stats::cor(x, y)^2\n}\n\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.kcap_unique <- function(x, kmax) {\n  ux <- unique(x[is.finite(x)])\n  nu <- length(ux)\n  if (nu <= 3) return(0L)                # treat as constant/near-constant\n  max(4L, min(kmax, nu - 1L))\n}\n\n# Error/diagnostic panels ----------------------------------------------\nblock_metrics_long <- function(cv_tbl) {\n  stopifnot(all(c(\"model\",\"block_id\",\"obs\",\"pred\") %in% names(cv_tbl)))\n  cv_tbl |>\n    dplyr::group_by(model, block_id) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\") |>\n    tidyr::pivot_longer(c(RMSE, MAE), names_to = \"Metric\", values_to = \"Value\")\n}\n\norder_models_by_median_rmse <- function(cv_tbl) {\n  bm <- block_metrics_long(cv_tbl)\n  bm |>\n    dplyr::filter(Metric == \"RMSE\") |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(Value, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n}\n\nmake_block_metric_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  bm <- block_metrics_long(cv_tbl) |>\n    dplyr::filter(is.finite(Value))\n  if (!is.null(tail_cap)) {\n    ymax <- stats::quantile(bm$Value, tail_cap, na.rm = TRUE)\n  }\n  lev <- order_models_by_median_rmse(cv_tbl)\n  bm$model <- factor(bm$model, levels = lev)\n  \n  ggplot2::ggplot(bm, ggplot2::aes(model, Value)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.35, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Block-wise errors (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"Error\") +\n    ggplot2::facet_wrap(~ Metric, scales = \"free_y\")\n}\n\nmake_abs_error_box <- function(cv_tbl, which_time = \"T14\", tail_cap = 0.995) {\n  df <- cv_tbl |>\n    dplyr::mutate(abs_err = abs(pred - obs)) |>\n    dplyr::filter(is.finite(abs_err))\n  ymax <- if (!is.null(tail_cap)) stats::quantile(df$abs_err, tail_cap, na.rm = TRUE) else max(df$abs_err, na.rm = TRUE)\n  lev <- df |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(med = stats::median(abs_err, na.rm = TRUE), .groups = \"drop\") |>\n    dplyr::arrange(med) |>\n    dplyr::pull(model)\n  df$model <- factor(df$model, levels = lev)\n  \n  ggplot2::ggplot(df, ggplot2::aes(model, abs_err)) +\n    ggplot2::geom_boxplot(outlier.alpha = 0.3, width = 0.7) +\n    ggplot2::stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3,\n                          fill = \"white\", colour = \"black\", stroke = 0.5) +\n    ggplot2::coord_cartesian(ylim = c(0, ymax)) +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Absolute errors per station (LBO-CV)\", which_time),\n                  subtitle = \"Box = IQR · line = median · ◆ = mean\",\n                  x = \"Model\", y = \"|pred − obs|\")\n}\n\n\nmake_obs_pred_scatter <- function(cv_tbl, which_time = \"T14\") {\n  lab <- .make_labeller(cv_tbl)\n  ggplot(cv_tbl, aes(obs, pred)) +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    geom_point(alpha = 0.7, shape = 16) +\n    coord_equal() + theme_minimal() +\n    labs(title = sprintf(\"%s — Observed vs Predicted (LBO-CV)\", which_time), x = \"Observed\", y = \"Predicted\") +\n    facet_wrap(~ model, ncol = 3, labeller = ggplot2::as_labeller(lab))\n}\n\nmake_residual_density <- function(cv_tbl, which_time = \"T14\") {\n  cv_tbl |> dplyr::mutate(resid = pred - obs) |> ggplot2::ggplot(ggplot2::aes(resid, fill = model)) +\n    ggplot2::geom_density(alpha = 0.4) + ggplot2::theme_minimal() +\n    ggplot2::labs(title = sprintf(\"%s — Residual density\", which_time), x = \"Residual (°C)\", y = \"Density\")\n}\n\n# Prediction maps & error panels ---------------------------------------\n.make_labeller <- function(cv_tbl) {\n  m <- cv_tbl |>\n    dplyr::group_by(model) |>\n    dplyr::summarise(RMSE = sqrt(mean((obs - pred)^2, na.rm = TRUE)), MAE  = mean(abs(obs - pred), na.rm = TRUE), .groups = \"drop\")\n  setNames(sprintf(\"%s  (RMSE=%.2f · MAE=%.2f)\", m$model, m$RMSE, m$MAE), m$model)\n}\n\n# Helfer: Raster schön als ggplot\n# --- Helfer: Raster hübsch als ggplot -----------------------------------\n.plot_raster_gg <- function(r, title = \"\", palette = temp_palette, q = c(0.02,0.98), lims = NULL) {\n  stopifnot(terra::nlyr(r) == 1)\n  df <- as.data.frame(r, xy = TRUE, na.rm = FALSE)\n  nm <- names(df)[3]\n  if (is.null(lims)) {\n    vv <- terra::values(r, na.rm = TRUE)\n    lims <- stats::quantile(vv, probs = q, na.rm = TRUE, names = FALSE)\n  }\n  ggplot2::ggplot(df, ggplot2::aes(.data$x, .data$y, fill = .data[[nm]])) +\n    ggplot2::geom_raster() +\n    ggplot2::coord_equal() +\n    ggplot2::scale_fill_gradientn(colours = palette, limits = lims, oob = scales::squish) +\n    ggplot2::labs(title = title, x = NULL, y = NULL, fill = \"°C\") +\n    ggplot2::theme_minimal(base_size = 11) +\n    ggplot2::theme(legend.position = \"right\",\n                   plot.title = ggplot2::element_text(face = \"bold\"))\n}\n\nbuild_panels_with_errors <- function(\n    maps, truth_raster, cv_tbl, stn_sf, which_time,\n    temp_palette = temp_palette, stretch_q = c(0.02,0.98),\n    layout = c(\"horizontal\",\"vertical\")\n) {\n  layout <- match.arg(layout)\n  \n  preds <- .get_preds_from_maps(maps)\n  \n  # Einheitliche Farbskala (Truth + alle Rastervorhersagen)\n  all_vals <- c(terra::values(truth_raster, na.rm = TRUE))\n  for (p in preds) if (inherits(p, \"SpatRaster\")) all_vals <- c(all_vals, terra::values(p, na.rm = TRUE))\n  lims <- stats::quantile(all_vals, probs = stretch_q, na.rm = TRUE, names = FALSE)\n  \n  # Wahrheit\n  p_truth <- .plot_raster_gg(truth_raster, title = paste0(which_time, \" — truth\"),\n                             palette = temp_palette, q = stretch_q, lims = lims)\n  \n  # Vorhersagen (Raster -> ggplot; ggplot bleibt ggplot)\n  p_pred_list <- Map(function(obj, nm) {\n    if (inherits(obj, \"SpatRaster\")) .plot_raster_gg(obj, title = nm, palette = temp_palette, q = stretch_q, lims = lims)\n    else if (inherits(obj, \"ggplot\")) obj + ggplot2::labs(title = nm)\n    else stop(\"Vorhersage-Typ nicht unterstützt: \", class(obj)[1])\n  }, preds, names(preds) %||% paste0(\"model_\", seq_along(preds)))\n  \n  p_preds <- patchwork::wrap_plots(p_pred_list, ncol = if (layout == \"vertical\") 1 else 3)\n  \n  # Fehler/Diagnose\n  p_box_rmse <- make_block_metric_box(cv_tbl, which_time = which_time, tail_cap = 0.995)\n  p_box_ae   <- make_abs_error_box  (cv_tbl, which_time = which_time, tail_cap = 0.995)\n  p_scatter  <- make_obs_pred_scatter(cv_tbl, which_time = which_time)\n  p_dens     <- make_residual_density(cv_tbl, which_time = which_time)\n  p_errs     <- (p_box_rmse | p_box_ae) / (p_scatter | p_dens)\n  \n  if (layout == \"vertical\") (p_truth / p_preds / p_errs) else ((p_truth | p_preds) / p_errs)\n}\n# --- Robust: Vorhersagen aus beliebigen 'maps'-Formen herausziehen ------\n.get_preds_from_maps <- function(maps) {\n  # 1) SpatRaster direkt\n  if (inherits(maps, \"SpatRaster\")) {\n    ul <- terra::unstack(maps)\n    names(ul) <- names(maps)\n    return(ul)\n  }\n  # 2) Liste mit typischen Feldern\n  if (is.list(maps)) {\n    if (!is.null(maps$preds))          return(maps$preds)\n    if (!is.null(maps$pred_rasters))   return(maps$pred_rasters)\n    if (!is.null(maps$pred_stack) && inherits(maps$pred_stack, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$pred_stack); names(ul) <- names(maps$pred_stack); return(ul)\n    }\n    if (!is.null(maps$stack) && inherits(maps$stack, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$stack); names(ul) <- names(maps$stack); return(ul)\n    }\n    if (!is.null(maps$maps) && inherits(maps$maps, \"SpatRaster\")) {\n      ul <- terra::unstack(maps$maps); names(ul) <- names(maps$maps); return(ul)\n    }\n    # 3) Liste, die bereits einzelne SpatRaster oder ggplots enthält\n    cand <- maps[ vapply(maps, function(x) inherits(x, \"SpatRaster\") || inherits(x, \"ggplot\"), logical(1)) ]\n    if (length(cand) > 0) return(cand)\n  }\n  stop(\"build_panels_with_errors(): In 'maps' keine Vorhersagen gefunden.\")\n}\n\n# --- Kartenplot mit optionalen Achsenticks/labels ----------------------\n.plot_map_axes <- function(r, title, cols, lims, q = c(0.02,0.98),\n                           base_size = 14, tick_n = 5,\n                           show_axis_labels = FALSE, show_axis_ticks = TRUE) {\n  stopifnot(terra::nlyr(r) == 1)\n  df <- as.data.frame(r, xy = TRUE, na.rm = FALSE)\n  nm <- names(df)[3]\n\n  if (is.null(lims) || !all(is.finite(lims)) || lims[1] >= lims[2]) {\n    vv <- terra::values(r, na.rm = TRUE)\n    lims <- stats::quantile(vv, probs = q, na.rm = TRUE, names = FALSE)\n    if (!all(is.finite(lims)) || lims[1] == lims[2]) lims <- range(vv, na.rm = TRUE) + c(-1e-6, 1e-6)\n  }\n  if (is.function(cols)) cols <- cols(256)\n  if (!is.atomic(cols) || length(cols) < 2) cols <- grDevices::hcl.colors(256, \"YlOrRd\")\n\n  ggplot2::ggplot(df, ggplot2::aes(x, y, fill = .data[[nm]])) +\n    ggplot2::geom_raster() +\n    ggplot2::coord_equal(expand = FALSE) +\n    ggplot2::scale_x_continuous(expand = c(0,0), breaks = scales::breaks_pretty(n = tick_n)) +\n    ggplot2::scale_y_continuous(expand = c(0,0), breaks = scales::breaks_pretty(n = tick_n)) +\n    ggplot2::scale_fill_gradientn(colours = cols, limits = lims, oob = scales::squish) +\n    ggplot2::labs(title = title, x = NULL, y = NULL, fill = \"°C\") +\n    ggplot2::theme_minimal(base_size = base_size) +\n    ggplot2::theme(\n      legend.position = \"right\",\n      plot.title = ggplot2::element_text(face = \"bold\"),\n      axis.title   = ggplot2::element_blank(),\n      axis.text    = if (show_axis_labels) ggplot2::element_text(size = base_size - 3) else ggplot2::element_blank(),\n      axis.ticks   = if (show_axis_ticks)  ggplot2::element_line(linewidth = 0.25) else ggplot2::element_blank(),\n      panel.border = ggplot2::element_rect(fill = NA, colour = \"grey40\", linewidth = .4)\n    )\n}\nbuild_panels_truth_preds_errors_paged <- function(\n  maps, truth_raster, cv_tbl, which_time,\n  models_per_page = 4,\n  model_order      = NULL,\n  temp_pal         = temp_palette,     # Vektor ODER Funktion -> wird zu Vektor\n  stretch_q        = c(0.02, 0.98),\n  errors_height    = 1.2,\n  scatter_next_to_truth = TRUE,        # Scatter rechts von Truth?\n  top_widths       = c(1.1, 0.9),      # Breitenverhältnis Truth | Scatter\n  show_second_legend = FALSE           # zweite °C-Legende bei den Preds unterdrücken\n) {\n  stopifnot(length(stretch_q) == 2)\n  if (is.function(temp_pal)) temp_pal <- temp_pal(256)\n  stopifnot(is.atomic(temp_pal), length(temp_pal) >= 2)\n\n  # Vorhersagen einsammeln / Reihenfolge\n  preds_raw  <- .get_preds_from_maps(maps)\n  pred_names <- names(preds_raw) %||% paste0(\"model_\", seq_along(preds_raw))\n  if (!is.null(model_order)) {\n    keep <- intersect(model_order, pred_names)\n    if (!length(keep)) stop(\"model_order enthält keine gültigen Modellnamen.\")\n    preds_raw  <- preds_raw[keep]\n    pred_names <- keep\n  }\n\n  # Gemeinsame Farbskala\n  all_vals <- c(terra::values(truth_raster, na.rm = TRUE))\n  for (p in preds_raw) if (inherits(p, \"SpatRaster\")) all_vals <- c(all_vals, terra::values(p, na.rm = TRUE))\n  lims <- stats::quantile(all_vals, probs = stretch_q, na.rm = TRUE, names = FALSE)\n  if (all(is.finite(lims)) && lims[1] == lims[2]) {\n    eps <- .Machine$double.eps * max(1, abs(lims[1])); lims <- lims + c(-eps, eps)\n  }\n\n  # Helfer: Raster -> ggplot\n  make_tile <- function(obj, title_txt, show_legend = TRUE) {\n    if (inherits(obj, \"SpatRaster\")) {\n      g <- .plot_raster_gg(obj, title = title_txt, palette = temp_pal, q = stretch_q, lims = lims)\n      if (!show_legend) g <- g + ggplot2::theme(legend.position = \"none\")\n      g\n    } else if (inherits(obj, \"ggplot\")) {\n      obj + ggplot2::labs(title = title_txt)\n    } else stop(\"Nicht unterstützter Prediction-Typ: \", class(obj)[1])\n  }\n\n  # Truth (+ optional Scatter daneben)\n  p_truth   <- .plot_raster_gg(truth_raster, title = paste0(which_time, \" — truth\"),\n                               palette = temp_pal, q = stretch_q, lims = lims)\n  p_scatter <- make_obs_pred_scatter(cv_tbl, which_time = which_time)\n\n  # Prediction-Kacheln bauen (nur erste mit °C-Legende falls gewünscht)\n  pred_tiles <- lapply(seq_along(preds_raw), function(i) {\n    show_leg <- if (isTRUE(show_second_legend)) TRUE else (i == 1L)\n    make_tile(preds_raw[[i]], pred_names[i], show_legend = show_leg)\n  })\n\n  # Paginierung\n  n <- length(pred_tiles)\n  idx_split <- split(seq_len(n), ceiling(seq_len(n) / models_per_page))\n\n  pages <- lapply(idx_split, function(idx) {\n    preds_row <- patchwork::wrap_plots(pred_tiles[idx], nrow = 1, ncol = length(idx))\n\n    top_row <- if (isTRUE(scatter_next_to_truth)) {\n      (p_truth | (p_scatter + ggplot2::theme(legend.position = \"none\"))) +\n        patchwork::plot_layout(widths = top_widths)\n    } else {\n      p_truth\n    }\n\n    # Errors unten: wenn Scatter schon oben, unten nur Dichte\n    p_box_rmse <- make_block_metric_box(cv_tbl, which_time = which_time, tail_cap = 0.995)\n    p_box_ae   <- make_abs_error_box  (cv_tbl, which_time = which_time, tail_cap = 0.995)\n    p_dens     <- make_residual_density(cv_tbl, which_time = which_time)\n    p_errors   <- (p_box_rmse | p_box_ae) / p_dens\n\n    (top_row / preds_row / p_errors) +\n      patchwork::plot_layout(heights = c(1, 1, errors_height), guides = \"collect\") &\n      ggplot2::theme(legend.position = \"right\")\n  })\n\n  pages\n}\n```\n:::\n\n\n\n# F. Run models with spatial CV and plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ------------------------------------------------------------------------------\n# run_for_time(stn_sf, truth_r, label, scen_local, block_m, models)\n# Purpose:\n#   Convenience wrapper to run leave-block-out CV, build prediction maps,\n#   and compose the \"truth/prediction/error with CV residuals\" panel.\n# Inputs:\n#   - stn_sf: station sf for one time slice (T14 or T05).\n#   - truth_r: corresponding truth raster (R14 or R05).\n#   - label: \"T14\" or \"T05\" for plot titles and selections.\n#   - scen_local: scenario object with rasters.\n#   - block_m: block size in meters for spatial CV.\n#   - models: vector of model names to evaluate.\n# Returns:\n#   list(res = cv result, maps = predict_maps result, panel = patchwork plot).\n# ------------------------------------------------------------------------------\nrun_for_time <- function(stn_sf, truth_r, label,\n                         scen_local = scen,\n                         block_m = block_size,\n                         models = models_use,\n                         layout = c(\"horizontal\",\"vertical\")) {\n  layout <- match.arg(layout)\n  res   <- run_lbo_cv(stn_sf, scen_local$E, block_size = block_m, models = models)\n  maps <- predict_maps(stn_sf, truth_r, which_time = label,\n                     scen = scen_local, models = models,\n                     lc_levels = scen_local$lc_levels)\n  # panel <- build_panels_with_errors(maps, truth_r, res$cv, stn_sf, label,\n  #                                   temp_palette = temp_palette, stretch_q = stretch_q,\n  #                                   layout = layout)\n  # panel <- build_panels_truth_preds_errors_paged(maps =maps, truth_raster = truth_r, cv_tbl = res$cv,  which_time = label)\n  panel <- build_panels_truth_preds_errors_paged(\n  maps, truth_r, res$cv, label,\n  models_per_page = 7,\n  scatter_next_to_truth = TRUE\n)\n  list(res = res, maps = maps, panel = panel)\n}\n\n# --- Factor + Level helpers ---------------------------------------------------\n.safe_levels <- function(x) unique(na.omit(as.character(x)))\n\n# Train/Grid sauber auf gemeinsame Levels bringen (+ Fallback-Bucket)\n.align_factor_pair <- function(train_x, grid_x, fallback = \"__OTHER__\") {\n  tl <- .safe_levels(train_x)\n  if (length(tl) == 0L) {\n    return(list(use = FALSE, train = NULL, grid = NULL, levels = character()))\n  }\n  lev <- unique(c(tl, fallback))\n  trc <- as.character(train_x); trc[is.na(trc)] <- fallback; trc[!(trc %in% lev)] <- fallback\n  gdc <- as.character(grid_x);  gdc[is.na(gdc)]  <- fallback; gdc[!(gdc %in% lev)] <- fallback\n  list(use = TRUE, train = factor(trc, levels = lev), grid = factor(gdc, levels = lev), levels = lev)\n}\n\n# Optional: numerische LC-Codes auf Labels mappen\n.map_lc <- function(codes, lc_levels = NULL) {\n  if (!is.null(lc_levels)) {\n    ok <- !is.na(codes) & codes >= 1 & codes <= length(lc_levels)\n    out <- rep(NA_character_, length(codes)); out[ok] <- lc_levels[codes[ok]]\n    out\n  } else as.character(codes)\n}\n\n# --- Kernel + Extract guards --------------------------------------------------\n.mean_kernel_for_R <- function(r, R_m) {\n  px <- mean(terra::res(r))\n  half <- max(1L, ceiling(R_m / px))     # >= 1 px\n  k <- 2L * half + 1L                    # odd size\n  W <- matrix(1, nrow = k, ncol = k)\n  W / sum(W)\n}\n\nsmooth_mean_R <- function(r, R_m) {\n  W <- .mean_kernel_for_R(r, R_m)\n  terra::focal(r, w = W, fun = \"mean\", na.policy = \"omit\", pad = TRUE, normalize = FALSE)\n}\n\n.extract_to_pts <- function(r, pts_sf) {\n  out <- try(terra::extract(r, terra::vect(pts_sf), ID = FALSE)[,1], silent = TRUE)\n  if (inherits(out, \"try-error\") || length(out) == 0L) rep(NA_real_, nrow(pts_sf)) else out\n}\n\n# --- GAM guards ---------------------------------------------------------------\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.k_cap    <- function(x, kmax = 15) {\n  ux <- dplyr::n_distinct(x[is.finite(x)])\n  max(4, min(kmax, ux - 1L))\n}\n\nsafe_gam_formula <- function(d, include_lc = FALSE) {\n  stopifnot(all(c(\"temp\",\"x\",\"y\") %in% names(d)))\n  d <- d[stats::complete.cases(d[, c(\"temp\",\"x\",\"y\")]), , drop = FALSE]\n  n    <- nrow(d)\n  n_xy <- dplyr::n_distinct(paste0(round(d$x,3), \"_\", round(d$y,3)))\n\n  base <- if (n_xy >= 4) sprintf(\"temp ~ s(x,y,bs='tp',k=%d)\", .k_for_xy(n, n_xy)) else \"temp ~ x + y\"\n\n  add <- character(0)\n  if (\"z_surf\" %in% names(d) && dplyr::n_distinct(d$z_surf) > 3)\n    add <- c(add, sprintf(\"s(z_surf,bs='tp',k=%d)\", .k_cap(d$z_surf, 20)))\n  if (\"slp\" %in% names(d) && dplyr::n_distinct(d$slp) > 3)\n    add <- c(add, sprintf(\"s(slp,bs='tp',k=%d)\", .k_cap(d$slp, 12)))\n  if (\"cosi\" %in% names(d) && dplyr::n_distinct(d$cosi) > 3)\n    add <- c(add, sprintf(\"s(cosi,bs='tp',k=%d)\", .k_cap(d$cosi, 12)))\n\n  if (include_lc && \"lc\" %in% names(d)) {\n    d$lc <- droplevels(factor(d$lc))\n    if (nlevels(d$lc) >= 2) add <- c(add, \"lc\")\n  }\n\n  as.formula(paste(base, paste(add, collapse = \" + \"),\n                   sep = if (length(add)) \" + \" else \"\"))\n}\n```\n:::\n\n\n\n## Truth, predictions & error panels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Variogram/Scale utilities -----------------------------------------------\n# ------------------------------------------------------------------------------\n\n# ------------------------------------------------------------------------------\n# plot_variogram_with_scales(vg, L50, L95, sill, title)\n# Purpose:\n#   Quick ggplot helper to display the empirical variogram with dotted sill and\n#   dashed vertical markers at L50 and L95 for interpretation.\n# Returns: a ggplot object.\n# ------------------------------------------------------------------------------\nplot_variogram_with_scales <- function(vg, L50, L95, sill, title = \"Empirical variogram\") {\n  df <- as.data.frame(vg)\n  ggplot2::ggplot(df, ggplot2::aes(dist, gamma)) +\n    ggplot2::geom_point(size = 1.4) +\n    ggplot2::geom_line(alpha = 0.5) +\n    ggplot2::geom_hline(yintercept = sill, linetype = \"dotted\", linewidth = 0.4) +\n    ggplot2::geom_vline(xintercept = L50, colour = \"#2b8cbe\", linetype = \"dashed\") +\n    ggplot2::geom_vline(xintercept = L95, colour = \"#de2d26\", linetype = \"dashed\") +\n    ggplot2::annotate(\"text\", x = L50, y = 0, vjust = -0.5,\n                      label = sprintf(\"L50 = %.0f m\", L50)) +\n    ggplot2::annotate(\"text\", x = L95, y = 0, vjust = -0.5,\n                      label = sprintf(\"L95 = %.0f m\", L95), colour = \"#de2d26\") +\n    ggplot2::theme_minimal() +\n    ggplot2::labs(title = title, x = \"Distance (m)\", y = \"Semivariance\")\n}\n\n# --- DEM smoothing + sun geometry --------------------------------------------\n# ------------------------------------------------------------------------------\n# gaussian_focal(r, radius_m, sigma_m = NULL)\n# Purpose:\n#   Build a separable, normalized 2D Gaussian kernel (in pixels) from a target\n#   radius in meters, then return the kernel matrix to be used with terra::focal.\n# Inputs:\n#   - r: reference raster to read pixel size from.\n#   - radius_m: target smoothing radius (meters).\n#   - sigma_m: optional sigma; by default half the radius.\n# Returns:\n#   A normalized kernel matrix suitable for terra::focal() smoothing.\n# ------------------------------------------------------------------------------\ngaussian_focal <- function(r, radius_m, sigma_m = NULL) {\n  resx <- terra::res(r)[1]\n  if (is.null(sigma_m)) sigma_m <- radius_m / 2\n  rad_px   <- max(1L, round(radius_m / resx))\n  sigma_px <- max(0.5, sigma_m / resx)\n  xs <- -rad_px:rad_px\n  k1 <- exp(-0.5 * (xs / sigma_px)^2); k1 <- k1 / sum(k1)\n  K  <- outer(k1, k1); K / sum(K)\n}\n\n# ------------------------------------------------------------------------------\n# smooth_dem_and_derive(E, alt, az, radius_m)\n# Purpose:\n#   Smooth the DEM at a given metric radius and recompute slope and\n#   cosine-of-incidence for a specified sun position (alt/az).\n# Returns:\n#   list(Es = smoothed DEM, slp = slope, cosi = cosine-of-incidence)\n# ------------------------------------------------------------------------------\nsmooth_dem_and_derive <- function(E, alt, az, radius_m) {\n  K   <- gaussian_focal(E, radius_m)\n  Es  <- terra::focal(E, w = K, fun = mean, na.policy = \"omit\", pad = TRUE)\n  slp <- terra::terrain(Es, v = \"slope\",  unit = \"radians\")\n  asp <- terra::terrain(Es, v = \"aspect\", unit = \"radians\")\n  zen <- (pi/2 - alt)\n  ci  <- cos(slp)*cos(zen) + sin(slp)*sin(zen)*cos(az - asp)\n  ci  <- terra::ifel(ci < 0, 0, ci)\n  list(Es = Es, slp = slp, cosi = ci)\n}\n\n# --- helpers to cap k by available info --------------------------------\n.k_for_xy <- function(n, n_xy) max(3, min(60, n_xy - 1L, floor(n * 0.8)))\n.kcap_unique <- function(x, kmax) {\n  ux <- unique(x[is.finite(x)])\n  nu <- length(ux)\n  if (nu <= 3) return(0L)                # treat as constant/near-constant\n  max(4L, min(kmax, nu - 1L))\n}\n\n# --- CV of GAM with R-smoothed predictors (robust k) -------------------\n# ------------------------------------------------------------------------------\n# cv_gam_with_R(stn_sf, E, alt, az, R, block_size_m)\n# Purpose:\n#   Leave-block-out CV of a GAM whose predictors are computed from a DEM\n#   smoothed at radius R (meters). This aligns the drift scale to the process\n#   scale before fitting, then evaluates predictive skill via blocked holdouts.\n# Notes:\n#   - Contains guards for low sample size and dynamic k to avoid mgcv errors.\n# Returns:\n#   list(cv = per-point CV table, RMSE = numeric)\n# ------------------------------------------------------------------------------\ncv_gam_with_R <- function(stn_sf, E, alt = NULL, az = NULL, R, block_size_m = NULL) {\n  \n  # ---- 0) Blockgröße sauber auflösen (tuning-fähig)\n  bs <- suppressWarnings(as.numeric(block_size_m)[1])             # bevorzugt: Tuning\n  if (!is.finite(bs) || bs <= 0) {\n    bs <- suppressWarnings(as.numeric(get0(\"block_size\",          # Fallback: global\n                                           ifnotfound = NA_real_)))\n  }\n  if (!is.finite(bs) || bs <= 0)\n    stop(\"cv_gam_with_R(): keine gültige Blockgröße gefunden (Tuning oder global).\")\n  \n  # ---- 1) R-gesmoothete Raster bauen (wie bei dir)\n  zR   <- smooth_mean_R(E, R)\n  slpR <- terra::terrain(zR, v = \"slope\",  unit = \"radians\")\n  aspR <- terra::terrain(zR, v = \"aspect\", unit = \"radians\")\n  cosiR <- if (!is.null(alt) && !is.null(az)) {\n    ci <- cos(slpR)*cos(pi/2 - alt) + sin(slpR)*sin(pi/2 - alt)*cos(az - aspR)\n    terra::ifel(ci < 0, 0, ci)\n  } else NULL\n  \n  # ---- 2) Werte an Stationen extrahieren (wie bei dir)\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) {\n    xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2]\n  }\n  fill_med <- function(v) { m <- stats::median(v[is.finite(v)], na.rm = TRUE); ifelse(is.finite(v), v, m) }\n  stn_sf$z_surf_R <- fill_med(.extract_to_pts(zR,   stn_sf))\n  stn_sf$slp_R    <- fill_med(.extract_to_pts(slpR, stn_sf))\n  stn_sf$cosi_R   <- if (is.null(cosiR)) rep(NA_real_, nrow(stn_sf)) else fill_med(.extract_to_pts(cosiR, stn_sf))\n  \n  # ---- 3) Blöcke bauen und zuordnen (einheitlich mit bs)\n  bb_poly <- sf::st_as_sfc(sf::st_bbox(stn_sf), crs = sf::st_crs(stn_sf))\n  blocks  <- sf::st_make_grid(bb_poly, cellsize = c(bs, bs), what = \"polygons\")\n  blocks  <- sf::st_sf(block_id = seq_along(blocks), geometry = blocks)\n  \n  stn_blk <- sf::st_join(stn_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (anyNA(stn_blk$block_id)) {\n    i <- is.na(stn_blk$block_id)\n    stn_blk$block_id[i] <- blocks$block_id[sf::st_nearest_feature(stn_blk[i,], blocks)]\n  }\n  \n  if (!all(c(\"x\",\"y\") %in% names(stn_blk))) {\n    xy <- sf::st_coordinates(stn_blk); stn_blk$x <- xy[,1]; stn_blk$y <- xy[,2]\n  }\n  \n  # ---- 4) CV-Schleife (dein Code unverändert weiter)\n  bids  <- sort(unique(stn_blk$block_id))\n  preds <- vector(\"list\", length(bids)); j <- 0L\n  for (b in bids) {\n    te <- stn_blk[stn_blk$block_id == b, ]\n    tr <- stn_blk[stn_blk$block_id != b, ]\n    \n    dtr <- sf::st_drop_geometry(tr)\n    need <- c(\"temp\",\"x\",\"y\",\"z_surf_R\",\"slp_R\",\"cosi_R\")\n    dtr  <- dtr[stats::complete.cases(dtr[, intersect(need, names(dtr)), drop = FALSE]), , drop = FALSE]\n    if (nrow(dtr) < 10) next\n    \n    n_xy <- dplyr::n_distinct(paste0(round(dtr$x,3), \"_\", round(dtr$y,3)))\n    k_xy <- .k_for_xy(nrow(dtr), n_xy)\n    k_z  <- .kcap_unique(dtr$z_surf_R, 20)\n    k_sl <- .kcap_unique(dtr$slp_R,    12)\n    k_ci <- .kcap_unique(dtr$cosi_R,   12)\n    \n    terms <- c()\n    terms <- c(terms, if (n_xy >= 4) sprintf(\"s(x,y,bs='tp',k=%d)\", k_xy) else \"x + y\")\n    terms <- c(terms, if (k_z  >= 4) sprintf(\"s(z_surf_R,bs='tp',k=%d)\", k_z)  else \"z_surf_R\")\n    if (length(unique(dtr$slp_R[is.finite(dtr$slp_R)])) > 1)\n      terms <- c(terms, if (k_sl >= 4) sprintf(\"s(slp_R,bs='tp',k=%d)\", k_sl) else \"slp_R\")\n    if (any(is.finite(dtr$cosi_R)) && length(unique(dtr$cosi_R[is.finite(dtr$cosi_R)])) > 1)\n      terms <- c(terms, if (k_ci >= 4) sprintf(\"s(cosi_R,bs='tp',k=%d)\", k_ci) else \"cosi_R\")\n    \n    form <- as.formula(paste(\"temp ~\", paste(terms, collapse = \" + \")))\n    gm <- mgcv::gam(form, data = dtr, method = \"REML\", select = TRUE)\n    \n    dte <- sf::st_drop_geometry(te)\n    ph  <- try(stats::predict(gm, newdata = dte, type = \"response\"), silent = TRUE)\n    if (inherits(ph, \"try-error\")) ph <- rep(NA_real_, nrow(dte))\n    \n    j <- j + 1L\n    preds[[j]] <- tibble::tibble(id = te$id, obs = te$temp, pred = as.numeric(ph), block_id = b)\n  }\n  \n  preds <- preds[seq_len(j)]\n  if (!length(preds)) {\n    return(list(cv = tibble::tibble(id = integer(), obs = numeric(), pred = numeric(), block_id = integer()),\n                RMSE = NA_real_))\n  }\n  out  <- dplyr::bind_rows(preds)\n  rmse <- sqrt(mean((out$pred - out$obs)^2, na.rm = TRUE))\n  list(cv = out, RMSE = rmse)\n}\n\n# --- U-curve tuning -----------------------------------------------------------\n# ------------------------------------------------------------------------------\n# tune_Rstar_ucurve(stn_sf, E, alt, az, L50, L95, block_fallback, n_grid, extra)\n# Purpose:\n#   Scan candidate R values (around the L50–L95 interval) and pick R* that\n#   minimises blocked-CV RMSE. Returns the scan table and chosen R*.\n# Returns:\n#   list(grid = data.frame(R, RMSE), R_star, block_m)\n# ------------------------------------------------------------------------------\ntune_Rstar_ucurve <- function(stn_sf, E, alt, az, L50, L95, block_fallback = 120, n_grid = 6, extra = c(0.8, 1.2)) {\n  L50 <- as.numeric(L50); L95 <- as.numeric(L95)\n  if (!is.finite(L50) || !is.finite(L95) || L95 <= L50) {\n    e <- terra::ext(E)\n    dom_diag <- sqrt((terra::xmax(e)-terra::xmin(e))^2 + (terra::ymax(e)-terra::ymin(e))^2)\n    L50 <- dom_diag/10; L95 <- dom_diag/4\n  }\n  block_m <- max(block_fallback, round(L50))\n  R_min <- max(10, round(L50*extra[1])); R_max <- round(L95*extra[2])\n  R_grid <- unique(round(seq(R_min, R_max, length.out = n_grid)))\n  df <- do.call(rbind, lapply(R_grid, function(R) { z <- cv_gam_with_R(stn_sf, E, alt, az, R = R, block_size_m = block_m); c(R = R, RMSE = z$RMSE) })) |> as.data.frame()\n  R_star <- df$R[which.min(df$RMSE)]\n  list(grid = df, R_star = as.numeric(R_star), block_m = block_m)\n}\n\n# ------------------------------------------------------------------------------\n# plot_ucurve(df, R_star, title)\n# Purpose:\n#   Visual helper to display the U-curve of RMSE vs. drift radius R with a\n#   dashed marker at the selected R*.\n# Returns: a ggplot object.\n# ------------------------------------------------------------------------------\nplot_ucurve <- function(df, R_star, title = \"U-curve: tune R\") {\n  ggplot2::ggplot(df, ggplot2::aes(R, RMSE)) +\n    ggplot2::geom_line() + ggplot2::geom_point() +\n    ggplot2::geom_vline(xintercept = R_star, linetype = \"dashed\", colour = \"#de2d26\") +\n    ggplot2::theme_minimal() + ggplot2::labs(title = title, x = \"Drift radius R (m)\", y = \"RMSE (block-CV)\")\n}\n\n# --- Factor alignment (robust) -----------------------------------------------\n.align_factor_to_model <- function(x, lev_model) {\n  xs <- as.character(x)\n  if (length(lev_model) == 0L) return(factor(rep(NA_character_, length(xs))))\n  y <- factor(xs, levels = lev_model)\n  if (anyNA(y)) {\n    xs[is.na(y)] <- lev_model[1]\n    y <- factor(xs, levels = lev_model)\n  }\n  y\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---------- SF-only learners ----------\npred_Voronoi <- function(train_sf, test_sf) {\n  idx <- sf::st_nearest_feature(test_sf, train_sf)\n  as.numeric(train_sf$temp)[idx]\n}\n\npred_IDW <- function(train_sf, test_sf, idp = 2) {\n  pr <- suppressWarnings(gstat::idw(temp ~ 1, locations = train_sf, newdata = test_sf, idp = idp))\n  as.numeric(pr$var1.pred)\n}\n\n.default_vgm <- function(values, model = \"Exp\", range = 100) {\n  psill <- stats::var(values, na.rm = TRUE); nug <- 0.1 * psill\n  gstat::vgm(psill = psill, model = model, range = range, nugget = nug)\n}\n\npred_OK <- function(train_sf, test_sf) {\n  vg      <- suppressWarnings(gstat::variogram(temp ~ 1, data = train_sf))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) vgm_fit <- .default_vgm(train_sf$temp)\n  pr <- suppressWarnings(gstat::krige(temp ~ 1, locations = train_sf, newdata = test_sf, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n\n.align_factor_to_model <- function(x, lev_model) {\n  y <- factor(as.character(x), levels = lev_model)\n  if (anyNA(y)) y[is.na(y)] <- lev_model[1]\n  y\n}\n.fill_num_na_vec <- function(x, ref) {\n  m <- stats::median(ref[is.finite(ref)], na.rm = TRUE)\n  x[!is.finite(x)] <- m\n  x\n}\n\n# --- sf-only KED (schluckt extra Args wie E=E) ----------------------\npred_KED <- function(train_sf, test_sf, ...) {\n  stopifnot(inherits(train_sf, \"sf\"), inherits(test_sf, \"sf\"))\n  need <- c(\"z_surf\",\"slp\",\"cosi\")\n  miss <- setdiff(need, names(train_sf))\n  if (length(miss)) stop(\"pred_KED(): fehlende Drift-Spalten im Training: \",\n                         paste(miss, collapse = \", \"))\n  \n  # Optional LC als Faktor angleichen\n  use_lc <- \"lc\" %in% names(train_sf) && \"lc\" %in% names(test_sf)\n  tr <- train_sf\n  te <- test_sf\n  if (use_lc) {\n    tr$lc <- droplevels(factor(tr$lc))\n    te$lc <- factor(as.character(te$lc), levels = levels(tr$lc))\n    te$lc[is.na(te$lc)] <- levels(tr$lc)[1]\n  }\n  \n  # fehlende numerische Drifts im TEST mit Trainingsmedian auffüllen\n  for (nm in need) {\n    m <- stats::median(tr[[nm]][is.finite(tr[[nm]])], na.rm = TRUE)\n    te[[nm]][!is.finite(te[[nm]])] <- m\n  }\n  \n  # nur vollständige Trainingszeilen\n  keep_tr <- c(\"temp\", need, if (use_lc) \"lc\")\n  dtr <- sf::st_drop_geometry(tr)[, keep_tr, drop = FALSE]\n  ok  <- stats::complete.cases(dtr)\n  tr  <- tr[ok, ]\n  if (nrow(tr) < 5) return(rep(NA_real_, nrow(te)))\n  \n  # Formel: lineare Drifts + optional LC\n  form <- stats::as.formula(paste(\"temp ~\", paste(c(need, if (use_lc) \"lc\"), collapse = \" + \")))\n  \n  # Variogramm + robuster Fit\n  vg      <- suppressWarnings(gstat::variogram(form, data = tr))\n  vgm_fit <- try(suppressWarnings(gstat::fit.variogram(vg, gstat::vgm(\"Exp\"))), silent = TRUE)\n  if (inherits(vgm_fit, \"try-error\")) {\n    ps <- stats::var(sf::st_drop_geometry(tr)$temp, na.rm = TRUE)\n    vgm_fit <- gstat::vgm(psill = ps, model = \"Exp\", range = max(vg$dist, na.rm = TRUE)/3, nugget = 0.1*ps)\n  }\n  \n  # Kriging mit externen Drifts (UK/KED)\n  pr <- suppressWarnings(gstat::krige(form, locations = tr, newdata = te, model = vgm_fit))\n  as.numeric(pr$var1.pred)\n}\n```\n:::\n\n\n\n## Block-wise and per-station errors\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Leave-Block-Out CV -------------------------------------------------------\n# ------------------------------------------------------------------------------\n# make_blocks_and_assign(pts_sf, E, block_size)\n# Purpose:\n#   Build a square grid of spatial blocks and assign each station to a block\n#   (nearest if on edge). Used by leave-block-out cross-validation.\n# Inputs:\n#   - pts_sf: station sf with geometry.\n#   - E: reference raster for domain extent/CRS.\n#   - block_size: block edge length in meters.\n# Returns:\n#   list(blocks = sf polygons, pts = station sf with block_id).\n# ------------------------------------------------------------------------------\nmake_blocks_and_assign <- function(pts_sf, E, block_size = 100) {\n  bb <- sf::st_as_sfc(sf::st_bbox(c(xmin = terra::xmin(E), ymin = terra::ymin(E), xmax = terra::xmax(E), ymax = terra::ymax(E)), crs = sf::st_crs(pts_sf)))\n  gr <- sf::st_make_grid(bb, cellsize = c(block_size, block_size), what = \"polygons\")\n  blocks <- sf::st_sf(block_id = seq_along(gr), geometry = gr)\n  pts_blk <- sf::st_join(pts_sf, blocks, join = sf::st_intersects, left = TRUE)\n  if (any(is.na(pts_blk$block_id))) {\n    nearest <- sf::st_nearest_feature(pts_blk[is.na(pts_blk$block_id), ], blocks)\n    pts_blk$block_id[is.na(pts_blk$block_id)] <- blocks$block_id[nearest]\n  }\n  list(blocks = blocks, pts = pts_blk)\n}\n\n# saubere Farbskala für viele Blöcke\n.discrete_cols <- function(n) scales::hue_pal()(n)\n\nplot_blocks_grid <- function(blocks, pts_blk, title = \"Blocks & stations\") {\n  # Ziel-CRS = CRS der Daten (UTM32N), Achsen in Metern\n  crs_plot <- sf::st_crs(pts_blk)\n  bb       <- sf::st_bbox(blocks)\n  n_blocks <- dplyr::n_distinct(pts_blk$block_id)\n  cols     <- .discrete_cols(max(1, n_blocks))\n\n  ggplot() +\n    geom_sf(data = blocks, fill = NA, color = \"grey50\", linewidth = 0.25) +\n    geom_sf(data = pts_blk, aes(color = factor(block_id)), size = 2, alpha = 0.95) +\n    scale_color_manual(values = cols, name = \"Block\") +\n    coord_sf(\n      crs  = crs_plot,    # <- erzwingt UTM32N als Plot-CRS (Meterachsen)\n      datum = NA,         # keine Gradnetz-Beschriftung\n      xlim = c(bb[\"xmin\"], bb[\"xmax\"]),\n      ylim = c(bb[\"ymin\"], bb[\"ymax\"]),\n      expand = FALSE\n    ) +\n    theme_minimal() +\n    labs(title = title, x = \"Easting (m)\", y = \"Northing (m)\")\n}\n\n\n# ------------------------------------------------------------------------------\n# run_lbo_cv(stn_sf, E, block_size, models)\n# Purpose:\n#   Perform leave-block-out cross-validation across the requested set of models.\n#   Each block is held out in turn; models are trained on the remainder and\n#   predictions are collected for the held-out stations.\n# Returns:\n#   list(cv = long per-point table, metrics = summary table, diag_plot, blocks_plot)\n# Notes:\n#   - No model settings are changed; this wrapper only orchestrates the CV.\n# ------------------------------------------------------------------------------\nrun_lbo_cv <- function(stn_sf, E, block_size = 100, models = models_use) {\n  if (!all(c(\"x\",\"y\") %in% names(stn_sf))) { xy <- sf::st_coordinates(stn_sf); stn_sf$x <- xy[,1]; stn_sf$y <- xy[,2] }\n  blk <- make_blocks_and_assign(stn_sf, E, block_size = block_size)\n  blocks_sf <- blk$blocks; stn_blk <- blk$pts\n  restore <- function(nm) if (!(nm %in% names(stn_blk))) stn_blk[[nm]] <<- stn_sf[[nm]][match(stn_blk$id, stn_sf$id)]\n  for (nm in c(\"temp\",\"z_surf\",\"slp\",\"cosi\",\"lc\",\"x\",\"y\")) restore(nm)\n\n  block_ids <- sort(unique(stn_blk$block_id))\n  out_list <- vector(\"list\", length(block_ids))\n  for (k in seq_along(block_ids)) {\n    b <- block_ids[k]\n    test_idx  <- which(stn_blk$block_id == b)\n    train_idx <- which(stn_blk$block_id != b)\n    train_sf <- stn_blk[train_idx, ]; test_sf <- stn_blk[test_idx, ]\n    pred_tbl <- lapply(models, function(m) {\n      p <- switch(m,\n        \"Voronoi\" = pred_Voronoi(train_sf, test_sf),\n        \"IDW\"     = pred_IDW(train_sf, test_sf),\n        \"OK\"      = pred_OK(train_sf, test_sf),\n        \"KED\"     = pred_KED(train_sf, test_sf, E = E),\n        \"RF\"      = pred_RF(train_sf, test_sf),\n        \"GAM\"     = pred_GAM(train_sf, test_sf),\n        stop(\"Unknown model: \", m)\n      )\n      tibble::tibble(model = m, id = test_sf$id, obs = test_sf$temp, pred = p, block_id = b)\n    })\n    out_list[[k]] <- dplyr::bind_rows(pred_tbl)\n  }\n\n  cv_tbl <- dplyr::bind_rows(out_list)\n  metrics <- cv_tbl %>%\n    dplyr::group_by(model) %>%\n    dplyr::summarise(\n      n    = dplyr::n(),\n      n_ok = sum(is.finite(obs) & is.finite(pred)),\n      MAE  = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(abs(pred[i]-obs[i])) else NA_real_},\n      RMSE = {i <- is.finite(obs) & is.finite(pred); if (any(i)) sqrt(mean((pred[i]-obs[i])^2)) else NA_real_},\n      Bias = {i <- is.finite(obs) & is.finite(pred); if (any(i)) mean(pred[i]-obs[i]) else NA_real_},\n      R2   = safe_r2(obs, pred),\n      .groups = \"drop\"\n    ) |>\n    dplyr::arrange(RMSE)\n\n  diag_plot <- ggplot(cv_tbl, aes(obs, pred)) +\n    geom_abline(slope=1, intercept=0, linetype=\"dashed\") +\n    geom_point(alpha=0.7) +\n    coord_equal() + theme_minimal() +\n    labs(title = sprintf(\"LBO-CV (block = %dm) — Observed vs Predicted\", block_size), x = \"Observed\", y = \"Predicted\") +\n    facet_wrap(~ model)\n\n  blocks_plot <- plot_blocks_grid(blocks_sf, stn_blk, title = sprintf(\"Blocks (%.0f m) & stations\", block_size))\n  list(cv = cv_tbl, metrics = metrics, diag_plot = diag_plot, blocks_plot = blocks_plot)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T14 ...\")\nlbo_cv_14_result <- run_for_time(stn_sf_14, scen$R14, \"T14\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Running LBO-CV and building maps for T05 ...\")\nlbo_cv_05_result <- run_for_time(stn_sf_05, scen$R05, \"T05\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlbo_cv_14_result$res$blocks_plot \n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-1.png){width=1350}\n:::\n\n```{.r .cell-code}\nlbo_cv_14_result$res$diag_plot\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-2.png){width=1350}\n:::\n\n```{.r .cell-code}\nlbo_cv_05_result$res$blocks_plot  \n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-3.png){width=1350}\n:::\n\n```{.r .cell-code}\nlbo_cv_05_result$res$diag_plot\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-4.png){width=1350}\n:::\n\n```{.r .cell-code}\nlbo_cv_14_result$panel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-5.png){width=1350}\n:::\n\n```{.r .cell-code}\nlbo_cv_05_result$panel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-6.png){width=1350}\n:::\n\n```{.r .cell-code}\np_block_box14  <- make_block_metric_box(lbo_cv_14_result$res$cv, \"T14\")\np_abserr_box14 <- make_abs_error_box(lbo_cv_14_result$res$cv,  \"T14\")\np_block_box05  <- make_block_metric_box(lbo_cv_05_result$res$cv, \"T05\")\np_abserr_box05 <- make_abs_error_box(lbo_cv_05_result$res$cv, \"T05\")\n\n(p_block_box14 | p_abserr_box14) / (p_block_box05 | p_abserr_box05)\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO_CV-maps-7.png){width=1350}\n:::\n:::\n\n\n\n## LBO-CV metrics and residuals\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(lbo_cv_14_result$res$metrics, digits = 3, caption = \"LBO-CV metrics — T14\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO-CV metrics — T14\n\n|model   |  n| n_ok|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|----:|-----:|-----:|------:|-----:|\n|GAM     | 60|   60| 0.275| 0.323| -0.005| 0.798|\n|KED     | 60|   60| 0.276| 0.333|  0.000| 0.784|\n|RF      | 60|   60| 0.375| 0.480|  0.011| 0.553|\n|IDW     | 60|   60| 0.541| 0.711|  0.088| 0.032|\n|OK      | 60|   60| 0.548| 0.716|  0.049| 0.016|\n|Voronoi | 60|   60| 0.667| 0.897|  0.205| 0.039|\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(lbo_cv_05_result$res$metrics, digits = 3, caption = \"LBO-CV metrics — T05\")\n```\n\n::: {.cell-output-display}\n\n\nTable: LBO-CV metrics — T05\n\n|model   |  n| n_ok|   MAE|  RMSE|   Bias|    R2|\n|:-------|--:|----:|-----:|-----:|------:|-----:|\n|GAM     | 60|   60| 0.232| 0.315| -0.013| 0.933|\n|RF      | 60|   60| 0.250| 0.323| -0.036| 0.932|\n|OK      | 60|   60| 0.624| 0.933| -0.067| 0.424|\n|IDW     | 60|   60| 0.792| 1.024| -0.127| 0.358|\n|Voronoi | 60|   60| 0.728| 1.169| -0.165| 0.346|\n|KED     | 60|   60| 0.794| 1.633|  0.218| 0.225|\n\n\n:::\n\n```{.r .cell-code}\nmake_obs_pred_scatter(lbo_cv_14_result$res$cv, \"T14\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO-CV-metrics-residuals-1.png){width=1350}\n:::\n\n```{.r .cell-code}\nmake_obs_pred_scatter(lbo_cv_05_result$res$cv, \"T05\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO-CV-metrics-residuals-2.png){width=1350}\n:::\n\n```{.r .cell-code}\nmake_residual_density(lbo_cv_14_result$res$cv, \"T14\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO-CV-metrics-residuals-3.png){width=1350}\n:::\n\n```{.r .cell-code}\nmake_residual_density(lbo_cv_05_result$res$cv, \"T05\")\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/LBO-CV-metrics-residuals-4.png){width=1350}\n:::\n:::\n\n\n\n\n\n\n## G Diagnostic\n\nAwesome—let’s read your **baseline (no R\\*)** results explicitly through\nthe lens of **process** (what drives T) and **scale** (over what\ndistances the drivers operate), model-by-model and time-by-time, then\nclose with a scale+process summary and concrete upgrades.\n\n------------------------------------------------------------------------\n\n# T14 (daytime)\n\n**Process you’re trying to capture**\n\n-   **Shortwave forcing** projected by **slope/aspect** → very **local**\n    facet contrasts.\n-   **Land-cover (LC)** modulates heating (forest shade, water inertia)\n    at **patch scale**.\n-   A mild **negative lapse** with elevation (broad scale).\n-   **Anisotropy** is limited; key is **small-scale** facet/LC\n    contrasts.\n\n**Observed performance (LBO-CV)** RMSE ↓ / R² ↑: **GAM (0.436 / 0.642)**\n\\< **KED (0.446 / 0.630)** ≈ **RF (0.449 / 0.619)** ≪ **IDW (0.813 /\n0.060)**, **Voronoi (0.828 / 0.025)**, **OK (0.848 / 0.085)**. Bias is\nsmall for the top 3 (GAM +0.032, KED +0.014, RF +0.050 °C).\n\n### What the diagnostics mean model-by-model\n\n-   **GAM — best alignment to process and scale**\n\n    -   **Boxplots:** tight across blocks → it’s matching\n        **facet/patch** scales.\n    -   **Obs–Pred:** near 1:1 with mild underfit only at the hottest\n        facets.\n    -   **Residual density:** narrow, centered at \\~0 → low variance,\n        low bias.\n    -   **Why:** smooth terms over **cos(i), slope, z, LC** let it bend\n        at the right (small) scales without oversmoothing.\n\n-   **KED — close second but still smoothing across LC edges**\n\n    -   **Boxplots:** slightly wider tails in blocks crossing **LC\n        transitions**.\n    -   **Obs–Pred:** more scatter than GAM; extremes compressed a bit.\n    -   **Residual density:** centered but broader.\n    -   **Why (scale):** isotropic variogram + untuned drift scale →\n        **blurs patch edges**. You need LC as drifts and\n        **R\\*-smoothed** topography terms.\n\n-   **RF — competitive third; sensitive to micro-texture**\n\n    -   **Boxplots:** a tad broader tails → some **patchy flicker** in\n        blocks.\n    -   **Obs–Pred:** good alignment; small warm bias (+0.05 °C).\n    -   **Residual density:** narrow, near-zero mean.\n    -   **Why (scale):** with raw x,y and unsmoothed features it can\n        pick up **too-fine** structure; it still handles **LC×cos(i)**\n        nonlinearity well.\n\n-   **OK / IDW / Voronoi — scale/process mismatch**\n\n    -   **Boxplots:** wide with outliers → **leakage** across sharp\n        contrasts.\n    -   **Obs–Pred:** under-dispersion (slope \\< 1 feel), big scatter.\n    -   **Residual density:** broad / skewed.\n    -   **Why:** purely spatial kernels **ignore physics**; their\n        smoothing scale is wrong for **facet/patch** structure.\n\n**Day takeaway:** day is **short-scale, LC-modulated**. Models that\nencode that structure (GAM, RF) win; kriging needs **right drifts at the\nright scale** to catch up.\n\n------------------------------------------------------------------------\n\n# T05 (pre-dawn)\n\n**Process you’re trying to capture**\n\n-   **Cold-air pooling**: a **cross-valley trough** (short scale\n    **across**, longer **along** → **anisotropy**).\n-   **Slope** term (drainage tendency).\n-   **LC offsets** (water warmest, bare coolest) and small **inversion**\n    with elevation.\n\n**Observed performance (LBO-CV)** RMSE ↓ / R² ↑: **RF (0.434 / 0.939)**\n\\< **GAM (0.622 / 0.864)** ≪ **KED (0.900 / 0.707)** \\< **OK (1.121 /\n0.547)** \\< **Voronoi (1.271 / 0.440)** \\< **IDW (1.457 / 0.246)**.\nBias: RF −0.018 (tiny cool), GAM −0.005, **KED +0.106** (under-cools),\n**IDW −0.137** (over-cools).\n\n### What the diagnostics mean model-by-model\n\n-   **RF — clear winner; nails nonlinear pooling+LC**\n\n    -   **Boxplots:** tightest by far → **right scale** and good\n        generalization.\n    -   **Obs–Pred:** almost exactly 1:1 → calibrated.\n    -   **Residual density:** slim, centered slightly negative (\\~−0.02\n        °C).\n    -   **Why (process):** tree splits capture **trough + slope + LC**\n        interactions; less sensitive to isotropy assumptions.\n\n-   **GAM — strong second; smooth but misses sharp minima**\n\n    -   **Boxplots:** tight but a bit wider than RF on trough blocks.\n    -   **Obs–Pred:** close to 1:1; modest extra spread.\n    -   **Residual density:** centered, slightly wider than RF.\n    -   **Why (scale):** splines smooth; without **R\\*-tuned features**\n        they can **round off** the deepest pooled cold.\n\n-   **KED — middle of the pack; wrong mean for pooling**\n\n    -   **Boxplots:** broader with tails in trough/blocked-flow blocks.\n    -   **Obs–Pred:** under-dispersion; misses deep minima.\n    -   **Residual density:** shifted **positive** (+0.106 °C) →\n        **under-cooling**.\n    -   **Why (process & anisotropy):** elevation drift ≠ pooling;\n        variogram likely **isotropic**, so it leaks across the\n        cross-valley gradient. Needs **distance-to-axis, cross-valley\n        coordinate, hill-block mask**, and **anisotropic** variogram.\n\n-   **OK / Voronoi / IDW — struggle in anisotropic pooling**\n\n    -   **Boxplots:** very wide; many outliers → big **scale mismatch**.\n    -   **Obs–Pred:** noisy; IDW shows global over-cool bias.\n    -   **Residual density:** broad (IDW skewed negative).\n    -   **Why:** they smooth across the **short cross-valley scale** and\n        ignore LC offsets.\n\n**Night takeaway:** night is **anisotropic** and **thresholdy**. RF\nhandles that best; GAM is close with proper feature scale. Kriging\n**must** get the **mean field** right and adopt **directional scale** to\ncompete.\n\n------------------------------------------------------------------------\n\n# Scale & process, integrated (what each model is buying/missing)\n\n| Time | Model | What process it encodes | How it treats scale | What the metrics+plots say |\n|-------------|-------------|-------------|-------------|----------------------|\n| T14 | **GAM** | cos(i) × LC × z interactions (smooth) | Implicit via spline basis; good at **patch/facet** | **Best RMSE/R²**; tight boxes; slender residuals → matched to **small** scales |\n| T14 | **RF** | Nonlinear LC × cos(i) well; can chase micro-texture | Learns whatever scale is in features (and x,y) | Near-best metrics; slightly broader boxes → **feature scale** not tuned |\n| T14 | **KED** | Mean = linear drifts (z, slope, cosi, maybe LC) | Variogram smooths **across** LC edges | Good but behind GAM; **tails** at LC transitions |\n| T14 | **OK/IDW/Voro** | None | Kernel/variogram at one scale | Broad tails, under-dispersion → **process blind** |\n| T05 | **RF** | Pooling trough + slope + LC (thresholdy) | Chooses effective scales from features | **Top RMSE/R²**, clean calibration; best boxes/density |\n| T05 | **GAM** | Smooth trough + slope + LC offsets | Smooths; needs tuned features | Strong second; misses sharp minima a bit |\n| T05 | **KED** | Wrong mean for pooling if only z/slope | Variogram often **isotropic** | Warm bias (+0.106 °C), broad boxes → **needs pooling drifts & anisotropy** |\n| T05 | **OK/IDW/Voro** | None | One isotropic smoothing scale | Very wide tails; density broad/skewed |\n\n------------------------------------------------------------------------\n\n# What to change (small steps, big benefits)\n\n**1) Add the missing *process* to kriging (both times)**\n\n-   **Day:** include **cos(i)** and **LC dummies** as external drifts;\n    compute cos(i) from the actual sun.\n-   **Night:** add **cross-valley coordinate / distance-to-axis**, a\n    **hill-block mask**, and **LC offsets** as drifts.\n-   This makes KED’s **mean** physically right; the variogram only\n    cleans **residual** texture.\n\n**2) Match the *scale* of the features (R\\*)**\n\n-   For **z, slope, cos(i)**, scan **R** over a practical range (e.g.,\n    variogram **L50→L95**) with **blocked CV** and rebuild features at\n    **R\\***.\n-   Expect **narrower boxplots** and slimmer residual densities for\n    **GAM (T14)** and **RF (T05)**; KED gains a lot too.\n\n**3) Respect *anisotropy* at night**\n\n-   Rotate to **(s,t)** (along/cross-valley); give **shorter range in\n    t** for variograms.\n-   Even without an explicit anisotropic variogram, feeding **t** as a\n    drift and smoothing features at **R\\*** helps.\n\n**4) Hybridize: regression-kriging**\n\n-   Mean = **GAM (T14)** / **RF (T05)**; residuals = **OK/KED** with\n    short-range, anisotropic structure.\n-   Keeps the physics-savvy mean and mops up local spatial leftovers.\n\n**5) RF hygiene (avoid coordinate memorization)**\n\n-   Drop raw **x,y** or replace with oriented **(s,t)**; rely on\n    **R\\*-smoothed** z/slope/cos(i) + LC and pooling drifts.\n-   This keeps process, reduces overfitting to station layout.\n\n**6) Validation remains scale-aware**\n\n-   Keep **LBO**; try a few **random grid origins** (tiling jitter) and\n    confirm ranks stay stable.\n\n------------------------------------------------------------------------\n\n## Summary\n\n**Daytime temperature** is controlled by **very local** facet and **LC**\neffects layered over a gentle lapse; models that **encode those drivers\nat the right (small) scale**—notably **GAM**, then **RF**—generalize\nacross blocks with low error.\n\n**Pre-dawn temperature** is **anisotropic** with a **short cross-valley\npooling scale**, **slope**, and **LC offsets**; **RF** captures these\nthresholdy interactions best, with **GAM** second. Purely spatial\nsmoothers (OK/IDW/Voronoi) underperform because their **smoothing scale\nand mean process are mismatched**.\n\nBring kriging back into contention by giving it the **right drifts**\n(cos(i), LC, distance-to-axis, hill-block) at **tuned feature scales\n(R\\*)**, and by acknowledging **anisotropy** at night; if you want the\nbest of both worlds, use **regression-kriging** with the learned mean\nfrom **GAM/RF** and an anisotropic residual field.\n\n# Critical review: does the winner take it all?\n\nShort answer: **no**. Even though the baseline shows **GAM (day)** and\n**RF (pre-dawn)** leading on block-CV, a “winner-takes-all” policy is\nbrittle because:\n\n-   **Regime shifts:** Day vs. night, clear vs. cloudy, dry vs. wet\n    canopy, snow, leaf-on/off—each changes the **dominant process** and\n    therefore the **right scale**. Your “winner” can flip.\n-   **Sampling artifacts:** With a different station layout or fewer\n    stations, RF can overfit locations; kriging can swing with a refit\n    variogram; GAM can underfit sharp minima if features aren’t\n    scale-tuned.\n-   **Extrapolation:** RF/GAM extrapolate poorly beyond the **feature\n    envelope** (new hill, bigger lake). Kriging extrapolates linearly in\n    the drift but may **oversmooth**. The best model **by CV** is not\n    always the safest out-of-sample.\n-   **Uncertainty:** Kriging gives a variance; RF/GAM need extra work\n    (quantile/ensembles) for predictive intervals. If you “winner take\n    all,” you may lose **calibrated uncertainty** where you need it\n    most.\n\n# “Information bias” between models\n\nDifferent learners consume different information channels and bring\ntheir own priors. That creates **systematic biases** you can anticipate\nand manage.\n\n| Model | Preferred info | Built-in bias | Typical failure mode |\n|---------------|----------------|----------------|--------------------------|\n| **Voronoi/IDW** | **Distance only** to stations | **Locality bias**; no physics | Edge artefacts; oversmooth across LC boundaries; anisotropy ignored |\n| **OK** | Distance + **stationarity** (residual field) | **Global smoothing scale**; isotropy unless told otherwise | Under-dispersion of extremes; leakage across cross-valley trough |\n| **KED** | OK + **drifts** (z, slope, cos(i), LC) | Mean = whatever drifts encode; **scale of drift matters** | If drift misses physics (pooling), mean is wrong → biased; if drift scale is off → blur |\n| **GAM** | Smooth **functions of features** (z, slope, cos(i), LC) | **Smoothness bias**; picks a scale implied by basis | Rounds off sharp minima/maxima if features aren’t **R\\***-tuned |\n| **RF** | **Nonlinear interactions** in features; can use x,y | **Sample-density & coordinate bias** (memorization) | Patchy “salt-and-pepper”; poor extrapolation; learns layout if x,y left in |\n\n**How to reduce these biases**\n\n-   **RF:** remove raw **x,y** (or replace with oriented **s,t**), feed\n    **R\\***-smoothed z/slope/cos(i) + explicit pooling/LC drifts → makes\n    it learn **process**, not **positions**.\n-   **GAM:** ensure **R\\*** on features so the spline’s smoothness\n    matches the **process scale**.\n-   **KED/OK:** add the **right drifts** (cos(i)@day; distance-to-axis,\n    hill-block, LC\\@night) and consider **anisotropic** variograms or\n    rotated coords.\n\n------------------------------------------------------------------------\n\n# What the current results imply (winner vs. information bias)\n\n**Day (T14)**\n\n-   **GAM wins** because it converts **facet + LC** physics into smooth\n    effects at the **correct small scales**. *Bias watch:* will\n    **under-hit** extremes if features are raw/noisy → fix with **R\\***.\n-   **RF close**; if x,y are present or features are too fine, it may\n    **overfit micro-texture**. *Mitigation:* drop x,y; use **R\\***\n    features.\n-   **KED behind** because the drift/variogram combo **blurs LC edges**;\n    give it **cos(i)+LC** drifts and **R\\*** to recover.\n\n**Pre-dawn (T05)**\n\n-   **RF wins** by capturing **pooling×slope×LC** interactions\n    (thresholdy, anisotropic). *Bias watch:* if station layout changes,\n    performance can drift—guard with **spatial CV** and **no x,y**.\n-   **GAM** close but **smooths** the deepest minima unless features\n    reflect the trough’s **short cross-valley scale** → tune **R\\***.\n-   **KED/OK** underperform without an explicit **pooling drift** and\n    **anisotropy**; that’s *information bias*: they’re limited by what\n    you tell the mean and by isotropic smoothing.\n\n------------------------------------------------------------------------\n\n# Don’t pick one—blend them (practical recipe)\n\n1.  **Regime-aware mean**\n\n-   Use **GAM** for T14, **RF** for T05 **means** (after **R\\*** tuning\n    and with physics features).\n-   Remove **x,y** from RF; use **(s,t)** if you need location signals.\n\n2.  **Residual kriging**\n\n-   Krige residuals from the mean with a **short-range**,\n    **anisotropic** variogram (short across-valley, longer\n    along-valley). This adds local spatial coherence and gives an\n    **uncertainty surface**.\n\n3.  **Stacking with block-CV**\n\n-   Train a simple meta-learner on **out-of-block predictions** (GAM,\n    RF, KED) → get **weights** that vary by time/regime.\n-   Or **per-block weights**: $w_m(b) \\propto 1/\\text{RMSE}_{m,b}$, then\n    blend predictions inside each block and smooth the weights.\n\n4.  **Agreement/diagnostic maps**\n\n-   Export **disagreement maps** (max–min across models) and\n    **which-model-won** maps per block/time. High disagreement = **low\n    trust** areas.\n\n5.  **Uncertainty**\n\n-   Keep **kriging variance** from residual-OK. For RF, add **quantile\n    forest**; for GAM, use **posterior SE** as a rough guide (not\n    predictive). Report a **combined interval** (mean ± kriging SD ⊕\n    model spread).\n\n------------------------------------------------------------------------\n\n# Bottom line\n\n-   The current leaders (GAM\\@day, RF\\@night) **deserve their\n    spots**—they align best with the **dominant processes and scales**.\n-   But each model carries **information bias** (smoothness,\n    stationarity, coordinate focus) that will bite under **layout\n    changes**, **regime shifts**, or **extrapolation**.\n-   Replace “winner takes all” with a **process-aware ensemble**:\n    **R\\***-tuned features, **regime-specific mean** (GAM/RF),\n    **anisotropic residual kriging**, and **CV-weighted stacking**.\n-   Always publish a **skill map**, a **disagreement map**, and\n    **uncertainty**—that’s how you turn a good score into a **reliable\n    microclimate product**.\n\n## I. Scale analysis — L50/L95 & tuned KED drift (R\\*)\n\nThis section adds a four-stage pipeline:\n\n1)  **Scale inference**: global variogram → **L50/L95**\\\n2)  **Scale-matched predictors**: drift from smoothed **E** at radius\n    **R**\\\n3)  **Tune R\\*** with **blocked CV** (U-curve)\\\n4)  **Diagnostics**: full benchmark + **simple error budget**\n\n> **Why:** Matching the **model scale** to the **process scale** reduces\n> scale-mismatch error and makes gains attributable to *scale* rather\n> than algorithm choice.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Scale inference (variogram -> L50/L95) ----------------------------------\n# --- SCALE → TUNING → FEATURES @R* → CV → MAPS → PANELS ----------------------\n# add smoothed predictors to both station sets\nadd_drifts_at_R <- function(stn_sf, E, alt, az, R, lc = NULL, lc_levels = NULL) {\n  # R-geglättete Prädiktor-Raster bauen (E*, slp*, cosi*)\n  dr <- smooth_dem_and_derive(E, alt, az, radius_m = R)\n  XY <- sf::st_coordinates(stn_sf)\n  \n  # Extraktion der bei R geglätteten Prädiktoren\n  stn_sf$z_surf <- as.numeric(terra::extract(dr$Es,   XY)[,1])\n  stn_sf$slp    <- as.numeric(terra::extract(dr$slp,  XY)[,1])\n  stn_sf$cosi   <- as.numeric(terra::extract(dr$cosi, XY)[,1])\n  \n  # Optional: Landnutzung als Faktor (nicht geglättet, aber konsistent gemappt)\n  if (!is.null(lc)) {\n    lc_codes <- as.integer(terra::extract(lc, XY)[,1])\n    if (!is.null(lc_levels)) {\n      lc_codes[is.na(lc_codes)] <- 1L\n      lc_codes <- pmax(1L, pmin(lc_codes, length(lc_levels)))\n      stn_sf$lc <- factor(lc_levels[lc_codes], levels = lc_levels)\n    } else {\n      stn_sf$lc <- factor(lc_codes)\n    }\n  }\n  \n  stn_sf\n}\n\n# ---- SF Variogram Scales (ohne sp::) --------------------------------\ncompute_Ls_from_points <- function(stn_sf, value_col = \"temp\",\n                                   maxdist = NULL, nlag = 18, smooth_k = 3) {\n  stopifnot(inherits(stn_sf, \"sf\"), value_col %in% names(stn_sf))\n  pts <- stn_sf[is.finite(stn_sf[[value_col]]), ]\n  if (is.null(maxdist)) {\n    bb <- sf::st_bbox(pts)\n    dom_diag <- sqrt((bb[\"xmax\"]-bb[\"xmin\"])^2 + (bb[\"ymax\"]-bb[\"ymin\"])^2)\n    maxdist <- dom_diag / 2\n  }\n  form <- stats::as.formula(sprintf(\"%s ~ 1\", value_col))\n  vg  <- gstat::variogram(form, data = pts, cutoff = maxdist, width = maxdist/nlag)\n  \n  if (nrow(vg) >= smooth_k) {\n    vg$gamma <- stats::filter(vg$gamma, rep(1/smooth_k, smooth_k), sides = 2)\n    vg$gamma[!is.finite(vg$gamma)] <- zoo::na.approx(vg$gamma, na.rm = FALSE)\n    vg$gamma <- zoo::na.locf(zoo::na.locf(vg$gamma, fromLast = TRUE))\n  }\n  sill <- max(vg$gamma, na.rm = TRUE)\n  if (!is.finite(sill) || sill <= 0) sill <- stats::median(vg$gamma, na.rm = TRUE)\n  \n  L_at_q <- function(q) {\n    thr <- q * sill\n    i   <- which(vg$gamma >= thr)[1]\n    if (is.na(i)) return(NA_real_)\n    if (i == 1) return(vg$dist[1])\n    d0 <- vg$dist[i-1]; d1 <- vg$dist[i]\n    g0 <- vg$gamma[i-1]; g1 <- vg$gamma[i]\n    if (!is.finite(d0) || !is.finite(d1) || g1 == g0) return(d1)\n    d0 + (thr - g0) * (d1 - d0) / (g1 - g0)\n  }\n  list(vg = vg, sill = sill, L50 = L_at_q(0.5), L95 = L_at_q(0.95), cutoff = maxdist)\n}\n\n\n## 1) Skalen (Variogramm) aus den Stationspunkten\nLs14 <- compute_Ls_from_points(stn_sf_14, value_col = \"temp\")\nLs05 <- compute_Ls_from_points(stn_sf_05, value_col = \"temp\")\n\n## (optional) Variogramm-Plots\np_vg14 <- plot_variogram_with_scales(Ls14$vg, Ls14$L50, Ls14$L95, Ls14$sill,\n                                     title = \"T14 — empirical variogram with L50/L95\")\np_vg05 <- plot_variogram_with_scales(Ls05$vg, Ls05$L50, Ls05$L95, Ls05$sill,\n                                     title = \"T05 — empirical variogram with L50/L95\")\n\n## 2) R* via U-Kurve mit GAM@R (geblockte CV; Blockgröße an globalem block_size)\ntune14 <- tune_Rstar_ucurve(\n  stn_sf = stn_sf_14, E = scen$E, alt = sun14$alt, az = sun14$az,\n  L50 = Ls14$L50, L95 = Ls14$L95, block_fallback = block_size, n_grid = 6\n)\ntune05 <- tune_Rstar_ucurve(\n  stn_sf = stn_sf_05, E = scen$E, alt = sun05$alt, az = sun05$az,\n  L50 = Ls05$L50, L95 = Ls05$L95, block_fallback = block_size, n_grid = 6\n)\n\n\n## (optional) U-Kurven plotten\nprint(plot_ucurve(tune14$grid, tune14$R_star, title = \"T14 — U-curve\"))\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-1.png){width=1350}\n:::\n\n```{.r .cell-code}\nprint(plot_ucurve(tune05$grid, tune05$R_star, title = \"T05 — U-curve\"))\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-2.png){width=1350}\n:::\n\n```{.r .cell-code}\nmessage(sprintf(\"Chosen R* — T14: %d m | blocks ≈ %d m\", tune14$R_star, tune14$block_m))\nmessage(sprintf(\"Chosen R* — T05: %d m | blocks ≈ %d m\", tune05$R_star, tune05$block_m))\n\n## 3) Feature-Raster @R* (E*, slp*, cosi*)\nfr14 <- smooth_dem_and_derive(scen$E, sun14$alt, sun14$az, radius_m = tune14$R_star)\nfr05 <- smooth_dem_and_derive(scen$E, sun05$alt, sun05$az, radius_m = tune05$R_star)\n\n## 4) Stations-Features @R* (inkl. LC, falls vorhanden)\nstn14_R <- add_drifts_at_R(stn_sf_14, scen$E, sun14$alt, sun14$az, tune14$R_star,\n                           lc = scen$lc, lc_levels = scen$lc_levels)\nstn05_R <- add_drifts_at_R(stn_sf_05, scen$E, sun05$alt, sun05$az, tune05$R_star,\n                           lc = scen$lc, lc_levels = scen$lc_levels)\n\n\n## 5) Block-CV gegen E* (nicht gegen rohes E)\nbench14 <- run_lbo_cv(stn14_R, E = fr14$Es, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nbench05 <- run_lbo_cv(stn05_R, E = fr05$Es, block_size = block_size, models = models_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\n## 6) Karten mit feature_rasters = {E*, slp*, cosi*}\nmaps14_tuned <- predict_maps(\n  stn_sf = stn14_R, truth_raster = scen$R14, which_time = \"T14\",\n  scen = scen, models = models_use, lc_levels = scen$lc_levels,\n  feature_rasters = list(E = fr14$Es, slp = fr14$slp, cosi = fr14$cosi)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\nmaps05_tuned <- predict_maps(\n  stn_sf = stn05_R, truth_raster = scen$R05, which_time = \"T05\",\n  scen = scen, models = models_use, lc_levels = scen$lc_levels,\n  feature_rasters = list(E = fr05$Es, slp = fr05$slp, cosi = fr05$cosi)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[inverse distance weighted interpolation]\n[using ordinary kriging]\n[using universal kriging]\n```\n\n\n:::\n\n```{.r .cell-code}\n## 7) Panels (Truth | Predictions | Error/Residuals) – horizontal, gut lesbar\npanel_pages_T14 <- build_panels_truth_preds_errors_paged(\n  maps          = maps14_tuned,      # list with $pred_rasters etc.\n  truth_raster  = scen$R14,\n  cv_tbl        = bench14$cv,\n  which_time    = \"T14\",\n  models_per_page     = 7,            # all models on one page\n  scatter_next_to_truth = TRUE,\n  top_widths           = c(1.1, 0.9), # optional\n  show_second_legend   = FALSE        # keep only one °C legend\n)\n# render the (only) page\npanel_pages_T05 <- build_panels_truth_preds_errors_paged(\n  maps          = maps05_tuned,      # list with $pred_rasters etc.\n  truth_raster  = scen$R05,\n  cv_tbl        = bench05$cv,\n  which_time    = \"T05\",\n  models_per_page     = 7,            # all models on one page\n  scatter_next_to_truth = TRUE,\n  top_widths           = c(1.1, 0.9), # optional\n  show_second_legend   = FALSE        # keep only one °C legend\n)\n# render the (only) page\nprint(panel_pages_T14[[1]])\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-3.png){width=1350}\n:::\n\n```{.r .cell-code}\nprint(panel_pages_T05[[1]])\n```\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-4.png){width=1350}\n:::\n\n```{.r .cell-code}\nprint(bench14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$cv\n# A tibble: 360 × 5\n   model      id   obs  pred block_id\n   <chr>   <int> <dbl> <dbl>    <int>\n 1 Voronoi    20  28.6  28.3        1\n 2 Voronoi    45  28.3  28.4        1\n 3 Voronoi    52  28.4  28.3        1\n 4 IDW        20  28.6  28.4        1\n 5 IDW        45  28.3  28.2        1\n 6 IDW        52  28.4  28.2        1\n 7 OK         20  28.6  28.5        1\n 8 OK         45  28.3  28.4        1\n 9 OK         52  28.4  28.3        1\n10 KED        20  28.6  28.8        1\n# ℹ 350 more rows\n\n$metrics\n# A tibble: 6 × 7\n  model       n  n_ok   MAE  RMSE     Bias     R2\n  <chr>   <int> <int> <dbl> <dbl>    <dbl>  <dbl>\n1 KED        60    58 0.285 0.368  0.0280  0.752 \n2 GAM        60    57 0.301 0.464 -0.0535  0.641 \n3 RF         60    57 0.378 0.495 -0.00124 0.545 \n4 IDW        60    60 0.541 0.711  0.0880  0.0316\n5 OK         60    60 0.548 0.716  0.0493  0.0159\n6 Voronoi    60    60 0.667 0.897  0.205   0.0393\n\n$diag_plot\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-5.png){width=1350}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$blocks_plot\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-6.png){width=1350}\n:::\n\n```{.r .cell-code}\nprint(bench05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$cv\n# A tibble: 360 × 5\n   model      id   obs  pred block_id\n   <chr>   <int> <dbl> <dbl>    <int>\n 1 Voronoi    20  8.60  9.15        1\n 2 Voronoi    45  8.86  9.03        1\n 3 Voronoi    52  9.03  9.15        1\n 4 IDW        20  8.60  8.32        1\n 5 IDW        45  8.86  8.56        1\n 6 IDW        52  9.03  8.80        1\n 7 OK         20  8.60  7.84        1\n 8 OK         45  8.86  8.44        1\n 9 OK         52  9.03  8.77        1\n10 KED        20  8.60 NA           1\n# ℹ 350 more rows\n\n$metrics\n# A tibble: 6 × 7\n  model       n  n_ok    MAE   RMSE    Bias     R2\n  <chr>   <int> <int>  <dbl>  <dbl>   <dbl>  <dbl>\n1 GAM        60    43  0.370  0.462  0.0530  0.881\n2 RF         60    43  0.369  0.561  0.0180  0.834\n3 OK         60    60  0.624  0.933 -0.0671  0.424\n4 IDW        60    60  0.792  1.02  -0.127   0.358\n5 Voronoi    60    60  0.728  1.17  -0.165   0.346\n6 KED        60     0 NA     NA     NA      NA    \n\n$diag_plot\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-7.png){width=1350}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$blocks_plot\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mc_2025_pipemodel_files/figure-html/scale analysis-8.png){width=1350}\n:::\n:::\n\n\n\n\n\n\n### Reading the outputs\n\n-   **Variogram**: dotted sill; dashed **L50/L95** → *scale anchors* for\n    smoothing and block sizes.\\\n-   **U-curve**: **R\\*** at lowest blocked-CV RMSE; include **R = 0** so\n    the tuner can prefer the raw drift.\\\n-   **Benchmark**: compare **OK / KED / GAM / RF / IDW / Voronoi** under\n    the same blocked CV; document block size and R\\*.\\\n-   **Error budget** (illustrative): OK → KED(base) → KED(R\\*) shows\n    gains from drift and from **scale matching**.\n\n> **From concept to practice (pipeline mapping).**\n>\n> 1.  Estimate scales: variogram $\\rightarrow$ $\\sigma_{\\text{proc}}^2$,\n>     $L_{50}$, $L_{95}$.\n> 2.  Couple scales: smooth predictors / choose grids according to\n>     $R_{\\text{micro}}$, $R_{\\text{local}}$.\n> 3.  Tune $R^*$: block‑CV, U‑curve $\\rightarrow$ stable drift radius.\n> 4.  Benchmark methods: compare OK/KED/GAM/RF/Trend/IDW/Voronoi at\n>     $R^*$ (RMSE/MAE/Bias, document block size).\n> 5.  Products: write maps/grids at $R^*$ (and optionally $L_{95}$);\n>     report the error budget.\n\n> **Key takeaway:** *The “smartest” algorithm doesn’t win — the one\n> whose scale matches the process does.*\n\n### I.5 Reading the outputs (tables & plots)\n\nThis section explains **how to interpret** the key tables and figures\nproduced by the pipeline and how to turn them into a **model choice**\nand a **scale statement**.\n\n#### 1) Variogram & scale table (chunk `scale-Ls`)\n\n-   **What you see:** Empirical variogram points/line, horizontal dotted\n    line at the **(structural) sill**, and vertical dashed lines at\n    **L50** and **L95**.\n\n-   **How to read it:**\n\n    -   **Nugget** (near‑zero intercept) ≈ measurement/microscale noise.\n        A large nugget means close points differ substantially; no\n        method can beat this noise floor.\n    -   **Sill** (plateau) ≈ total variance once pairs are effectively\n        uncorrelated.\n    -   **L50 / L95** ≈ pragmatic correlation distances (half vs. \\~all\n        structure spent). They are your **scale anchors** for smoothing\n        radii, neighborhood ranges, and CV block sizes.\n\n-   **Quality checks:**\n\n    -   If no clear plateau: trend/non‑stationarity is likely → consider\n        a drift (elev/sun terms) or a larger domain.\n    -   If L95 is near the domain size: scales are long; block sizes\n        should be generous to avoid leakage.\n    -   If the variogram is noisy at large lags: rely more on **L50**\n        and the U‑curve outcome.\n\n#### 2) U‑curve for tuned drift (chunk `scale-tune`)\n\n-   **What you see:** A line plot of **RMSE vs. smoothing radius R** for\n    KED under **blocked CV**.\n\n-   **Decision rule:** **R\\*** is the radius with the **lowest\n    CV‑RMSE**.\n\n-   **What shapes mean:**\n\n    -   **Left side high** (too small R): drift carries microscale noise\n        → overfitting → higher CV error.\n    -   **Right side high** (too large R): drift is oversmoothed → loses\n        meaningful gradient → bias ↑.\n    -   **Flat bottom/plateau:** a range of R values are equivalent →\n        pick the smallest R on the plateau for parsimony.\n\n-   **Edge cases:** If the minimum sits at the **search boundary**,\n    widen the R grid and re‑run; if still at the boundary, the field may\n    be trend‑dominated or the covariate is weak.\n\n#### 3) LBO‑CV metrics table (`res$metrics`)\n\nFor each model (Voronoi, IDW, OK, KED, GAM, RF) we report:\n\n-   **RMSE** (primary): square‑error penalty; most sensitive to\n    outliers. **Use this to rank models.**\n-   **MAE**: median‑like robustness; a useful tie‑breaker alongside\n    RMSE.\n-   **Bias** (mean error): systematic over/under‑prediction; prefer\n    \\|Bias\\| close to 0.\n-   **R²**: variance explained in held‑out blocks; interpret cautiously\n    under spatial CV.\n-   **n**: number of held‑out predictions contributing.\n\n**Choosing a winner:**\n\n1.  Rank by **lowest RMSE** under the **tuned** configuration.\n2.  If RMSEs are within \\~5–10%: prefer the model with **lower MAE**,\n    **lower \\|Bias\\|**, and **more stable block‑wise errors** (see next\n    point).\n3.  If KED (R\\*) ≈ OK: the drift adds little; the covariate is weak or\n    the process is long‑range. If GAM/RF wins, the relationship is\n    **nonlinear** or **interaction‑rich**.\n\n#### 4) Block‑wise diagnostics\n\n-   **Block error boxes/scatter:** Look for **narrow distributions**\n    (stable across space). Large spread or outliers indicate\n    location‑dependent performance.\n-   **Stability index (optional):**\n    `CV_rmse = sd(RMSE_block) / mean(RMSE_block)`. Values \\< 0.25 are\n    typically stable; \\> 0.4 suggests uneven performance.\n-   **Obs vs Pred scatter:** Slope \\~1 and tight cloud = good\n    calibration; bowed patterns imply bias or missing drift terms.\n\n#### 5) Error budget table (`make_simple_error_budget`)\n\nThree rows show how error decreases as structure is added and matched:\n\n-   **Baseline (OK):** no drift; sets a structure‑free reference.\n-   **Add drift (KED base):** uses raw covariate; improvement here\n    quantifies **signal in the covariate**.\n-   **Scale‑match drift (KED R\\*):** covariate smoothed at **R\\***;\n    additional gain isolates **scale alignment**. The `Gain_vs_prev`\n    column is the **incremental improvement** at each step.\n\n> If **KED base** \\~ **KED R\\***, scale matching adds little (either the\n> raw drift is already at a compatible scale, or the field is\n> insensitive to R). If **OK** \\> **KED base**, the covariate may inject\n> noise or the drift term is mis‑specified.\n\n### I.6 Deciding on the *best* model (and documenting the scale)\n\nUse this practical, auditable rule set:\n\n1.  **Primary criterion:** Lowest **CV‑RMSE** under blocked CV.\n2.  **Tie‑breakers:** Lower **MAE**, smaller **\\|Bias\\|**, and better\n    **block‑stability**.\n3.  **Parsimony:** If multiple models tie, choose the **simplest**\n    (OK/KED \\< GAM \\< RF).\n4.  **Scale sanity check:** Report **L50/L95** and verify that **R\\***\n    lies roughly in \\[L50, 1.5·L95\\]. If not, discuss why (e.g., strong\n    trend, weak covariate, anisotropy).\n5.  **Reproducibility:** Record the **block size**, **R grid**, winning\n    **R\\***, and the full metrics table.\n\n### I.7 Typical patterns & what they imply\n\n-   **High nugget, short L50:** Expect modest absolute accuracy; prefer\n    **coarser R** and conservative models. IDW/OK with tight\n    neighborhoods can perform on par with KED.\n-   **Long L95, clear sill:** Favor larger neighborhoods and smoother\n    drifts; **KED (R\\*)** often dominates.\n-   **GAM/RF \\> KED:** Nonlinear covariate effects or interactions\n    (e.g., slope×aspect). Still align covariates to **R\\*** to avoid\n    noise chasing.\n-   **OK \\~ KED:** Elevation (or chosen drift) is weak for this\n    synthetic setup; consider enriching covariates (slope/aspect/TRI) at\n    matched scales.\n\n### I.8 Checklist before you trust the numbers\n\n-   Block size reflects **correlation scale** (≈ L95).\n-   U‑curve scanned a **broad enough R** range; minimum not at boundary.\n-   **R\\*** reported along with **L50/L95**.\n-   Winner chosen by **blocked CV** (not random folds).\n-   Bias near zero; residuals pattern‑free in space.\n-   Figures/tables archived for reproducibility.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ====================== EXPORT: Plots, Tabellen, Raster ======================\n# Ordnerstruktur\nout_dir <- \"exports\"\nfig_dir <- file.path(out_dir, \"figs\")\ntab_dir <- file.path(out_dir, \"tables\")\nras_dir <- file.path(out_dir, \"rasters\")\ndat_dir <- file.path(out_dir, \"data\")\ndir.create(out_dir, showWarnings = FALSE)\nfor (d in c(fig_dir, tab_dir, ras_dir, dat_dir)) dir.create(d, showWarnings = FALSE)\n\n# Helfer\nsafe_save_plot <- function(p, file, w = 9, h = 6, dpi = 300) {\n  if (!is.null(p) && inherits(p, c(\"gg\",\"ggplot\",\"patchwork\"))) {\n    try(ggplot2::ggsave(filename = file, plot = p, width = w, height = h,\n                        dpi = dpi, bg = \"white\"), silent = TRUE)\n  }\n}\nsafe_write_csv <- function(x, file) {\n  if (!is.null(x)) try(utils::write.csv(x, file, row.names = FALSE), silent = TRUE)\n}\nsafe_save_kable <- function(tab, file_html, self_contained = TRUE) {\n  # normalize and create the parent directory if needed\n  out_path <- normalizePath(file_html, winslash = \"/\", mustWork = FALSE)\n  out_dir  <- dirname(out_path)\n  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)\n\n  # try saving via kableExtra; on failure, write the raw HTML as a fallback\n  tryCatch(\n    {\n      kableExtra::save_kable(tab, out_path, self_contained = self_contained)\n      message(\"Saved table: \", out_path)\n    },\n    error = function(e) {\n      warning(\"save_kable failed (\", conditionMessage(e), \"). Writing raw HTML fallback.\")\n      cat(as.character(tab), file = out_path)\n      message(\"Fallback table written: \", out_path)\n    }\n  )\n\n  invisible(out_path)\n}\n\n\n\n\n# ====================== EXPORT: Plots, Tabellen, Raster ======================\n# Ordnerstruktur\n\nout_dir <- \"block4_5/exports\"\nfig_dir <- file.path(out_dir, \"figs\")\ntab_dir <- file.path(out_dir, \"tables\")\nras_dir <- file.path(out_dir, \"rasters\")\ndat_dir <- file.path(out_dir, \"data\")\ndir.create(out_dir, showWarnings = FALSE)\nfor (d in c(fig_dir, tab_dir, ras_dir, dat_dir)) dir.create(d, showWarnings = FALSE)\n\n# Helfer\nsafe_save_plot <- function(p, file, w = 9, h = 6, dpi = 300) {\n  if (!is.null(p) && inherits(p, c(\"gg\",\"ggplot\",\"patchwork\"))) {\n    try(ggplot2::ggsave(filename = file, plot = p, width = w, height = h,\n                        dpi = dpi, bg = \"white\"), silent = TRUE)\n  }\n}\nsafe_write_csv <- function(x, file) {\n  if (!is.null(x)) try(utils::write.csv(x, file, row.names = FALSE), silent = TRUE)\n}\nsafe_save_kable <- function(df, file_html, caption = NULL) {\n  if (!is.null(df) && requireNamespace(\"kableExtra\", quietly = TRUE)) {\n    tab <- knitr::kable(df, digits = 3, caption = caption, format = \"html\")\n    kableExtra::save_kable(tab, file_html, self_contained = TRUE)\n  }\n}\n\n# ---------- Plots sammeln & speichern ----------\n# ---- Plots sicher speichern (fixte Referenzen) ----\nplots <- list(\n  # Panels (tuned)\n  \"T14_panel_tuned.png\"  = if (exists(\"panel14_tuned\")) panel14_tuned else NULL,\n  \"T05_panel_tuned.png\"  = if (exists(\"panel05_tuned\")) panel05_tuned else NULL,\n  \n  # LBO-CV Übersicht (BLOCKS + DIAG)\n  \"T14_blocks.png\"       = if (exists(\"out14\")) out14$res$blocks_plot else NULL,\n  \"T14_diag.png\"         = if (exists(\"out14\")) out14$res$diag_plot   else NULL,\n  \"T05_blocks.png\"       = if (exists(\"out05\")) out05$res$blocks_plot else NULL,\n  \"T05_diag.png\"         = if (exists(\"out05\")) out05$res$diag_plot   else NULL,\n  \n  # Truth/Pred (baseline)\n  \"T14_truth.png\"        = if (exists(\"out14\")) out14$maps$p_truth else NULL,\n  \"T14_pred.png\"         = if (exists(\"out14\")) out14$maps$p_pred  else NULL,\n  \"T05_truth.png\"        = if (exists(\"out05\")) out05$maps$p_truth else NULL,\n  \"T05_pred.png\"         = if (exists(\"out05\")) out05$maps$p_pred  else NULL,\n  \n  # Truth/Pred (tuned @ R*)\n  \"T14_truth_TUNED.png\"  = if (exists(\"maps14_tuned\")) maps14_tuned$p_truth else NULL,\n  \"T14_pred_TUNED.png\"   = if (exists(\"maps14_tuned\")) maps14_tuned$p_pred  else NULL,\n  \"T05_truth_TUNED.png\"  = if (exists(\"maps05_tuned\")) maps05_tuned$p_truth else NULL,\n  \"T05_pred_TUNED.png\"   = if (exists(\"maps05_tuned\")) maps05_tuned$p_pred  else NULL,\n  \n  # Boxplots, Scatter, Density (aus CV)\n  \"T14_block_box.png\"    = if (exists(\"p_block_box14\"))  p_block_box14  else NULL,\n  \"T14_abserr_box.png\"   = if (exists(\"p_abserr_box14\")) p_abserr_box14 else NULL,\n  \"T05_block_box.png\"    = if (exists(\"p_block_box05\"))  p_block_box05  else NULL,\n  \"T05_abserr_box.png\"   = if (exists(\"p_abserr_box05\")) p_abserr_box05 else NULL,\n  \"T14_obs_pred.png\"     = if (exists(\"p_scatter14\")) p_scatter14 else NULL,\n  \"T05_obs_pred.png\"     = if (exists(\"p_scatter05\")) p_scatter05 else NULL,\n  \"T14_resid_density.png\"= if (exists(\"p_dens14\"))    p_dens14    else NULL,\n  \"T05_resid_density.png\"= if (exists(\"p_dens05\"))    p_dens05    else NULL,\n  \n  # Variogramme & U-Kurven\n  \"T14_variogram.png\"    = if (exists(\"p_vg14\")) p_vg14 else NULL,\n  \"T05_variogram.png\"    = if (exists(\"p_vg05\")) p_vg05 else NULL,\n  \"T14_ucurve.png\"       = if (exists(\"p_uc14\")) p_uc14 else NULL,\n  \"T05_ucurve.png\"       = if (exists(\"p_uc05\")) p_uc05 else NULL,\n  \n  # Landuse / Terrain-Overview aus Teil 1\n  \"landcover_vertical.png\" = if (exists(\"p_landcover_vert\")) p_landcover_vert else NULL,\n  \"overview_2x2.png\"       = if (exists(\"p_overview2x2\"))    p_overview2x2    else NULL\n)\n\nfor (nm in names(plots)) safe_save_plot(plots[[nm]], file.path(fig_dir, nm), w = 9, h = 6, dpi = 300)\n\n# ---------- Tabellen & Daten exportieren ----------\n# CV-Punktvorhersagen\nif (exists(\"out14\")) safe_write_csv(out14$res$cv, file.path(dat_dir, \"cv_points_T14.csv\"))\nif (exists(\"out05\")) safe_write_csv(out05$res$cv, file.path(dat_dir, \"cv_points_T05.csv\"))\n\n# Grid-Vorhersagen (Truth/Pred) – “pred_df” der Map-Objekte\nif (exists(\"out14\")) safe_write_csv(out14$maps$pred_df, file.path(dat_dir, \"grid_pred_T14.csv\"))\nif (exists(\"out05\")) safe_write_csv(out05$maps$pred_df, file.path(dat_dir, \"grid_pred_T05.csv\"))\nif (exists(\"maps14_tuned\")) safe_write_csv(maps14_tuned$pred_df, file.path(dat_dir, \"grid_pred_T14_TUNED.csv\"))\nif (exists(\"maps05_tuned\")) safe_write_csv(maps05_tuned$pred_df, file.path(dat_dir, \"grid_pred_T05_TUNED.csv\"))\n\n# Metriken\nif (exists(\"out14\")) {\n  safe_write_csv(out14$res$metrics, file.path(tab_dir, \"metrics_T14_base.csv\"))\n  safe_save_kable(out14$res$metrics, file.path(tab_dir, \"metrics_T14_base.html\"), \"LBO-CV metrics — T14\")\n}\nif (exists(\"out05\")) {\n  safe_write_csv(out05$res$metrics, file.path(tab_dir, \"metrics_T05_base.csv\"))\n  safe_save_kable(out05$res$metrics, file.path(tab_dir, \"metrics_T05_base.html\"), \"LBO-CV metrics — T05\")\n}\nif (exists(\"bench14\")) {\n  safe_write_csv(bench14$metrics, file.path(tab_dir, \"metrics_T14_tuned.csv\"))\n  safe_save_kable(bench14$metrics, file.path(tab_dir, \"metrics_T14_tuned.html\"), \"Metrics — tuned @ R* (T14)\")\n}\nif (exists(\"bench05\")) {\n  safe_write_csv(bench05$metrics, file.path(tab_dir, \"metrics_T05_tuned.csv\"))\n  safe_save_kable(bench05$metrics, file.path(tab_dir, \"metrics_T05_tuned.html\"), \"Metrics — tuned @ R* (T05)\")\n}\n\n# Skalen & R*\nif (exists(\"tune14\") && exists(\"Ls14\")) {\n  safe_write_csv(tune14$table, file.path(tab_dir, \"Ucurve_T14.csv\"))\n  safe_write_csv(data.frame(L50 = Ls14$L50, L95 = Ls14$L95, R_star = tune14$R_star),\n                 file.path(tab_dir, \"scales_T14.csv\"))\n}\nif (exists(\"tune05\") && exists(\"Ls05\")) {\n  safe_write_csv(tune05$table, file.path(tab_dir, \"Ucurve_T05.csv\"))\n  safe_write_csv(data.frame(L50 = Ls05$L50, L95 = Ls05$L95, R_star = tune05$R_star),\n                 file.path(tab_dir, \"scales_T05.csv\"))\n}\n\n# Optional: Error-Budget (falls berechnet)\nif (exists(\"eb14\")) safe_write_csv(eb14, file.path(tab_dir, \"error_budget_T14.csv\"))\nif (exists(\"eb05\")) safe_write_csv(eb05, file.path(tab_dir, \"error_budget_T05.csv\"))\n\n# ---------- Raster exportieren ----------\nif (exists(\"scen\")) {\n  try(terra::writeRaster(scen$E,   file.path(ras_dir, \"E_dem.tif\"),   overwrite = TRUE), silent = TRUE)\n  try(terra::writeRaster(scen$R14, file.path(ras_dir, \"R14_truth.tif\"), overwrite = TRUE), silent = TRUE)\n  try(terra::writeRaster(scen$R05, file.path(ras_dir, \"R05_truth.tif\"), overwrite = TRUE), silent = TRUE)\n  if (\"lc\" %in% names(scen)) try(terra::writeRaster(scen$lc, file.path(ras_dir, \"landcover.tif\"),\n                                                    overwrite = TRUE), silent = TRUE)\n}\nif (exists(\"bench14\") && \"E_star\" %in% names(bench14))\n  try(terra::writeRaster(bench14$E_star, file.path(ras_dir, \"E_star_T14.tif\"), overwrite = TRUE), silent = TRUE)\nif (exists(\"bench05\") && \"E_star\" %in% names(bench05))\n  try(terra::writeRaster(bench05$E_star, file.path(ras_dir, \"E_star_T05.tif\"), overwrite = TRUE), silent = TRUE)\n\n# ---------- Sessioninfo als Referenz ----------\ntry(saveRDS(sessionInfo(), file.path(out_dir, \"sessionInfo.rds\")), silent = TRUE)\n\nmessage(\"✔ Export fertig. Siehe Ordner: \", normalizePath(out_dir))\n# ========================================================================\n```\n:::\n",
    "supporting": [
      "mc_2025_pipemodel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}