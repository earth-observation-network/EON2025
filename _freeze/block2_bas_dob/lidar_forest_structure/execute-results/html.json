{
  "hash": "8a3f3cf1711a781ae1ba7fd682a074f7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Processing of 3D Lidar data to assess forest structure\"\nauthor: \"Prakash Basnet and Svenja Dobelmann\"\n---\n\n\ncheck out the manual of the lidR package: https://r-lidar.github.io/lidRbook/ \n\n## 0. Setup\n\n### Install and load required libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## install libraries\n# install.packges(\"lidR\")\n# install.packages(\"terra\")\n# install.packages(\"sf\")\n# install.packages(\"rTwig\")\n# install.packages('lidRviewer', repos = c('https://r-lidar.r-universe.dev'))\n\n\nlibrary(lidR)\nlibrary(terra)\nlibrary(sf)\nlibrary(lidRviewer)\nlibrary(dplyr)\nlibrary(rTwig)\n```\n:::\n\n\n\n### download the data\ndownload lidar point cloud and ground truth data (BI) from owncloud. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data access\nurl_las <- \"https://cloud.hawk.de/index.php/s/pB4RRmLb4Xxy4Qj/download\"\ndownload.file(url_las, destfile = \"uls_goewa.laz\", mode = \"wb\")\n\nurl_bi <- \"https://cloud.hawk.de/index.php/s/5npprfZYLjg5ip5/download\"\ndownload.file(url_bi, destfile = \"trees_bi.gpkg\", mode = \"wb\")\n```\n:::\n\n\n\n### import the data \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlas <- readLAS(\"uls_goewa.laz\")\ntrees_bi <- st_read(\"trees_bi.gpkg\")\n```\n:::\n\n\nletÂ´s inspect the data. \n1) whats the point density of the lidar data? \n2) whats the total number of points and pulses and what is the difference between the two? \n3) is there any classification in the point cloud? \n4) how many trees were measured in the BI? \n5) which tree species are present in the plot? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(las)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass        : LAS (v1.2 format 3)\nmemory       : 313.2 Mb \nextent       : 572445.4, 572496.1, 5709020, 5709071 (xmin, xmax, ymin, ymax)\ncoord. ref.  : WGS 84 / UTM zone 32N \narea         : 2602 mÂ²\npoints       : 5.13 million points\ntype         : terrestrial\ndensity      : 1971.94 points/mÂ²\ndensity      : 1660.17 pulses/mÂ²\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(las)\nprint(trees_bi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 69 features and 17 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 572446.5 ymin: 5709021 xmax: 572495.8 ymax: 5709069\nProjected CRS: WGS 84 / UTM zone 32N\nFirst 10 features:\n   IDPlots          Name Plots.Bem ID      X_m     Y_m    Z_m Species Spec_txt\n1        1 GoeWald Fla 1      <NA>  1 572468.6 5709043 -0.448      22       Bu\n2        1 GoeWald Fla 1      <NA>  2 572467.4 5709044 -0.466      22       Bu\n3        1 GoeWald Fla 1      <NA>  3 572462.7 5709041 -0.443      22       Bu\n4        1 GoeWald Fla 1      <NA>  4 572459.8 5709039 -0.657      22       Bu\n5        1 GoeWald Fla 1      <NA>  5 572455.0 5709045 -0.971      22       Bu\n6        1 GoeWald Fla 1      <NA>  6 572455.1 5709048 -0.978      22       Bu\n7        1 GoeWald Fla 1      <NA>  7 572459.6 5709050 -0.723      22       Bu\n8        1 GoeWald Fla 1      <NA>  8 572460.5 5709052 -0.920      22       Bu\n9        1 GoeWald Fla 1      <NA>  9 572463.9 5709053 -0.747      22       Bu\n10       1 GoeWald Fla 1      <NA> 10 572468.1 5709048 -0.619      22       Bu\n   DBH_mm Vit Bruch                Schirm Schiefer.B Trees.Bem   x_lok  y_lok\n1     354 leb  nein geringe ï¿½berschirmung       Nein      <NA>  -2.197 -2.543\n2     345 leb  nein geringe ï¿½berschirmung       Nein      <NA>  -3.371 -1.518\n3     518 leb  nein geringe ï¿½berschirmung       Nein      <NA>  -8.087 -3.932\n4     373 leb  nein    Hohe ï¿½berschirmung       Nein      <NA> -11.067 -6.176\n5     350 leb  nein    Hohe ï¿½berschirmung       Nein      <NA> -15.776 -0.631\n6     388 leb  nein geringe ï¿½berschirmung       Nein      <NA> -15.576  2.703\n7     264 tot    ja                  <NA>       Nein      <NA> -11.070  4.367\n8     404 leb  nein geringe ï¿½berschirmung       Nein      <NA> -10.178  6.296\n9     464 leb  nein geringe ï¿½berschirmung       Nein      <NA>  -6.741  7.432\n10    291 leb    ja  Komplett ï¿½berschirmt       Nein      <NA>  -2.589  2.832\n                       geom\n1  POINT (572468.6 5709043)\n2  POINT (572467.4 5709044)\n3  POINT (572462.7 5709041)\n4  POINT (572459.8 5709039)\n5    POINT (572455 5709045)\n6  POINT (572455.1 5709048)\n7  POINT (572459.6 5709050)\n8  POINT (572460.5 5709052)\n9  POINT (572463.9 5709053)\n10 POINT (572468.1 5709048)\n```\n\n\n:::\n:::\n\n\n\n## 1. Calculating Terrain Models \nNext we are calculating terrain models, using triangulation (TIN = Triangulated Irregular Network). Since the data is already ground classified we can skip the classification step. The DEM is using the ground return points to interpolate the surface. In contrast, the digital surface model is using the highest lidar returns to represent the top of any object above the ground. Subtracting the two gives us the canopy height. \n\ncheck out the documentation of the rasterize_terrain algorithm. Try out different interpolation algorithms and different resolutions. Compare the results visually. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem <- rasterize_terrain(las, res = 0.5, algorithm = tin())\ndsm <- rasterize_canopy(las, res = 0.5, algorithm = dsmtin(max_edge = 8))\nchm <- dsm - dem\nchm <- terra::focal(chm, w = 3, fun = mean, na.rm = TRUE) # smoothing results \n\npar(mfrow = c(1,3))\nplot(dem, main = \"digital elevation model\")\nplot(dsm, main = \"digital surface model\")\nplot(chm, main = \"canopy heigt model\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n\n```{.r .cell-code}\n#writeRaster(dem, \"./data/output/dem.tif\", overwrite=TRUE)\n#writeRaster(dsm, \"./data/output/dsm.tif\", overwrite=TRUE)\n#writeRaster(chm, \"./data/output/chm.tif\", overwrite=TRUE)\n```\n:::\n\n\n\n## 2. Individual Tree Detection\nIndividual Tree Detection (ITD) is the process of spatially locating trees (f.i to extract height information). Tree tops can be detected by applying a Local Maximum Filter (LMF) on the loaded data set. The number of detected trees is correlated to the window size (ws) argument. Small windows sizes usually gives more trees, while large windows size generally miss smaller trees that are â€œhiddenâ€ by big trees that contain the highest points in the neighbourhood. We will use the Tree detection function with variable window size. Any points below 2 m will equate to a window size of 3 m, while points above 20 meters equate to a window size of 5 m. Anything between 2 and 20 meter will have a non-linear relationship.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function for Local Maximum Filter with variable windows size\n\nf <- function(x) {\n  y <- 2.6 * (-(exp(-0.08*(x-2)) - 1)) + 3 \n  # from https://r-lidar.github.io/lidRbook/itd.html\n  y[x < 2] <- 3\n  y[x > 20] <- 5\n  return(y)\n}\n\nheights <- seq(-5,35,0.5)\nws <- f(heights)\n\nplot(heights, ws, type = \"l\",  ylim = c(0,5))\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-6-1.png){width=480}\n:::\n:::\n\n\n  \n  LetÂ´s run the tree detection algorithm using the user-defined ws function and the CHM created beforehand. Compare the results with the ground truth BI data. \n- How many of the trees could be detected in the lidar data?  \n- what could be the reasons for that? \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ttops <- locate_trees(las, lmf(f)) # only run this if you have a fast computer! \nttops <- locate_trees(chm, lmf(f)) \n\n# plot results \nplot(chm, col = height.colors(50))\nplot(sf::st_geometry(trees_bi), add = TRUE, pch = 2, col =\"blue\")\nplot(sf::st_geometry(ttops), add = TRUE, pch = 3, col = \"black\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-7-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# 3D plot\nlas_norm <- normalize_height(las, knnidw()) # normalize point cloud for this vizualisation \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInverse distance weighting: [==================================----------------] 68% (6 threads)\nInverse distance weighting: [==================================----------------] 69% (6 threads)\nInverse distance weighting: [===================================---------------] 70% (6 threads)\nInverse distance weighting: [===================================---------------] 71% (6 threads)\nInverse distance weighting: [====================================--------------] 72% (6 threads)\nInverse distance weighting: [====================================--------------] 73% (6 threads)\nInverse distance weighting: [=====================================-------------] 74% (6 threads)\nInverse distance weighting: [=====================================-------------] 75% (6 threads)\nInverse distance weighting: [======================================------------] 76% (6 threads)\nInverse distance weighting: [======================================------------] 77% (6 threads)\nInverse distance weighting: [=======================================-----------] 78% (6 threads)\nInverse distance weighting: [=======================================-----------] 79% (6 threads)\nInverse distance weighting: [========================================----------] 80% (6 threads)\nInverse distance weighting: [========================================----------] 81% (6 threads)\nInverse distance weighting: [=========================================---------] 82% (6 threads)\nInverse distance weighting: [=========================================---------] 83% (6 threads)\nInverse distance weighting: [==========================================--------] 84% (6 threads)\nInverse distance weighting: [==========================================--------] 85% (6 threads)\nInverse distance weighting: [===========================================-------] 86% (6 threads)\nInverse distance weighting: [===========================================-------] 87% (6 threads)\nInverse distance weighting: [============================================------] 88% (6 threads)\nInverse distance weighting: [============================================------] 89% (6 threads)\nInverse distance weighting: [=============================================-----] 90% (6 threads)\nInverse distance weighting: [=============================================-----] 91% (6 threads)\nInverse distance weighting: [==============================================----] 92% (6 threads)\nInverse distance weighting: [==============================================----] 93% (6 threads)\nInverse distance weighting: [===============================================---] 94% (6 threads)\nInverse distance weighting: [===============================================---] 95% (6 threads)\nInverse distance weighting: [================================================--] 96% (6 threads)\nInverse distance weighting: [================================================--] 97% (6 threads)\nInverse distance weighting: [=================================================-] 98% (6 threads)\nInverse distance weighting: [=================================================-] 99% (6 threads)\nInverse distance weighting: [==================================================] 100% (6 threads)\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- plot(las_norm, bg = \"white\", size = 4)\nadd_treetops3d(x, ttops)\n\n#writeVector(vect(ttops), \"./data/output/ttops_chm_.gpkg\", overwrite=TRUE)\n```\n:::\n\n\n\n## 3. Individual Tree Segmentation\nIndividual Tree Segmentation (ITS) is the process of individually delineating detected trees. Even when the algorithm is raster-based (which is the case of dalponte2016()), lidR segments the point cloud and assigns an ID to each point by inserting a new attribute named treeID in the LAS object. This means that every point is associated with a particular tree. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalgo <- dalponte2016(chm, ttops)\nlas_seg <- segment_trees(las_norm, algo) # segment point cloud\nx <- plot(las_seg, bg = \"white\", size = 4, color = \"treeID\") # visualize trees\nadd_treetops3d(x, ttops)\n```\n:::\n\n\n\n## 4. Deriving Metrics using the area-based approach \nthe Area-Based Approach (ABA) allows the creation of wall-to-wall predictions of forest inventory attributes (e.g. basal area or total volume per hectare) by linking ALS variables with field measured references.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_metr <- pixel_metrics(las, res = 0.5, func = .stdmetrics)\nplot(r_metr)\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n## 5.Forest structural complexity \n(Fractal complexity analysis/ voxel-based box-count dimension or box dimension (Db) method)  \nThe box dimension quantifies structural complexity of point clouds using a fractal box-counting approach.   \nIt is defined as the slope of the regression between log box (voxel) count and log inverse box (voxel) size, \nwith higher RÂ² values indicating stronger self-similarity.\nReliable estimates require high-resolution (â‰¤1 cm) point clouds with minimal occlusion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read data, check and pre-process with lidR\n#data <- readLAS(\"uls_goewa.laz\")\nprint(las)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass        : LAS (v1.2 format 3)\nmemory       : 313.2 Mb \nextent       : 572445.4, 572496.1, 5709020, 5709071 (xmin, xmax, ymin, ymax)\ncoord. ref.  : WGS 84 / UTM zone 32N \narea         : 2602 mÂ²\npoints       : 5.13 million points\ntype         : terrestrial\ndensity      : 1971.94 points/mÂ²\ndensity      : 1660.17 pulses/mÂ²\n```\n\n\n:::\n\n```{.r .cell-code}\nlas_check(las) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Checking the data\n  - Checking coordinates...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates type...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates range...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates quantization...\u001b[0;32m âœ“\u001b[0m\n  - Checking attributes type...\u001b[0;32m âœ“\u001b[0m\n  - Checking ReturnNumber validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking NumberOfReturns validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking ReturnNumber vs. NumberOfReturns...\u001b[0;32m âœ“\u001b[0m\n  - Checking RGB validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking absence of NAs...\u001b[0;32m âœ“\u001b[0m\n  - Checking duplicated points...\u001b[0;32m âœ“\u001b[0m\n  - Checking degenerated ground points...\u001b[0;32m âœ“\u001b[0m\n  - Checking attribute population...\n \u001b[0;32m   ðŸ›ˆ 'PointSourceID' attribute is not populated\u001b[0m\n \u001b[0;32m   ðŸ›ˆ 'ScanDirectionFlag' attribute is not populated\u001b[0m\n \u001b[0;32m   ðŸ›ˆ 'EdgeOfFlightline' attribute is not populated\u001b[0m\n  - Checking gpstime incoherances\u001b[0;32m âœ“\u001b[0m\n  - Checking flag attributes...\u001b[0;32m âœ“\u001b[0m\n  - Checking user data attribute...\u001b[0;32m âœ“\u001b[0m\n Checking the header\n  - Checking header completeness...\u001b[0;32m âœ“\u001b[0m\n  - Checking scale factor validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking point data format ID validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking extra bytes attributes validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking the bounding box validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinate reference system...\u001b[0;32m âœ“\u001b[0m\n Checking header vs data adequacy\n  - Checking attributes vs. point format...\u001b[0;32m âœ“\u001b[0m\n  - Checking header bbox vs. actual content...\u001b[0;32m âœ“\u001b[0m\n  - Checking header number of points vs. actual content...\u001b[0;32m âœ“\u001b[0m\n  - Checking header return number vs. actual content...\u001b[0;32m âœ“\u001b[0m\n Checking coordinate reference system...\n  - Checking if the CRS was understood by R...\u001b[0;32m âœ“\u001b[0m\n Checking preprocessing already done \n  - Checking ground classification...\u001b[0;32m yes\u001b[0m\n  - Checking normalization...\u001b[0;31m no\u001b[0m\n  - Checking negative outliers...\u001b[0;32m âœ“\u001b[0m\n  - Checking flightline classification...\u001b[0;31m no\u001b[0m\n Checking compression\n  - Checking attribute compression...\n   -  ScanDirectionFlag is compressed\n   -  EdgeOfFlightline is compressed\n   -  Synthetic_flag is compressed\n   -  Keypoint_flag is compressed\n   -  Withheld_flag is compressed\n   -  UserData is compressed\n   -  PointSourceID is compressed\n```\n\n\n:::\n\n```{.r .cell-code}\nlas_norm <- normalize_height(las = las, \n                        algorithm = tin(), \n                        use_class = 2)\n\nlas_check(las_norm) # check negative outliers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Checking the data\n  - Checking coordinates...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates type...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates range...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinates quantization...\u001b[0;32m âœ“\u001b[0m\n  - Checking attributes type...\u001b[0;32m âœ“\u001b[0m\n  - Checking ReturnNumber validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking NumberOfReturns validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking ReturnNumber vs. NumberOfReturns...\u001b[0;32m âœ“\u001b[0m\n  - Checking RGB validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking absence of NAs...\u001b[0;32m âœ“\u001b[0m\n  - Checking duplicated points...\u001b[0;32m âœ“\u001b[0m\n  - Checking degenerated ground points...\u001b[0;32m âœ“\u001b[0m\n  - Checking attribute population...\n \u001b[0;32m   ðŸ›ˆ 'PointSourceID' attribute is not populated\u001b[0m\n \u001b[0;32m   ðŸ›ˆ 'ScanDirectionFlag' attribute is not populated\u001b[0m\n \u001b[0;32m   ðŸ›ˆ 'EdgeOfFlightline' attribute is not populated\u001b[0m\n  - Checking gpstime incoherances\u001b[0;32m âœ“\u001b[0m\n  - Checking flag attributes...\u001b[0;32m âœ“\u001b[0m\n  - Checking user data attribute...\u001b[0;32m âœ“\u001b[0m\n Checking the header\n  - Checking header completeness...\u001b[0;32m âœ“\u001b[0m\n  - Checking scale factor validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking point data format ID validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking extra bytes attributes validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking the bounding box validity...\u001b[0;32m âœ“\u001b[0m\n  - Checking coordinate reference system...\u001b[0;32m âœ“\u001b[0m\n Checking header vs data adequacy\n  - Checking attributes vs. point format...\u001b[0;32m âœ“\u001b[0m\n  - Checking header bbox vs. actual content...\u001b[0;32m âœ“\u001b[0m\n  - Checking header number of points vs. actual content...\u001b[0;32m âœ“\u001b[0m\n  - Checking header return number vs. actual content...\u001b[0;32m âœ“\u001b[0m\n Checking coordinate reference system...\n  - Checking if the CRS was understood by R...\u001b[0;32m âœ“\u001b[0m\n Checking preprocessing already done \n  - Checking ground classification...\u001b[0;32m yes\u001b[0m\n  - Checking normalization...\u001b[0;32m yes\u001b[0m\n  - Checking negative outliers...\n \u001b[1;33m   âš  51 points below 0\u001b[0m\n  - Checking flightline classification...\u001b[0;31m no\u001b[0m\n Checking compression\n  - Checking attribute compression...\n   -  ScanDirectionFlag is compressed\n   -  EdgeOfFlightline is compressed\n   -  Synthetic_flag is compressed\n   -  Keypoint_flag is compressed\n   -  Withheld_flag is compressed\n   -  UserData is compressed\n   -  PointSourceID is compressed\n```\n\n\n:::\n\n```{.r .cell-code}\nview(las_norm)\n            #Rotate with left mouse button\n            #Zoom with mouse wheel\n            #Pan with right mouse button\n            #Keyboard r or g or b to color with RGB\n            #Keyboard z to color with Z\n            #Keyboard i to color with Intensity\n            #Keyboard c to color with Classification\n            #Keyboard + or - to change the point size\n            #Keyboard l to enable/disable eyes-dome lightning\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlas_norm@data[Z<0, 1:3] # Here options are either remove all or assign all to 0, However...\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           X       Y       Z\n       <num>   <num>   <num>\n 1: 572471.7 5709038 -0.0183\n 2: 572469.0 5709021 -0.0044\n 3: 572475.5 5709041 -0.0315\n 4: 572477.3 5709041 -0.0004\n 5: 572475.2 5709040 -0.0013\n 6: 572476.9 5709041 -0.0088\n 7: 572459.1 5709064 -0.0035\n 8: 572477.3 5709041 -0.0041\n 9: 572460.3 5709058 -0.0034\n10: 572458.5 5709062 -0.0015\n11: 572462.5 5709046 -0.1952\n12: 572480.8 5709064 -0.0056\n13: 572483.4 5709069 -0.0163\n14: 572483.8 5709068 -0.0514\n15: 572483.8 5709068 -0.0330\n16: 572483.4 5709068 -0.0129\n17: 572488.9 5709023 -0.0133\n18: 572476.2 5709047 -0.0031\n19: 572451.9 5709020 -0.0029\n20: 572483.6 5709068 -0.0488\n21: 572484.9 5709062 -0.0040\n22: 572452.1 5709020 -0.0102\n23: 572452.0 5709021 -0.0030\n24: 572488.8 5709054 -0.0037\n25: 572476.1 5709032 -0.0070\n26: 572452.2 5709020 -0.0227\n27: 572491.1 5709069 -0.0163\n28: 572488.9 5709023 -0.0496\n29: 572483.9 5709068 -0.0246\n30: 572483.4 5709068 -0.0099\n31: 572484.7 5709063 -0.0017\n32: 572477.9 5709064 -0.0101\n33: 572478.2 5709065 -0.0129\n34: 572482.9 5709060 -0.0112\n35: 572494.0 5709053 -0.0001\n36: 572491.3 5709055 -0.0017\n37: 572476.1 5709047 -0.0046\n38: 572475.6 5709050 -0.0004\n39: 572491.0 5709039 -0.0019\n40: 572473.3 5709046 -0.0006\n41: 572478.1 5709039 -0.0100\n42: 572493.1 5709032 -0.0122\n43: 572470.5 5709037 -0.0157\n44: 572490.8 5709032 -0.0080\n45: 572477.5 5709041 -0.0002\n46: 572474.1 5709035 -0.0131\n47: 572493.0 5709032 -0.0166\n48: 572477.7 5709040 -0.0088\n49: 572476.5 5709052 -0.0075\n50: 572473.1 5709038 -0.0014\n51: 572474.0 5709035 -0.0297\n           X       Y       Z\n```\n\n\n:::\n\n```{.r .cell-code}\n# Forest structural complexity (Box dimension)\n\ncloud = las_norm@data[Z>0.5, 1:3] # Here, all points above 0.5 meter and only X,Y,z coordinates \n\ndb <- box_dimension(cloud = cloud, \n                    lowercutoff = 0.01, \n                    rm_int_box = FALSE, \n                    plot = FALSE )\nstr(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :Classes 'tidytable', 'tbl', 'data.table' and 'data.frame':\t13 obs. of  2 variables:\n  ..$ log.box.size: num [1:13] 0 0.693 1.386 2.079 2.773 ...\n  ..$ log.voxels  : num [1:13] 1.39 2.89 4.32 6.04 7.56 ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ :Classes 'tidytable', 'tbl', 'data.table' and 'data.frame':\t1 obs. of  4 variables:\n  ..$ r.squared    : num 0.964\n  ..$ adj.r.squared: num 0.96\n  ..$ intercept    : num 2.24\n  ..$ slope        : num 1.84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Box Dimension (slope)\ndb[[2]]$slope\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.838747\n```\n\n\n:::\n\n```{.r .cell-code}\ndb[[2]]$r.squared # show similarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9636752\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualization\n# 2D Plot\nbox_dimension(cloud[, 1:3], plot = \"2D\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tidytable: 13 Ã— 2\n   log.box.size log.voxels\n          <dbl>      <dbl>\n 1        0           1.39\n 2        0.693       2.89\n 3        1.39        4.32\n 4        2.08        6.04\n 5        2.77        7.56\n 6        3.47        9.11\n 7        4.16       10.6 \n 8        4.85       12.1 \n 9        5.55       13.6 \n10        6.24       14.8 \n11        6.93       15.3 \n12        7.62       15.4 \n13        8.32       15.4 \n\n[[2]]\n# A tidytable: 1 Ã— 4\n  r.squared adj.r.squared intercept slope\n      <dbl>         <dbl>     <dbl> <dbl>\n1     0.964         0.960      2.24  1.84\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3D Plot\nbox_dimension(cloud[, 1:3], plot = \"3D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPanning plot on rgl device: 4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tidytable: 13 Ã— 2\n   log.box.size log.voxels\n          <dbl>      <dbl>\n 1        0           1.39\n 2        0.693       2.89\n 3        1.39        4.32\n 4        2.08        6.04\n 5        2.77        7.56\n 6        3.47        9.11\n 7        4.16       10.6 \n 8        4.85       12.1 \n 9        5.55       13.6 \n10        6.24       14.8 \n11        6.93       15.3 \n12        7.62       15.4 \n13        8.32       15.4 \n\n[[2]]\n# A tidytable: 1 Ã— 4\n  r.squared adj.r.squared intercept slope\n      <dbl>         <dbl>     <dbl> <dbl>\n1     0.964         0.960      2.24  1.84\n```\n\n\n:::\n:::\n",
    "supporting": [
      "lidar_forest_structure_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}