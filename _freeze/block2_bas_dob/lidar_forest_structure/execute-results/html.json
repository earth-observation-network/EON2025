{
  "hash": "8a3f3cf1711a781ae1ba7fd682a074f7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Processing of 3D Lidar data to assess forest structure\"\nauthor: \"Prakash Basnet and Svenja Dobelmann\"\n---\n\n\ncheck out the manual of the lidR package: https://r-lidar.github.io/lidRbook/ \n\n## 0. Setup\n\n### Install and load required libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## install libraries\n# install.packges(\"lidR\")\n# install.packages(\"terra\")\n# install.packages(\"sf\")\n# install.packages(\"rTwig\")\n# install.packages('lidRviewer', repos = c('https://r-lidar.r-universe.dev'))\n\n\nlibrary(lidR)\nlibrary(terra)\nlibrary(sf)\nlibrary(lidRviewer)\nlibrary(dplyr)\nlibrary(rTwig)\n```\n:::\n\n\n\n### download the data\ndownload lidar point cloud and ground truth data (BI) from owncloud. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data access\nurl_las <- \"https://cloud.hawk.de/index.php/s/pB4RRmLb4Xxy4Qj/download\"\ndownload.file(url_las, destfile = \"uls_goewa.laz\", mode = \"wb\")\n\nurl_bi <- \"https://cloud.hawk.de/index.php/s/5npprfZYLjg5ip5/download\"\ndownload.file(url_bi, destfile = \"trees_bi.gpkg\", mode = \"wb\")\n```\n:::\n\n\n\n### import the data \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlas <- readLAS(\"uls_goewa.laz\")\ntrees_bi <- st_read(\"trees_bi.gpkg\")\n```\n:::\n\n\nlet´s inspect the data. \n1) whats the point density of the lidar data? \n2) whats the total number of points and pulses and what is the difference between the two? \n3) is there any classification in the point cloud? \n4) how many trees were measured in the BI? \n5) which tree species are present in the plot? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(las)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass        : LAS (v1.2 format 3)\nmemory       : 313.2 Mb \nextent       : 572445.4, 572496.1, 5709020, 5709071 (xmin, xmax, ymin, ymax)\ncoord. ref.  : WGS 84 / UTM zone 32N \narea         : 2602 m²\npoints       : 5.13 million points\ntype         : terrestrial\ndensity      : 1971.94 points/m²\ndensity      : 1660.17 pulses/m²\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(las)\nprint(trees_bi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 69 features and 17 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 572446.5 ymin: 5709021 xmax: 572495.8 ymax: 5709069\nProjected CRS: WGS 84 / UTM zone 32N\nFirst 10 features:\n   IDPlots          Name Plots.Bem ID      X_m     Y_m    Z_m Species Spec_txt\n1        1 GoeWald Fla 1      <NA>  1 572468.6 5709043 -0.448      22       Bu\n2        1 GoeWald Fla 1      <NA>  2 572467.4 5709044 -0.466      22       Bu\n3        1 GoeWald Fla 1      <NA>  3 572462.7 5709041 -0.443      22       Bu\n4        1 GoeWald Fla 1      <NA>  4 572459.8 5709039 -0.657      22       Bu\n5        1 GoeWald Fla 1      <NA>  5 572455.0 5709045 -0.971      22       Bu\n6        1 GoeWald Fla 1      <NA>  6 572455.1 5709048 -0.978      22       Bu\n7        1 GoeWald Fla 1      <NA>  7 572459.6 5709050 -0.723      22       Bu\n8        1 GoeWald Fla 1      <NA>  8 572460.5 5709052 -0.920      22       Bu\n9        1 GoeWald Fla 1      <NA>  9 572463.9 5709053 -0.747      22       Bu\n10       1 GoeWald Fla 1      <NA> 10 572468.1 5709048 -0.619      22       Bu\n   DBH_mm Vit Bruch                Schirm Schiefer.B Trees.Bem   x_lok  y_lok\n1     354 leb  nein geringe �berschirmung       Nein      <NA>  -2.197 -2.543\n2     345 leb  nein geringe �berschirmung       Nein      <NA>  -3.371 -1.518\n3     518 leb  nein geringe �berschirmung       Nein      <NA>  -8.087 -3.932\n4     373 leb  nein    Hohe �berschirmung       Nein      <NA> -11.067 -6.176\n5     350 leb  nein    Hohe �berschirmung       Nein      <NA> -15.776 -0.631\n6     388 leb  nein geringe �berschirmung       Nein      <NA> -15.576  2.703\n7     264 tot    ja                  <NA>       Nein      <NA> -11.070  4.367\n8     404 leb  nein geringe �berschirmung       Nein      <NA> -10.178  6.296\n9     464 leb  nein geringe �berschirmung       Nein      <NA>  -6.741  7.432\n10    291 leb    ja  Komplett �berschirmt       Nein      <NA>  -2.589  2.832\n                       geom\n1  POINT (572468.6 5709043)\n2  POINT (572467.4 5709044)\n3  POINT (572462.7 5709041)\n4  POINT (572459.8 5709039)\n5    POINT (572455 5709045)\n6  POINT (572455.1 5709048)\n7  POINT (572459.6 5709050)\n8  POINT (572460.5 5709052)\n9  POINT (572463.9 5709053)\n10 POINT (572468.1 5709048)\n```\n\n\n:::\n:::\n\n\n\n## 1. Calculating Terrain Models \nNext we are calculating terrain models, using triangulation (TIN = Triangulated Irregular Network). Since the data is already ground classified we can skip the classification step. The DEM is using the ground return points to interpolate the surface. In contrast, the digital surface model is using the highest lidar returns to represent the top of any object above the ground. Subtracting the two gives us the canopy height. \n\ncheck out the documentation of the rasterize_terrain algorithm. Try out different interpolation algorithms and different resolutions. Compare the results visually. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem <- rasterize_terrain(las, res = 0.5, algorithm = tin())\ndsm <- rasterize_canopy(las, res = 0.5, algorithm = dsmtin(max_edge = 8))\nchm <- dsm - dem\nchm <- terra::focal(chm, w = 3, fun = mean, na.rm = TRUE) # smoothing results \n\npar(mfrow = c(1,3))\nplot(dem, main = \"digital elevation model\")\nplot(dsm, main = \"digital surface model\")\nplot(chm, main = \"canopy heigt model\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n\n```{.r .cell-code}\n#writeRaster(dem, \"./data/output/dem.tif\", overwrite=TRUE)\n#writeRaster(dsm, \"./data/output/dsm.tif\", overwrite=TRUE)\n#writeRaster(chm, \"./data/output/chm.tif\", overwrite=TRUE)\n```\n:::\n\n\n\n## 2. Individual Tree Detection\nIndividual Tree Detection (ITD) is the process of spatially locating trees (f.i to extract height information). Tree tops can be detected by applying a Local Maximum Filter (LMF) on the loaded data set. The number of detected trees is correlated to the window size (ws) argument. Small windows sizes usually gives more trees, while large windows size generally miss smaller trees that are “hidden” by big trees that contain the highest points in the neighbourhood. We will use the Tree detection function with variable window size. Any points below 2 m will equate to a window size of 3 m, while points above 20 meters equate to a window size of 5 m. Anything between 2 and 20 meter will have a non-linear relationship.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function for Local Maximum Filter with variable windows size\n\nf <- function(x) {\n  y <- 2.6 * (-(exp(-0.08*(x-2)) - 1)) + 3 \n  # from https://r-lidar.github.io/lidRbook/itd.html\n  y[x < 2] <- 3\n  y[x > 20] <- 5\n  return(y)\n}\n\nheights <- seq(-5,35,0.5)\nws <- f(heights)\n\nplot(heights, ws, type = \"l\",  ylim = c(0,5))\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-6-1.png){width=480}\n:::\n:::\n\n\n  \n  Let´s run the tree detection algorithm using the user-defined ws function and the CHM created beforehand. Compare the results with the ground truth BI data. \n- How many of the trees could be detected in the lidar data?  \n- what could be the reasons for that? \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ttops <- locate_trees(las, lmf(f)) # only run this if you have a fast computer! \nttops <- locate_trees(chm, lmf(f)) \n\n# plot results \nplot(chm, col = height.colors(50))\nplot(sf::st_geometry(trees_bi), add = TRUE, pch = 2, col =\"blue\")\nplot(sf::st_geometry(ttops), add = TRUE, pch = 3, col = \"black\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-7-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# 3D plot\nlas_norm <- normalize_height(las, knnidw()) # normalize point cloud for this vizualisation \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInverse distance weighting: [==================================----------------] 68% (6 threads)\nInverse distance weighting: [==================================----------------] 69% (6 threads)\nInverse distance weighting: [===================================---------------] 70% (6 threads)\nInverse distance weighting: [===================================---------------] 71% (6 threads)\nInverse distance weighting: [====================================--------------] 72% (6 threads)\nInverse distance weighting: [====================================--------------] 73% (6 threads)\nInverse distance weighting: [=====================================-------------] 74% (6 threads)\nInverse distance weighting: [=====================================-------------] 75% (6 threads)\nInverse distance weighting: [======================================------------] 76% (6 threads)\nInverse distance weighting: [======================================------------] 77% (6 threads)\nInverse distance weighting: [=======================================-----------] 78% (6 threads)\nInverse distance weighting: [=======================================-----------] 79% (6 threads)\nInverse distance weighting: [========================================----------] 80% (6 threads)\nInverse distance weighting: [========================================----------] 81% (6 threads)\nInverse distance weighting: [=========================================---------] 82% (6 threads)\nInverse distance weighting: [=========================================---------] 83% (6 threads)\nInverse distance weighting: [==========================================--------] 84% (6 threads)\nInverse distance weighting: [==========================================--------] 85% (6 threads)\nInverse distance weighting: [===========================================-------] 86% (6 threads)\nInverse distance weighting: [===========================================-------] 87% (6 threads)\nInverse distance weighting: [============================================------] 88% (6 threads)\nInverse distance weighting: [============================================------] 89% (6 threads)\nInverse distance weighting: [=============================================-----] 90% (6 threads)\nInverse distance weighting: [=============================================-----] 91% (6 threads)\nInverse distance weighting: [==============================================----] 92% (6 threads)\nInverse distance weighting: [==============================================----] 93% (6 threads)\nInverse distance weighting: [===============================================---] 94% (6 threads)\nInverse distance weighting: [===============================================---] 95% (6 threads)\nInverse distance weighting: [================================================--] 96% (6 threads)\nInverse distance weighting: [================================================--] 97% (6 threads)\nInverse distance weighting: [=================================================-] 98% (6 threads)\nInverse distance weighting: [=================================================-] 99% (6 threads)\nInverse distance weighting: [==================================================] 100% (6 threads)\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- plot(las_norm, bg = \"white\", size = 4)\nadd_treetops3d(x, ttops)\n\n#writeVector(vect(ttops), \"./data/output/ttops_chm_.gpkg\", overwrite=TRUE)\n```\n:::\n\n\n\n## 3. Individual Tree Segmentation\nIndividual Tree Segmentation (ITS) is the process of individually delineating detected trees. Even when the algorithm is raster-based (which is the case of dalponte2016()), lidR segments the point cloud and assigns an ID to each point by inserting a new attribute named treeID in the LAS object. This means that every point is associated with a particular tree. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalgo <- dalponte2016(chm, ttops)\nlas_seg <- segment_trees(las_norm, algo) # segment point cloud\nx <- plot(las_seg, bg = \"white\", size = 4, color = \"treeID\") # visualize trees\nadd_treetops3d(x, ttops)\n```\n:::\n\n\n\n## 4. Deriving Metrics using the area-based approach \nthe Area-Based Approach (ABA) allows the creation of wall-to-wall predictions of forest inventory attributes (e.g. basal area or total volume per hectare) by linking ALS variables with field measured references.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_metr <- pixel_metrics(las, res = 0.5, func = .stdmetrics)\nplot(r_metr)\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n## 5.Forest structural complexity \n(Fractal complexity analysis/ voxel-based box-count dimension or box dimension (Db) method)  \nThe box dimension quantifies structural complexity of point clouds using a fractal box-counting approach.   \nIt is defined as the slope of the regression between log box (voxel) count and log inverse box (voxel) size, \nwith higher R² values indicating stronger self-similarity.\nReliable estimates require high-resolution (≤1 cm) point clouds with minimal occlusion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read data, check and pre-process with lidR\n#data <- readLAS(\"uls_goewa.laz\")\nprint(las)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass        : LAS (v1.2 format 3)\nmemory       : 313.2 Mb \nextent       : 572445.4, 572496.1, 5709020, 5709071 (xmin, xmax, ymin, ymax)\ncoord. ref.  : WGS 84 / UTM zone 32N \narea         : 2602 m²\npoints       : 5.13 million points\ntype         : terrestrial\ndensity      : 1971.94 points/m²\ndensity      : 1660.17 pulses/m²\n```\n\n\n:::\n\n```{.r .cell-code}\nlas_check(las) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Checking the data\n  - Checking coordinates...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates type...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates range...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates quantization...\u001b[0;32m ✓\u001b[0m\n  - Checking attributes type...\u001b[0;32m ✓\u001b[0m\n  - Checking ReturnNumber validity...\u001b[0;32m ✓\u001b[0m\n  - Checking NumberOfReturns validity...\u001b[0;32m ✓\u001b[0m\n  - Checking ReturnNumber vs. NumberOfReturns...\u001b[0;32m ✓\u001b[0m\n  - Checking RGB validity...\u001b[0;32m ✓\u001b[0m\n  - Checking absence of NAs...\u001b[0;32m ✓\u001b[0m\n  - Checking duplicated points...\u001b[0;32m ✓\u001b[0m\n  - Checking degenerated ground points...\u001b[0;32m ✓\u001b[0m\n  - Checking attribute population...\n \u001b[0;32m   🛈 'PointSourceID' attribute is not populated\u001b[0m\n \u001b[0;32m   🛈 'ScanDirectionFlag' attribute is not populated\u001b[0m\n \u001b[0;32m   🛈 'EdgeOfFlightline' attribute is not populated\u001b[0m\n  - Checking gpstime incoherances\u001b[0;32m ✓\u001b[0m\n  - Checking flag attributes...\u001b[0;32m ✓\u001b[0m\n  - Checking user data attribute...\u001b[0;32m ✓\u001b[0m\n Checking the header\n  - Checking header completeness...\u001b[0;32m ✓\u001b[0m\n  - Checking scale factor validity...\u001b[0;32m ✓\u001b[0m\n  - Checking point data format ID validity...\u001b[0;32m ✓\u001b[0m\n  - Checking extra bytes attributes validity...\u001b[0;32m ✓\u001b[0m\n  - Checking the bounding box validity...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinate reference system...\u001b[0;32m ✓\u001b[0m\n Checking header vs data adequacy\n  - Checking attributes vs. point format...\u001b[0;32m ✓\u001b[0m\n  - Checking header bbox vs. actual content...\u001b[0;32m ✓\u001b[0m\n  - Checking header number of points vs. actual content...\u001b[0;32m ✓\u001b[0m\n  - Checking header return number vs. actual content...\u001b[0;32m ✓\u001b[0m\n Checking coordinate reference system...\n  - Checking if the CRS was understood by R...\u001b[0;32m ✓\u001b[0m\n Checking preprocessing already done \n  - Checking ground classification...\u001b[0;32m yes\u001b[0m\n  - Checking normalization...\u001b[0;31m no\u001b[0m\n  - Checking negative outliers...\u001b[0;32m ✓\u001b[0m\n  - Checking flightline classification...\u001b[0;31m no\u001b[0m\n Checking compression\n  - Checking attribute compression...\n   -  ScanDirectionFlag is compressed\n   -  EdgeOfFlightline is compressed\n   -  Synthetic_flag is compressed\n   -  Keypoint_flag is compressed\n   -  Withheld_flag is compressed\n   -  UserData is compressed\n   -  PointSourceID is compressed\n```\n\n\n:::\n\n```{.r .cell-code}\nlas_norm <- normalize_height(las = las, \n                        algorithm = tin(), \n                        use_class = 2)\n\nlas_check(las_norm) # check negative outliers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Checking the data\n  - Checking coordinates...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates type...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates range...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinates quantization...\u001b[0;32m ✓\u001b[0m\n  - Checking attributes type...\u001b[0;32m ✓\u001b[0m\n  - Checking ReturnNumber validity...\u001b[0;32m ✓\u001b[0m\n  - Checking NumberOfReturns validity...\u001b[0;32m ✓\u001b[0m\n  - Checking ReturnNumber vs. NumberOfReturns...\u001b[0;32m ✓\u001b[0m\n  - Checking RGB validity...\u001b[0;32m ✓\u001b[0m\n  - Checking absence of NAs...\u001b[0;32m ✓\u001b[0m\n  - Checking duplicated points...\u001b[0;32m ✓\u001b[0m\n  - Checking degenerated ground points...\u001b[0;32m ✓\u001b[0m\n  - Checking attribute population...\n \u001b[0;32m   🛈 'PointSourceID' attribute is not populated\u001b[0m\n \u001b[0;32m   🛈 'ScanDirectionFlag' attribute is not populated\u001b[0m\n \u001b[0;32m   🛈 'EdgeOfFlightline' attribute is not populated\u001b[0m\n  - Checking gpstime incoherances\u001b[0;32m ✓\u001b[0m\n  - Checking flag attributes...\u001b[0;32m ✓\u001b[0m\n  - Checking user data attribute...\u001b[0;32m ✓\u001b[0m\n Checking the header\n  - Checking header completeness...\u001b[0;32m ✓\u001b[0m\n  - Checking scale factor validity...\u001b[0;32m ✓\u001b[0m\n  - Checking point data format ID validity...\u001b[0;32m ✓\u001b[0m\n  - Checking extra bytes attributes validity...\u001b[0;32m ✓\u001b[0m\n  - Checking the bounding box validity...\u001b[0;32m ✓\u001b[0m\n  - Checking coordinate reference system...\u001b[0;32m ✓\u001b[0m\n Checking header vs data adequacy\n  - Checking attributes vs. point format...\u001b[0;32m ✓\u001b[0m\n  - Checking header bbox vs. actual content...\u001b[0;32m ✓\u001b[0m\n  - Checking header number of points vs. actual content...\u001b[0;32m ✓\u001b[0m\n  - Checking header return number vs. actual content...\u001b[0;32m ✓\u001b[0m\n Checking coordinate reference system...\n  - Checking if the CRS was understood by R...\u001b[0;32m ✓\u001b[0m\n Checking preprocessing already done \n  - Checking ground classification...\u001b[0;32m yes\u001b[0m\n  - Checking normalization...\u001b[0;32m yes\u001b[0m\n  - Checking negative outliers...\n \u001b[1;33m   ⚠ 51 points below 0\u001b[0m\n  - Checking flightline classification...\u001b[0;31m no\u001b[0m\n Checking compression\n  - Checking attribute compression...\n   -  ScanDirectionFlag is compressed\n   -  EdgeOfFlightline is compressed\n   -  Synthetic_flag is compressed\n   -  Keypoint_flag is compressed\n   -  Withheld_flag is compressed\n   -  UserData is compressed\n   -  PointSourceID is compressed\n```\n\n\n:::\n\n```{.r .cell-code}\nview(las_norm)\n            #Rotate with left mouse button\n            #Zoom with mouse wheel\n            #Pan with right mouse button\n            #Keyboard r or g or b to color with RGB\n            #Keyboard z to color with Z\n            #Keyboard i to color with Intensity\n            #Keyboard c to color with Classification\n            #Keyboard + or - to change the point size\n            #Keyboard l to enable/disable eyes-dome lightning\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlas_norm@data[Z<0, 1:3] # Here options are either remove all or assign all to 0, However...\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           X       Y       Z\n       <num>   <num>   <num>\n 1: 572471.7 5709038 -0.0183\n 2: 572469.0 5709021 -0.0044\n 3: 572475.5 5709041 -0.0315\n 4: 572477.3 5709041 -0.0004\n 5: 572475.2 5709040 -0.0013\n 6: 572476.9 5709041 -0.0088\n 7: 572459.1 5709064 -0.0035\n 8: 572477.3 5709041 -0.0041\n 9: 572460.3 5709058 -0.0034\n10: 572458.5 5709062 -0.0015\n11: 572462.5 5709046 -0.1952\n12: 572480.8 5709064 -0.0056\n13: 572483.4 5709069 -0.0163\n14: 572483.8 5709068 -0.0514\n15: 572483.8 5709068 -0.0330\n16: 572483.4 5709068 -0.0129\n17: 572488.9 5709023 -0.0133\n18: 572476.2 5709047 -0.0031\n19: 572451.9 5709020 -0.0029\n20: 572483.6 5709068 -0.0488\n21: 572484.9 5709062 -0.0040\n22: 572452.1 5709020 -0.0102\n23: 572452.0 5709021 -0.0030\n24: 572488.8 5709054 -0.0037\n25: 572476.1 5709032 -0.0070\n26: 572452.2 5709020 -0.0227\n27: 572491.1 5709069 -0.0163\n28: 572488.9 5709023 -0.0496\n29: 572483.9 5709068 -0.0246\n30: 572483.4 5709068 -0.0099\n31: 572484.7 5709063 -0.0017\n32: 572477.9 5709064 -0.0101\n33: 572478.2 5709065 -0.0129\n34: 572482.9 5709060 -0.0112\n35: 572494.0 5709053 -0.0001\n36: 572491.3 5709055 -0.0017\n37: 572476.1 5709047 -0.0046\n38: 572475.6 5709050 -0.0004\n39: 572491.0 5709039 -0.0019\n40: 572473.3 5709046 -0.0006\n41: 572478.1 5709039 -0.0100\n42: 572493.1 5709032 -0.0122\n43: 572470.5 5709037 -0.0157\n44: 572490.8 5709032 -0.0080\n45: 572477.5 5709041 -0.0002\n46: 572474.1 5709035 -0.0131\n47: 572493.0 5709032 -0.0166\n48: 572477.7 5709040 -0.0088\n49: 572476.5 5709052 -0.0075\n50: 572473.1 5709038 -0.0014\n51: 572474.0 5709035 -0.0297\n           X       Y       Z\n```\n\n\n:::\n\n```{.r .cell-code}\n# Forest structural complexity (Box dimension)\n\ncloud = las_norm@data[Z>0.5, 1:3] # Here, all points above 0.5 meter and only X,Y,z coordinates \n\ndb <- box_dimension(cloud = cloud, \n                    lowercutoff = 0.01, \n                    rm_int_box = FALSE, \n                    plot = FALSE )\nstr(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :Classes 'tidytable', 'tbl', 'data.table' and 'data.frame':\t13 obs. of  2 variables:\n  ..$ log.box.size: num [1:13] 0 0.693 1.386 2.079 2.773 ...\n  ..$ log.voxels  : num [1:13] 1.39 2.89 4.32 6.04 7.56 ...\n  ..- attr(*, \".internal.selfref\")=<externalptr> \n $ :Classes 'tidytable', 'tbl', 'data.table' and 'data.frame':\t1 obs. of  4 variables:\n  ..$ r.squared    : num 0.964\n  ..$ adj.r.squared: num 0.96\n  ..$ intercept    : num 2.24\n  ..$ slope        : num 1.84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Box Dimension (slope)\ndb[[2]]$slope\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.838747\n```\n\n\n:::\n\n```{.r .cell-code}\ndb[[2]]$r.squared # show similarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9636752\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualization\n# 2D Plot\nbox_dimension(cloud[, 1:3], plot = \"2D\")\n```\n\n::: {.cell-output-display}\n![](lidar_forest_structure_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tidytable: 13 × 2\n   log.box.size log.voxels\n          <dbl>      <dbl>\n 1        0           1.39\n 2        0.693       2.89\n 3        1.39        4.32\n 4        2.08        6.04\n 5        2.77        7.56\n 6        3.47        9.11\n 7        4.16       10.6 \n 8        4.85       12.1 \n 9        5.55       13.6 \n10        6.24       14.8 \n11        6.93       15.3 \n12        7.62       15.4 \n13        8.32       15.4 \n\n[[2]]\n# A tidytable: 1 × 4\n  r.squared adj.r.squared intercept slope\n      <dbl>         <dbl>     <dbl> <dbl>\n1     0.964         0.960      2.24  1.84\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3D Plot\nbox_dimension(cloud[, 1:3], plot = \"3D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPanning plot on rgl device: 4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tidytable: 13 × 2\n   log.box.size log.voxels\n          <dbl>      <dbl>\n 1        0           1.39\n 2        0.693       2.89\n 3        1.39        4.32\n 4        2.08        6.04\n 5        2.77        7.56\n 6        3.47        9.11\n 7        4.16       10.6 \n 8        4.85       12.1 \n 9        5.55       13.6 \n10        6.24       14.8 \n11        6.93       15.3 \n12        7.62       15.4 \n13        8.32       15.4 \n\n[[2]]\n# A tidytable: 1 × 4\n  r.squared adj.r.squared intercept slope\n      <dbl>         <dbl>     <dbl> <dbl>\n1     0.964         0.960      2.24  1.84\n```\n\n\n:::\n:::\n",
    "supporting": [
      "lidar_forest_structure_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}